import {
  KHR_DF_FLAG_ALPHA_PREMULTIPLIED,
  KHR_DF_TRANSFER_SRGB,
  KHR_SUPERCOMPRESSION_NONE,
  KHR_SUPERCOMPRESSION_ZSTD,
  Q,
  VK_FORMAT_R16G16B16A16_SFLOAT,
  VK_FORMAT_R16G16_SFLOAT,
  VK_FORMAT_R16_SFLOAT,
  VK_FORMAT_R32G32B32A32_SFLOAT,
  VK_FORMAT_R32G32_SFLOAT,
  VK_FORMAT_R32_SFLOAT,
  VK_FORMAT_R8G8B8A8_SRGB,
  VK_FORMAT_R8G8B8A8_UNORM,
  VK_FORMAT_R8G8_SRGB,
  VK_FORMAT_R8G8_UNORM,
  VK_FORMAT_R8_SRGB,
  VK_FORMAT_R8_UNORM,
  VK_FORMAT_UNDEFINED,
  _defineProperty,
  read
} from "./chunk-7MPH4NFQ.js";
import {
  useFrame,
  useLoader,
  useThree
} from "./chunk-NWGYSPKM.js";
import {
  AddEquation,
  AdditiveBlending,
  AlwaysDepth,
  AnimationClip,
  AnimationMixer,
  BackSide,
  BasicDepthPacking,
  Bone,
  BooleanKeyframeTrack,
  Box2,
  Box3,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  Camera,
  ClampToEdgeWrapping,
  Clock,
  Color,
  ColorKeyframeTrack,
  CompressedTexture,
  CubeCamera,
  Curve,
  CustomBlending,
  CylinderGeometry,
  Data3DTexture,
  DataTexture,
  DataTexture3D,
  DepthStencilFormat,
  DepthTexture,
  DirectionalLight,
  DoubleSide,
  DstAlphaFactor,
  DstColorFactor,
  DynamicDrawUsage,
  EqualDepth,
  Euler,
  EventDispatcher,
  FileLoader as FileLoader2,
  Float32BufferAttribute,
  FloatType,
  FramebufferTexture,
  FrontSide,
  Frustum,
  GLSL3,
  GreaterDepth,
  GreaterEqualDepth,
  HalfFloatType,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  InterpolateDiscrete,
  InterpolateLinear,
  LessDepth,
  LessEqualDepth,
  Line,
  Line3,
  LineBasicMaterial,
  LineLoop,
  LineSegments,
  LinearEncoding,
  LinearFilter,
  LinearMipmapLinearFilter,
  LinearMipmapNearestFilter,
  Loader,
  LoaderUtils,
  LoadingManager,
  LuminanceFormat,
  Material,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshLambertMaterial,
  MeshMatcapMaterial,
  MeshNormalMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshToonMaterial,
  MirroredRepeatWrapping,
  NearestFilter,
  NearestMipmapLinearFilter,
  NearestMipmapNearestFilter,
  NeverDepth,
  NoBlending,
  NormalBlending,
  NotEqualDepth,
  NumberKeyframeTrack,
  Object3D,
  OneMinusSrcAlphaFactor,
  OrthographicCamera,
  PMREMGenerator,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  PointLight,
  Points,
  PointsMaterial,
  PropertyBinding,
  Quaternion,
  QuaternionKeyframeTrack,
  REVISION,
  RGBADepthPacking,
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format,
  RGFormat,
  RawShaderMaterial,
  Ray,
  Raycaster,
  RedFormat,
  RepeatWrapping,
  Scene,
  ShaderChunk,
  ShaderLib,
  ShaderMaterial,
  ShapePath,
  Skeleton,
  SkeletonHelper,
  SkinnedMesh,
  Sphere,
  SphereGeometry,
  SpotLight,
  SrcAlphaFactor,
  TangentSpaceNormalMap,
  Texture,
  TextureLoader,
  Triangle,
  Uint16BufferAttribute,
  Uint32BufferAttribute,
  Uniform,
  UniformsLib,
  UniformsUtils,
  UnsignedByteType,
  UnsignedInt248Type,
  UnsignedIntType,
  UnsignedShortType,
  Vector2,
  Vector3,
  Vector4,
  VectorKeyframeTrack,
  VideoTexture,
  WebGLCubeRenderTarget,
  WebGLMultipleRenderTargets,
  WebGLMultisampleRenderTarget,
  WebGLRenderTarget,
  ZeroFactor,
  sRGBEncoding
} from "./chunk-PK3IDSHG.js";
import {
  _extends
} from "./chunk-XDANE42M.js";
import {
  require_react
} from "./chunk-JLBVE3FS.js";
import {
  __toESM
} from "./chunk-HUBM7RA2.js";

// node_modules/postprocessing/build/postprocessing.esm.js
var adaptive_luminance_default = "#include <packing>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\nuniform lowp sampler2D luminanceBuffer0;uniform lowp sampler2D luminanceBuffer1;uniform float minLuminance;uniform float deltaTime;uniform float tau;varying vec2 vUv;void main(){float l0=unpackRGBAToFloat(texture2D(luminanceBuffer0,vUv));\n#if __VERSION__ < 300\nfloat l1=texture2DLodEXT(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\n#else\nfloat l1=textureLod(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\n#endif\nl0=max(minLuminance,l0);l1=max(minLuminance,l1);float adaptedLum=l0+(l1-l0)*(1.0-exp(-deltaTime*tau));gl_FragColor=(adaptedLum==1.0)?vec4(1.0):packFloatToRGBA(adaptedLum);}";
var common_default = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}";
var AdaptiveLuminanceMaterial = class extends ShaderMaterial {
  constructor() {
    super({
      name: "AdaptiveLuminanceMaterial",
      defines: {
        THREE_REVISION: REVISION.replace(/\D+/g, ""),
        MIP_LEVEL_1X1: "0.0"
      },
      uniforms: {
        luminanceBuffer0: new Uniform(null),
        luminanceBuffer1: new Uniform(null),
        minLuminance: new Uniform(0.01),
        deltaTime: new Uniform(0),
        tau: new Uniform(1)
      },
      extensions: {
        shaderTextureLOD: true
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: adaptive_luminance_default,
      vertexShader: common_default
    });
    this.toneMapped = false;
  }
  set luminanceBuffer0(value) {
    this.uniforms.luminanceBuffer0.value = value;
  }
  setLuminanceBuffer0(value) {
    this.uniforms.luminanceBuffer0.value = value;
  }
  set luminanceBuffer1(value) {
    this.uniforms.luminanceBuffer1.value = value;
  }
  setLuminanceBuffer1(value) {
    this.uniforms.luminanceBuffer1.value = value;
  }
  set mipLevel1x1(value) {
    this.defines.MIP_LEVEL_1X1 = value.toFixed(1);
    this.needsUpdate = true;
  }
  setMipLevel1x1(value) {
    this.mipLevel1x1 = value;
  }
  set deltaTime(value) {
    this.uniforms.deltaTime.value = value;
  }
  setDeltaTime(value) {
    this.uniforms.deltaTime.value = value;
  }
  get minLuminance() {
    return this.uniforms.minLuminance.value;
  }
  set minLuminance(value) {
    this.uniforms.minLuminance.value = value;
  }
  getMinLuminance() {
    return this.uniforms.minLuminance.value;
  }
  setMinLuminance(value) {
    this.uniforms.minLuminance.value = value;
  }
  get adaptationRate() {
    return this.uniforms.tau.value;
  }
  set adaptationRate(value) {
    this.uniforms.tau.value = value;
  }
  getAdaptationRate() {
    return this.uniforms.tau.value;
  }
  setAdaptationRate(value) {
    this.uniforms.tau.value = value;
  }
};
var convolution_bokeh_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if PASS == 1\nuniform vec4 kernel64[32];\n#else\nuniform vec4 kernel16[8];\n#endif\nuniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;varying vec2 vUv;void main(){\n#ifdef FOREGROUND\nvec2 CoCNearFar=texture2D(cocBuffer,vUv).rg;float CoC=CoCNearFar.r*scale;\n#else\nfloat CoC=texture2D(cocBuffer,vUv).g*scale;\n#endif\nif(CoC==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{\n#ifdef FOREGROUND\nvec2 step=texelSize*max(CoC,CoCNearFar.g*scale);\n#else\nvec2 step=texelSize*CoC;\n#endif\n#if PASS == 1\nvec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;\n#else\nvec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;\n#endif\n}}";
var BokehMaterial = class extends ShaderMaterial {
  constructor(fill = false, foreground = false) {
    super({
      name: "BokehMaterial",
      defines: {
        PASS: fill ? "2" : "1"
      },
      uniforms: {
        inputBuffer: new Uniform(null),
        cocBuffer: new Uniform(null),
        texelSize: new Uniform(new Vector2()),
        kernel64: new Uniform(null),
        kernel16: new Uniform(null),
        scale: new Uniform(1)
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: convolution_bokeh_default,
      vertexShader: common_default
    });
    this.toneMapped = false;
    if (foreground) {
      this.defines.FOREGROUND = "1";
    }
    this.generateKernel();
  }
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  set cocBuffer(value) {
    this.uniforms.cocBuffer.value = value;
  }
  setCoCBuffer(value) {
    this.uniforms.cocBuffer.value = value;
  }
  get scale() {
    return this.uniforms.scale.value;
  }
  set scale(value) {
    this.uniforms.scale.value = value;
  }
  getScale(value) {
    return this.scale;
  }
  setScale(value) {
    this.scale = value;
  }
  generateKernel() {
    const GOLDEN_ANGLE = 2.39996323;
    const points64 = new Float64Array(128);
    const points16 = new Float64Array(32);
    let i64 = 0, i16 = 0;
    for (let i2 = 0, sqrt80 = Math.sqrt(80); i2 < 80; ++i2) {
      const theta = i2 * GOLDEN_ANGLE;
      const r = Math.sqrt(i2) / sqrt80;
      const u = r * Math.cos(theta), v3 = r * Math.sin(theta);
      if (i2 % 5 === 0) {
        points16[i16++] = u;
        points16[i16++] = v3;
      } else {
        points64[i64++] = u;
        points64[i64++] = v3;
      }
    }
    this.uniforms.kernel64.value = points64;
    this.uniforms.kernel16.value = points16;
  }
  setTexelSize(x, y) {
    this.uniforms.texelSize.value.set(x, y);
  }
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};
function getTextureDecoding(texture2, isWebGL2) {
  let decoding = "texel";
  if (texture2 !== null) {
    const revision = Number.parseInt(REVISION);
    const sRGB8Alpha8 = isWebGL2 && revision >= 133 && revision !== 135 && texture2.format === RGBAFormat && texture2.type === UnsignedByteType && texture2.encoding === sRGBEncoding;
    if (!sRGB8Alpha8) {
      switch (texture2.encoding) {
        case sRGBEncoding:
          decoding = "sRGBToLinear(texel)";
          break;
        case LinearEncoding:
          decoding = "texel";
          break;
        default:
          throw new Error(`Unsupported encoding: ${texture2.encoding}`);
      }
    }
  }
  return decoding;
}
function orthographicDepthToViewZ(depth, near, far) {
  return depth * (near - far) - near;
}
function viewZToOrthographicDepth(viewZ, near, far) {
  return Math.min(Math.max((viewZ + near) / (near - far), 0), 1);
}
var circle_of_confusion_default = "#include <common>\n#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform float focusDistance;uniform float focusRange;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}void main(){float depth=readDepth(vUv);\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\n#else\nfloat linearDepth=depth;\n#endif\nfloat signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}";
var CircleOfConfusionMaterial = class extends ShaderMaterial {
  constructor(camera) {
    super({
      name: "CircleOfConfusionMaterial",
      defines: {
        DEPTH_PACKING: "0"
      },
      uniforms: {
        depthBuffer: new Uniform(null),
        focusDistance: new Uniform(0),
        focusRange: new Uniform(0),
        cameraNear: new Uniform(0.3),
        cameraFar: new Uniform(1e3)
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: circle_of_confusion_default,
      vertexShader: common_default
    });
    this.toneMapped = false;
    this.uniforms.focalLength = this.uniforms.focusRange;
    this.copyCameraSettings(camera);
  }
  get near() {
    return this.uniforms.cameraNear.value;
  }
  get far() {
    return this.uniforms.cameraFar.value;
  }
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  setDepthBuffer(buffer2, depthPacking = BasicDepthPacking) {
    this.depthBuffer = buffer2;
    this.depthPacking = depthPacking;
  }
  get focusDistance() {
    return this.uniforms.focusDistance.value;
  }
  set focusDistance(value) {
    this.uniforms.focusDistance.value = value;
  }
  get worldFocusDistance() {
    return -orthographicDepthToViewZ(this.focusDistance, this.near, this.far);
  }
  set worldFocusDistance(value) {
    this.focusDistance = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  getFocusDistance(value) {
    this.uniforms.focusDistance.value = value;
  }
  setFocusDistance(value) {
    this.uniforms.focusDistance.value = value;
  }
  get focalLength() {
    return this.focusRange;
  }
  set focalLength(value) {
    this.focusRange = value;
  }
  get focusRange() {
    return this.uniforms.focusRange.value;
  }
  set focusRange(value) {
    this.uniforms.focusRange.value = value;
  }
  get worldFocusRange() {
    return -orthographicDepthToViewZ(this.focusRange, this.near, this.far);
  }
  set worldFocusRange(value) {
    this.focusRange = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  getFocalLength(value) {
    return this.focusRange;
  }
  setFocalLength(value) {
    this.focusRange = value;
  }
  adoptCameraSettings(camera) {
    this.copyCameraSettings(camera);
  }
  copyCameraSettings(camera) {
    if (camera) {
      this.uniforms.cameraNear.value = camera.near;
      this.uniforms.cameraFar.value = camera.far;
      if (camera instanceof PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
      this.needsUpdate = true;
    }
  }
};
var BlendFunction = {
  SKIP: 9,
  SET: 30,
  ADD: 0,
  ALPHA: 1,
  AVERAGE: 2,
  COLOR: 3,
  COLOR_BURN: 4,
  COLOR_DODGE: 5,
  DARKEN: 6,
  DIFFERENCE: 7,
  DIVIDE: 8,
  DST: 9,
  EXCLUSION: 10,
  HARD_LIGHT: 11,
  HARD_MIX: 12,
  HUE: 13,
  INVERT: 14,
  INVERT_RGB: 15,
  LIGHTEN: 16,
  LINEAR_BURN: 17,
  LINEAR_DODGE: 18,
  LINEAR_LIGHT: 19,
  LUMINOSITY: 20,
  MULTIPLY: 21,
  NEGATION: 22,
  NORMAL: 23,
  OVERLAY: 24,
  PIN_LIGHT: 25,
  REFLECT: 26,
  SATURATION: 27,
  SCREEN: 28,
  SOFT_LIGHT: 29,
  SRC: 30,
  SUBTRACT: 31,
  VIVID_LIGHT: 32
};
var ColorChannel = {
  RED: 0,
  GREEN: 1,
  BLUE: 2,
  ALPHA: 3
};
var DepthTestStrategy = {
  DEFAULT: 0,
  KEEP_MAX_DEPTH: 1,
  DISCARD_MAX_DEPTH: 2
};
var EdgeDetectionMode = {
  DEPTH: 0,
  LUMA: 1,
  COLOR: 2
};
var EffectAttribute = {
  NONE: 0,
  DEPTH: 1,
  CONVOLUTION: 2
};
var EffectShaderSection = {
  FRAGMENT_HEAD: "FRAGMENT_HEAD",
  FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
  FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
  VERTEX_HEAD: "VERTEX_HEAD",
  VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
};
var GlitchMode = {
  DISABLED: 0,
  SPORADIC: 1,
  CONSTANT_MILD: 2,
  CONSTANT_WILD: 3
};
var KernelSize = {
  VERY_SMALL: 0,
  SMALL: 1,
  MEDIUM: 2,
  LARGE: 3,
  VERY_LARGE: 4,
  HUGE: 5
};
var LUTOperation = {
  SCALE_UP: "lut.scaleup"
};
var MaskFunction = {
  DISCARD: 0,
  MULTIPLY: 1,
  MULTIPLY_RGB_SET_ALPHA: 2
};
var PredicationMode = {
  DISABLED: 0,
  DEPTH: 1,
  CUSTOM: 2
};
var SMAAPreset = {
  LOW: 0,
  MEDIUM: 1,
  HIGH: 2,
  ULTRA: 3
};
var ToneMappingMode = {
  REINHARD: 0,
  REINHARD2: 1,
  REINHARD2_ADAPTIVE: 2,
  OPTIMIZED_CINEON: 3,
  ACES_FILMIC: 4
};
var VignetteTechnique = {
  DEFAULT: 0,
  ESKIL: 1
};
var convolution_kawase_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\n#include <encodings_fragment>\n}";
var convolution_kawase_default2 = "uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}";
var kernelPresets = [
  new Float32Array([0, 0]),
  new Float32Array([0, 1, 1]),
  new Float32Array([0, 1, 1, 2]),
  new Float32Array([0, 1, 2, 2, 3]),
  new Float32Array([0, 1, 2, 3, 4, 4, 5]),
  new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])
];
var KawaseBlurMaterial = class extends ShaderMaterial {
  constructor(texelSize = new Vector4()) {
    super({
      name: "KawaseBlurMaterial",
      uniforms: {
        inputBuffer: new Uniform(null),
        texelSize: new Uniform(new Vector4()),
        scale: new Uniform(1),
        kernel: new Uniform(0)
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: convolution_kawase_default,
      vertexShader: convolution_kawase_default2
    });
    this.toneMapped = false;
    this.setTexelSize(texelSize.x, texelSize.y);
    this.kernelSize = KernelSize.MEDIUM;
  }
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  setInputBuffer(value) {
    this.inputBuffer = value;
  }
  get kernelSequence() {
    return kernelPresets[this.kernelSize];
  }
  get scale() {
    return this.uniforms.scale.value;
  }
  set scale(value) {
    this.uniforms.scale.value = value;
  }
  getScale() {
    return this.uniforms.scale.value;
  }
  setScale(value) {
    this.uniforms.scale.value = value;
  }
  getKernel() {
    return null;
  }
  get kernel() {
    return this.uniforms.kernel.value;
  }
  set kernel(value) {
    this.uniforms.kernel.value = value;
  }
  setKernel(value) {
    this.kernel = value;
  }
  setTexelSize(x, y) {
    this.uniforms.texelSize.value.set(x, y, x * 0.5, y * 0.5);
  }
  setSize(width, height) {
    const x = 1 / width, y = 1 / height;
    this.uniforms.texelSize.value.set(x, y, x * 0.5, y * 0.5);
  }
};
var copy_default = "#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <encodings_fragment>\n#include <dithering_fragment>\n}";
var CopyMaterial = class extends ShaderMaterial {
  constructor() {
    super({
      name: "CopyMaterial",
      uniforms: {
        inputBuffer: new Uniform(null),
        opacity: new Uniform(1)
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: copy_default,
      vertexShader: common_default
    });
    this.toneMapped = false;
  }
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  getOpacity(value) {
    return this.uniforms.opacity.value;
  }
  setOpacity(value) {
    this.uniforms.opacity.value = value;
  }
};
var depth_comparison_default = "#include <packing>\n#include <clipping_planes_pars_fragment>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform float cameraNear;uniform float cameraFar;varying float vViewZ;varying vec4 vProjTexCoord;void main(){\n#include <clipping_planes_fragment>\nvec2 projTexCoord=(vProjTexCoord.xy/vProjTexCoord.w)*0.5+0.5;projTexCoord=clamp(projTexCoord,0.002,0.998);\n#if DEPTH_PACKING == 3201\nfloat fragCoordZ=unpackRGBAToDepth(texture2D(depthBuffer,projTexCoord));\n#else\nfloat fragCoordZ=texture2D(depthBuffer,projTexCoord).r;\n#endif\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(fragCoordZ,cameraNear,cameraFar);\n#else\nfloat viewZ=orthographicDepthToViewZ(fragCoordZ,cameraNear,cameraFar);\n#endif\nfloat depthTest=(-vViewZ>-viewZ)?1.0:0.0;gl_FragColor.rg=vec2(0.0,depthTest);}";
var depth_comparison_default2 = "#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying float vViewZ;varying vec4 vProjTexCoord;void main(){\n#include <skinbase_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <project_vertex>\nvViewZ=mvPosition.z;vProjTexCoord=gl_Position;\n#include <clipping_planes_vertex>\n}";
var DepthComparisonMaterial = class extends ShaderMaterial {
  constructor(depthTexture = null, camera) {
    super({
      name: "DepthComparisonMaterial",
      defines: {
        DEPTH_PACKING: "0"
      },
      uniforms: {
        depthBuffer: new Uniform(null),
        cameraNear: new Uniform(0.3),
        cameraFar: new Uniform(1e3)
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: depth_comparison_default,
      vertexShader: depth_comparison_default2
    });
    this.toneMapped = false;
    this.depthBuffer = depthTexture;
    this.depthPacking = RGBADepthPacking;
    this.copyCameraSettings(camera);
  }
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  setDepthBuffer(buffer2, depthPacking = RGBADepthPacking) {
    this.depthBuffer = buffer2;
    this.depthPacking = depthPacking;
  }
  adoptCameraSettings(camera) {
    this.copyCameraSettings(camera);
  }
  copyCameraSettings(camera) {
    if (camera) {
      this.uniforms.cameraNear.value = camera.near;
      this.uniforms.cameraFar.value = camera.far;
      if (camera instanceof PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
      this.needsUpdate = true;
    }
  }
};
var depth_downsampling_default = "#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\n#ifdef DOWNSAMPLE_NORMALS\nuniform lowp sampler2D normalBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[]=float[4](abs(c-samples[0]),abs(c-samples[1]),abs(c-samples[2]),abs(c-samples[3]));float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[]=float[4](readDepth(vUv0),readDepth(vUv1),readDepth(vUv2),readDepth(vUv3));int index=findBestDepth(d);\n#ifdef DOWNSAMPLE_NORMALS\nvec3 n[]=vec3[4](texture2D(normalBuffer,vUv0).rgb,texture2D(normalBuffer,vUv1).rgb,texture2D(normalBuffer,vUv2).rgb,texture2D(normalBuffer,vUv3).rgb);\n#else\nvec3 n[]=vec3[4](vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\n#endif\ngl_FragColor=vec4(n[index],d[index]);}";
var depth_downsampling_default2 = "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}";
var DepthDownsamplingMaterial = class extends ShaderMaterial {
  constructor() {
    super({
      name: "DepthDownsamplingMaterial",
      defines: {
        DEPTH_PACKING: "0"
      },
      uniforms: {
        depthBuffer: new Uniform(null),
        normalBuffer: new Uniform(null),
        texelSize: new Uniform(new Vector2())
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: depth_downsampling_default,
      vertexShader: depth_downsampling_default2
    });
    this.toneMapped = false;
  }
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  setDepthBuffer(buffer2, depthPacking = BasicDepthPacking) {
    this.depthBuffer = buffer2;
    this.depthPacking = depthPacking;
  }
  set normalBuffer(value) {
    this.uniforms.normalBuffer.value = value;
    if (value !== null) {
      this.defines.DOWNSAMPLE_NORMALS = "1";
    } else {
      delete this.defines.DOWNSAMPLE_NORMALS;
    }
    this.needsUpdate = true;
  }
  setNormalBuffer(value) {
    this.normalBuffer = value;
  }
  setTexelSize(x, y) {
    this.uniforms.texelSize.value.set(x, y);
  }
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};
var depth_mask_default = "#include <common>\n#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer0;uniform highp sampler2D depthBuffer1;\n#else\nuniform mediump sampler2D depthBuffer0;uniform mediump sampler2D depthBuffer1;\n#endif\nuniform sampler2D inputBuffer;uniform vec2 cameraNearFar;float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#endif\n}varying vec2 vUv;void main(){vec2 depth;\n#if DEPTH_PACKING_0 == 3201\ndepth.x=unpackRGBAToDepth(texture2D(depthBuffer0,vUv));\n#else\ndepth.x=texture2D(depthBuffer0,vUv).r;\n#endif\n#if DEPTH_PACKING_1 == 3201\ndepth.y=unpackRGBAToDepth(texture2D(depthBuffer1,vUv));\n#else\ndepth.y=texture2D(depthBuffer1,vUv).r;\n#endif\nbool isMaxDepth=(depth.x==1.0);\n#ifdef PERSPECTIVE_CAMERA\ndepth.x=viewZToOrthographicDepth(getViewZ(depth.x),cameraNearFar.x,cameraNearFar.y);depth.y=viewZToOrthographicDepth(getViewZ(depth.y),cameraNearFar.x,cameraNearFar.y);\n#endif\n#if DEPTH_TEST_STRATEGY == 0\nbool keep=depthTest(depth.x,depth.y);\n#elif DEPTH_TEST_STRATEGY == 1\nbool keep=isMaxDepth||depthTest(depth.x,depth.y);\n#else\nbool keep=!isMaxDepth&&depthTest(depth.x,depth.y);\n#endif\nif(keep){gl_FragColor=texture2D(inputBuffer,vUv);}else{discard;}}";
var DepthMaskMaterial = class extends ShaderMaterial {
  constructor() {
    super({
      name: "DepthMaskMaterial",
      defines: {
        DEPTH_EPSILON: "0.0001",
        DEPTH_PACKING_0: "0",
        DEPTH_PACKING_1: "0",
        DEPTH_TEST_STRATEGY: DepthTestStrategy.KEEP_MAX_DEPTH
      },
      uniforms: {
        inputBuffer: new Uniform(null),
        depthBuffer0: new Uniform(null),
        depthBuffer1: new Uniform(null),
        cameraNearFar: new Uniform(new Vector2(1, 1))
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: depth_mask_default,
      vertexShader: common_default
    });
    this.toneMapped = false;
    this.depthMode = LessDepth;
  }
  set depthBuffer0(value) {
    this.uniforms.depthBuffer0.value = value;
  }
  set depthPacking0(value) {
    this.defines.DEPTH_PACKING_0 = value.toFixed(0);
    this.needsUpdate = true;
  }
  setDepthBuffer0(buffer2, depthPacking = BasicDepthPacking) {
    this.depthBuffer0 = buffer2;
    this.depthPacking0 = depthPacking;
  }
  set depthBuffer1(value) {
    this.uniforms.depthBuffer1.value = value;
  }
  set depthPacking1(value) {
    this.defines.DEPTH_PACKING_1 = value.toFixed(0);
    this.needsUpdate = true;
  }
  setDepthBuffer1(buffer2, depthPacking = BasicDepthPacking) {
    this.depthBuffer1 = buffer2;
    this.depthPacking1 = depthPacking;
  }
  get maxDepthStrategy() {
    return Number(this.defines.DEPTH_TEST_STRATEGY);
  }
  set maxDepthStrategy(value) {
    this.defines.DEPTH_TEST_STRATEGY = value.toFixed(0);
    this.needsUpdate = true;
  }
  get keepFar() {
    return this.maxDepthStrategy;
  }
  set keepFar(value) {
    this.maxDepthStrategy = value ? DepthTestStrategy.KEEP_MAX_DEPTH : DepthTestStrategy.DISCARD_MAX_DEPTH;
  }
  getMaxDepthStrategy() {
    return this.maxDepthStrategy;
  }
  setMaxDepthStrategy(value) {
    this.maxDepthStrategy = value;
  }
  get epsilon() {
    return Number(this.defines.DEPTH_EPSILON);
  }
  set epsilon(value) {
    this.defines.DEPTH_EPSILON = value.toFixed(16);
    this.needsUpdate = true;
  }
  getEpsilon() {
    return this.epsilon;
  }
  setEpsilon(value) {
    this.epsilon = value;
  }
  get depthMode() {
    return Number(this.defines.DEPTH_MODE);
  }
  set depthMode(value) {
    let depthTest;
    switch (value) {
      case NeverDepth:
        depthTest = "false";
        break;
      case AlwaysDepth:
        depthTest = "true";
        break;
      case EqualDepth:
        depthTest = "abs(d1 - d0) <= DEPTH_EPSILON";
        break;
      case NotEqualDepth:
        depthTest = "abs(d1 - d0) > DEPTH_EPSILON";
        break;
      case LessDepth:
        depthTest = "d0 > d1";
        break;
      case LessEqualDepth:
        depthTest = "d0 >= d1";
        break;
      case GreaterEqualDepth:
        depthTest = "d0 <= d1";
        break;
      case GreaterDepth:
      default:
        depthTest = "d0 < d1";
        break;
    }
    this.defines.DEPTH_MODE = value.toFixed(0);
    this.defines["depthTest(d0, d1)"] = depthTest;
    this.needsUpdate = true;
  }
  getDepthMode() {
    return this.depthMode;
  }
  setDepthMode(mode) {
    this.depthMode = mode;
  }
  adoptCameraSettings(camera) {
    this.copyCameraSettings(camera);
  }
  copyCameraSettings(camera) {
    if (camera) {
      this.uniforms.cameraNearFar.value.set(camera.near, camera.far);
      if (camera instanceof PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
      this.needsUpdate = true;
    }
  }
};
var convolution_downsampling_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#define WEIGHT_INNER 0.125\n#define WEIGHT_OUTER 0.0555555\nvarying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;\n#include <encodings_fragment>\n}";
var convolution_downsampling_default2 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}";
var DownsamplingMaterial = class extends ShaderMaterial {
  constructor() {
    super({
      name: "DownsamplingMaterial",
      uniforms: {
        inputBuffer: new Uniform(null),
        texelSize: new Uniform(new Vector2())
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: convolution_downsampling_default,
      vertexShader: convolution_downsampling_default2
    });
    this.toneMapped = false;
  }
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};
var edge_detection_default = "varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if THREE_REVISION < 143\n#define luminance(v) linearToRelativeLuminance(v)\n#endif\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\n#if EDGE_DETECTION_MODE == 1\n#include <common>\n#endif\n#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}\n#elif PREDICATION_MODE == 2\nuniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}\n#endif\n#if PREDICATION_MODE != 0\nvec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}\n#endif\n#if EDGE_DETECTION_MODE != 0\nuniform sampler2D inputBuffer;\n#endif\nvoid main(){\n#if EDGE_DETECTION_MODE == 0\nconst vec2 threshold=vec2(DEPTH_THRESHOLD);\n#elif PREDICATION_MODE != 0\nvec2 threshold=calculatePredicatedThreshold();\n#else\nconst vec2 threshold=vec2(EDGE_THRESHOLD);\n#endif\n#if EDGE_DETECTION_MODE == 0\nvec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 1\nfloat l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 2\nvec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#endif\n}";
var edge_detection_default2 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\nvoid main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);\n#if EDGE_DETECTION_MODE != 0\nvUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}";
var EdgeDetectionMaterial = class extends ShaderMaterial {
  constructor(texelSize = new Vector2(), mode = EdgeDetectionMode.COLOR) {
    super({
      name: "EdgeDetectionMaterial",
      defines: {
        THREE_REVISION: REVISION.replace(/\D+/g, ""),
        LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
        EDGE_THRESHOLD: "0.1",
        DEPTH_THRESHOLD: "0.01",
        PREDICATION_MODE: "0",
        PREDICATION_THRESHOLD: "0.01",
        PREDICATION_SCALE: "2.0",
        PREDICATION_STRENGTH: "1.0",
        DEPTH_PACKING: "0"
      },
      uniforms: {
        inputBuffer: new Uniform(null),
        depthBuffer: new Uniform(null),
        predicationBuffer: new Uniform(null),
        texelSize: new Uniform(texelSize)
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: edge_detection_default,
      vertexShader: edge_detection_default2
    });
    this.toneMapped = false;
    this.edgeDetectionMode = mode;
  }
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  setDepthBuffer(buffer2, depthPacking = BasicDepthPacking) {
    this.depthBuffer = buffer2;
    this.depthPacking = depthPacking;
  }
  get edgeDetectionMode() {
    return Number(this.defines.EDGE_DETECTION_MODE);
  }
  set edgeDetectionMode(value) {
    this.defines.EDGE_DETECTION_MODE = value.toFixed(0);
    this.needsUpdate = true;
  }
  getEdgeDetectionMode() {
    return this.edgeDetectionMode;
  }
  setEdgeDetectionMode(value) {
    this.edgeDetectionMode = value;
  }
  get localContrastAdaptationFactor() {
    return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR);
  }
  set localContrastAdaptationFactor(value) {
    this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = value.toFixed("6");
    this.needsUpdate = true;
  }
  getLocalContrastAdaptationFactor() {
    return this.localContrastAdaptationFactor;
  }
  setLocalContrastAdaptationFactor(value) {
    this.localContrastAdaptationFactor = value;
  }
  get edgeDetectionThreshold() {
    return Number(this.defines.EDGE_THRESHOLD);
  }
  set edgeDetectionThreshold(value) {
    this.defines.EDGE_THRESHOLD = value.toFixed("6");
    this.defines.DEPTH_THRESHOLD = (value * 0.1).toFixed("6");
    this.needsUpdate = true;
  }
  getEdgeDetectionThreshold() {
    return this.edgeDetectionThreshold;
  }
  setEdgeDetectionThreshold(value) {
    this.edgeDetectionThreshold = value;
  }
  get predicationMode() {
    return Number(this.defines.PREDICATION_MODE);
  }
  set predicationMode(value) {
    this.defines.PREDICATION_MODE = value.toFixed(0);
    this.needsUpdate = true;
  }
  getPredicationMode() {
    return this.predicationMode;
  }
  setPredicationMode(value) {
    this.predicationMode = value;
  }
  set predicationBuffer(value) {
    this.uniforms.predicationBuffer.value = value;
  }
  setPredicationBuffer(value) {
    this.uniforms.predicationBuffer.value = value;
  }
  get predicationThreshold() {
    return Number(this.defines.PREDICATION_THRESHOLD);
  }
  set predicationThreshold(value) {
    this.defines.PREDICATION_THRESHOLD = value.toFixed("6");
    this.needsUpdate = true;
  }
  getPredicationThreshold() {
    return this.predicationThreshold;
  }
  setPredicationThreshold(value) {
    this.predicationThreshold = value;
  }
  get predicationScale() {
    return Number(this.defines.PREDICATION_SCALE);
  }
  set predicationScale(value) {
    this.defines.PREDICATION_SCALE = value.toFixed("6");
    this.needsUpdate = true;
  }
  getPredicationScale() {
    return this.predicationScale;
  }
  setPredicationScale(value) {
    this.predicationScale = value;
  }
  get predicationStrength() {
    return Number(this.defines.PREDICATION_STRENGTH);
  }
  set predicationStrength(value) {
    this.defines.PREDICATION_STRENGTH = value.toFixed("6");
    this.needsUpdate = true;
  }
  getPredicationStrength() {
    return this.predicationStrength;
  }
  setPredicationStrength(value) {
    this.predicationStrength = value;
  }
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};
var effect_default = "#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;\n#if THREE_REVISION < 143\n#define luminance(v) linearToRelativeLuminance(v)\n#endif\n#if THREE_REVISION >= 137\nvec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEADvoid main(){FRAGMENT_MAIN_UVvec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGEgl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <encodings_fragment>\n#endif\n#include <dithering_fragment>\n}";
var effect_default2 = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEADvoid main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORTgl_Position=vec4(position.xy,1.0,1.0);}";
var EffectMaterial = class extends ShaderMaterial {
  constructor(shaderParts, defines, uniforms, camera, dithering = false) {
    super({
      name: "EffectMaterial",
      defines: {
        THREE_REVISION: REVISION.replace(/\D+/g, ""),
        DEPTH_PACKING: "0",
        ENCODE_OUTPUT: "1"
      },
      uniforms: {
        inputBuffer: new Uniform(null),
        depthBuffer: new Uniform(null),
        resolution: new Uniform(new Vector2()),
        texelSize: new Uniform(new Vector2()),
        cameraNear: new Uniform(0.3),
        cameraFar: new Uniform(1e3),
        aspect: new Uniform(1),
        time: new Uniform(0)
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      dithering
    });
    this.toneMapped = false;
    if (shaderParts) {
      this.setShaderParts(shaderParts);
    }
    if (defines) {
      this.setDefines(defines);
    }
    if (uniforms) {
      this.setUniforms(uniforms);
    }
    this.copyCameraSettings(camera);
  }
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  get depthBuffer() {
    return this.uniforms.depthBuffer.value;
  }
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  get depthPacking() {
    return Number(this.defines.DEPTH_PACKING);
  }
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  setDepthBuffer(buffer2, depthPacking = BasicDepthPacking) {
    this.depthBuffer = buffer2;
    this.depthPacking = depthPacking;
  }
  setShaderData(data) {
    this.setShaderParts(data.shaderParts);
    this.setDefines(data.defines);
    this.setUniforms(data.uniforms);
    this.setExtensions(data.extensions);
  }
  setShaderParts(shaderParts) {
    var _a, _b, _c, _d, _e;
    this.fragmentShader = effect_default.replace(EffectShaderSection.FRAGMENT_HEAD, (_a = shaderParts.get(EffectShaderSection.FRAGMENT_HEAD)) != null ? _a : "").replace(EffectShaderSection.FRAGMENT_MAIN_UV, (_b = shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV)) != null ? _b : "").replace(EffectShaderSection.FRAGMENT_MAIN_IMAGE, (_c = shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE)) != null ? _c : "");
    this.vertexShader = effect_default2.replace(EffectShaderSection.VERTEX_HEAD, (_d = shaderParts.get(EffectShaderSection.VERTEX_HEAD)) != null ? _d : "").replace(EffectShaderSection.VERTEX_MAIN_SUPPORT, (_e = shaderParts.get(EffectShaderSection.VERTEX_MAIN_SUPPORT)) != null ? _e : "");
    this.needsUpdate = true;
    return this;
  }
  setDefines(defines) {
    for (const entry of defines.entries()) {
      this.defines[entry[0]] = entry[1];
    }
    this.needsUpdate = true;
    return this;
  }
  setUniforms(uniforms) {
    for (const entry of uniforms.entries()) {
      this.uniforms[entry[0]] = entry[1];
    }
    return this;
  }
  setExtensions(extensions) {
    this.extensions = {};
    for (const extension of extensions) {
      this.extensions[extension] = true;
    }
    return this;
  }
  get encodeOutput() {
    return this.defines.ENCODE_OUTPUT !== void 0;
  }
  set encodeOutput(value) {
    if (this.encodeOutput !== value) {
      if (value) {
        this.defines.ENCODE_OUTPUT = "1";
      } else {
        delete this.defines.ENCODE_OUTPUT;
      }
      this.needsUpdate = true;
    }
  }
  isOutputEncodingEnabled(value) {
    return this.encodeOutput;
  }
  setOutputEncodingEnabled(value) {
    this.encodeOutput = value;
  }
  get time() {
    return this.uniforms.time.value;
  }
  set time(value) {
    this.uniforms.time.value = value;
  }
  setDeltaTime(value) {
    this.uniforms.time.value += value;
  }
  adoptCameraSettings(camera) {
    this.copyCameraSettings(camera);
  }
  copyCameraSettings(camera) {
    if (camera) {
      this.uniforms.cameraNear.value = camera.near;
      this.uniforms.cameraFar.value = camera.far;
      if (camera instanceof PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
      this.needsUpdate = true;
    }
  }
  setSize(width, height) {
    const uniforms = this.uniforms;
    uniforms.resolution.value.set(width, height);
    uniforms.texelSize.value.set(1 / width, 1 / height);
    uniforms.aspect.value = width / height;
  }
  static get Section() {
    return EffectShaderSection;
  }
};
var convolution_god_rays_default = "#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform vec2 lightPosition;uniform float exposure;uniform float decay;uniform float density;uniform float weight;uniform float clampMax;varying vec2 vUv;void main(){vec2 coord=vUv;vec2 delta=lightPosition-coord;delta*=1.0/SAMPLES_FLOAT*density;float illuminationDecay=1.0;vec4 color=vec4(0.0);for(int i=0;i<SAMPLES_INT;++i){coord+=delta;vec4 texel=texture2D(inputBuffer,coord);texel*=illuminationDecay*weight;color+=texel;illuminationDecay*=decay;}gl_FragColor=clamp(color*exposure,0.0,clampMax);\n#include <dithering_fragment>\n}";
var GodRaysMaterial = class extends ShaderMaterial {
  constructor(lightPosition) {
    super({
      name: "GodRaysMaterial",
      defines: {
        SAMPLES_INT: "60",
        SAMPLES_FLOAT: "60.0"
      },
      uniforms: {
        inputBuffer: new Uniform(null),
        lightPosition: new Uniform(lightPosition),
        density: new Uniform(1),
        decay: new Uniform(1),
        weight: new Uniform(1),
        exposure: new Uniform(1),
        clampMax: new Uniform(1)
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: convolution_god_rays_default,
      vertexShader: common_default
    });
    this.toneMapped = false;
  }
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  get lightPosition() {
    return this.uniforms.lightPosition.value;
  }
  getLightPosition() {
    return this.uniforms.lightPosition.value;
  }
  setLightPosition(value) {
    this.uniforms.lightPosition.value = value;
  }
  get density() {
    return this.uniforms.density.value;
  }
  set density(value) {
    this.uniforms.density.value = value;
  }
  getDensity() {
    return this.uniforms.density.value;
  }
  setDensity(value) {
    this.uniforms.density.value = value;
  }
  get decay() {
    return this.uniforms.decay.value;
  }
  set decay(value) {
    this.uniforms.decay.value = value;
  }
  getDecay() {
    return this.uniforms.decay.value;
  }
  setDecay(value) {
    this.uniforms.decay.value = value;
  }
  get weight() {
    return this.uniforms.weight.value;
  }
  set weight(value) {
    this.uniforms.weight.value = value;
  }
  getWeight() {
    return this.uniforms.weight.value;
  }
  setWeight(value) {
    this.uniforms.weight.value = value;
  }
  get exposure() {
    return this.uniforms.exposure.value;
  }
  set exposure(value) {
    this.uniforms.exposure.value = value;
  }
  getExposure() {
    return this.uniforms.exposure.value;
  }
  setExposure(value) {
    this.uniforms.exposure.value = value;
  }
  get maxIntensity() {
    return this.uniforms.clampMax.value;
  }
  set maxIntensity(value) {
    this.uniforms.clampMax.value = value;
  }
  getMaxIntensity() {
    return this.uniforms.clampMax.value;
  }
  setMaxIntensity(value) {
    this.uniforms.clampMax.value = value;
  }
  get samples() {
    return Number(this.defines.SAMPLES_INT);
  }
  set samples(value) {
    const s = Math.floor(value);
    this.defines.SAMPLES_INT = s.toFixed(0);
    this.defines.SAMPLES_FLOAT = s.toFixed(1);
    this.needsUpdate = true;
  }
  getSamples() {
    return this.samples;
  }
  setSamples(value) {
    this.samples = value;
  }
};
var luminance_default = "#include <common>\n#if THREE_REVISION < 143\n#define luminance(v) linearToRelativeLuminance(v)\n#endif\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef RANGE\nuniform vec2 range;\n#elif defined(THRESHOLD)\nuniform float threshold;uniform float smoothing;\n#endif\nvarying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);\n#ifdef RANGE\nfloat low=step(range.x,l);float high=step(l,range.y);l*=low*high;\n#elif defined(THRESHOLD)\nl=smoothstep(threshold,threshold+smoothing,l);\n#endif\n#ifdef COLOR\ngl_FragColor=vec4(texel.rgb*l,l);\n#else\ngl_FragColor=vec4(l);\n#endif\n}";
var LuminanceMaterial = class extends ShaderMaterial {
  constructor(colorOutput = false, luminanceRange = null) {
    super({
      name: "LuminanceMaterial",
      defines: {
        THREE_REVISION: REVISION.replace(/\D+/g, "")
      },
      uniforms: {
        inputBuffer: new Uniform(null),
        threshold: new Uniform(0),
        smoothing: new Uniform(1),
        range: new Uniform(null)
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: luminance_default,
      vertexShader: common_default
    });
    this.toneMapped = false;
    this.colorOutput = colorOutput;
    this.luminanceRange = luminanceRange;
  }
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  get threshold() {
    return this.uniforms.threshold.value;
  }
  set threshold(value) {
    if (this.smoothing > 0 || value > 0) {
      this.defines.THRESHOLD = "1";
    } else {
      delete this.defines.THRESHOLD;
    }
    this.uniforms.threshold.value = value;
  }
  getThreshold() {
    return this.threshold;
  }
  setThreshold(value) {
    this.threshold = value;
  }
  get smoothing() {
    return this.uniforms.smoothing.value;
  }
  set smoothing(value) {
    if (this.threshold > 0 || value > 0) {
      this.defines.THRESHOLD = "1";
    } else {
      delete this.defines.THRESHOLD;
    }
    this.uniforms.smoothing.value = value;
  }
  getSmoothingFactor() {
    return this.smoothing;
  }
  setSmoothingFactor(value) {
    this.smoothing = value;
  }
  get useThreshold() {
    return this.threshold > 0 || this.smoothing > 0;
  }
  set useThreshold(value) {
  }
  get colorOutput() {
    return this.defines.COLOR !== void 0;
  }
  set colorOutput(value) {
    if (value) {
      this.defines.COLOR = "1";
    } else {
      delete this.defines.COLOR;
    }
    this.needsUpdate = true;
  }
  isColorOutputEnabled(value) {
    return this.colorOutput;
  }
  setColorOutputEnabled(value) {
    this.colorOutput = value;
  }
  get useRange() {
    return this.luminanceRange !== null;
  }
  set useRange(value) {
    this.luminanceRange = null;
  }
  get luminanceRange() {
    return this.uniforms.range.value;
  }
  set luminanceRange(value) {
    if (value !== null) {
      this.defines.RANGE = "1";
    } else {
      delete this.defines.RANGE;
    }
    this.uniforms.range.value = value;
    this.needsUpdate = true;
  }
  getLuminanceRange() {
    return this.luminanceRange;
  }
  setLuminanceRange(value) {
    this.luminanceRange = value;
  }
};
var mask_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef MASK_PRECISION_HIGH\nuniform mediump sampler2D maskTexture;\n#else\nuniform lowp sampler2D maskTexture;\n#endif\n#if MASK_FUNCTION != 0\nuniform float strength;\n#endif\nvarying vec2 vUv;void main(){\n#if COLOR_CHANNEL == 0\nfloat mask=texture2D(maskTexture,vUv).r;\n#elif COLOR_CHANNEL == 1\nfloat mask=texture2D(maskTexture,vUv).g;\n#elif COLOR_CHANNEL == 2\nfloat mask=texture2D(maskTexture,vUv).b;\n#else\nfloat mask=texture2D(maskTexture,vUv).a;\n#endif\n#if MASK_FUNCTION == 0\n#ifdef INVERTED\nmask=step(mask,0.0);\n#else\nmask=1.0-step(mask,0.0);\n#endif\n#else\nmask=clamp(mask*strength,0.0,1.0);\n#ifdef INVERTED\nmask=1.0-mask;\n#endif\n#endif\n#if MASK_FUNCTION == 2\ngl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);\n#else\ngl_FragColor=mask*texture2D(inputBuffer,vUv);\n#endif\n}";
var MaskMaterial = class extends ShaderMaterial {
  constructor(maskTexture = null) {
    super({
      name: "MaskMaterial",
      uniforms: {
        maskTexture: new Uniform(maskTexture),
        inputBuffer: new Uniform(null),
        strength: new Uniform(1)
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: mask_default,
      vertexShader: common_default
    });
    this.toneMapped = false;
    this.setColorChannel(ColorChannel.RED);
    this.setMaskFunction(MaskFunction.DISCARD);
  }
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  set maskTexture(value) {
    this.uniforms.maskTexture.value = value;
    delete this.defines.MASK_PRECISION_HIGH;
    if (value.type !== UnsignedByteType) {
      this.defines.MASK_PRECISION_HIGH = "1";
    }
    this.needsUpdate = true;
  }
  setMaskTexture(value) {
    this.maskTexture = value;
  }
  set colorChannel(value) {
    this.defines.COLOR_CHANNEL = value.toFixed(0);
    this.needsUpdate = true;
  }
  setColorChannel(value) {
    this.colorChannel = value;
  }
  set maskFunction(value) {
    this.defines.MASK_FUNCTION = value.toFixed(0);
    this.needsUpdate = true;
  }
  setMaskFunction(value) {
    this.maskFunction = value;
  }
  get inverted() {
    return this.defines.INVERTED !== void 0;
  }
  set inverted(value) {
    if (this.inverted && !value) {
      delete this.defines.INVERTED;
    } else if (value) {
      this.defines.INVERTED = "1";
    }
    this.needsUpdate = true;
  }
  isInverted() {
    return this.inverted;
  }
  setInverted(value) {
    this.inverted = value;
  }
  get strength() {
    return this.uniforms.strength.value;
  }
  set strength(value) {
    this.uniforms.strength.value = value;
  }
  getStrength() {
    return this.strength;
  }
  setStrength(value) {
    this.strength = value;
  }
};
var outline_default = "uniform lowp sampler2D inputBuffer;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 c0=texture2D(inputBuffer,vUv0).rg;vec2 c1=texture2D(inputBuffer,vUv1).rg;vec2 c2=texture2D(inputBuffer,vUv2).rg;vec2 c3=texture2D(inputBuffer,vUv3).rg;float d0=(c0.x-c1.x)*0.5;float d1=(c2.x-c3.x)*0.5;float d=length(vec2(d0,d1));float a0=min(c0.y,c1.y);float a1=min(c2.y,c3.y);float visibilityFactor=min(a0,a1);gl_FragColor.rg=(1.0-visibilityFactor>0.001)?vec2(d,0.0):vec2(0.0,d);}";
var outline_default2 = "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=vec2(uv.x+texelSize.x,uv.y);vUv1=vec2(uv.x-texelSize.x,uv.y);vUv2=vec2(uv.x,uv.y+texelSize.y);vUv3=vec2(uv.x,uv.y-texelSize.y);gl_Position=vec4(position.xy,1.0,1.0);}";
var OutlineMaterial = class extends ShaderMaterial {
  constructor(texelSize = new Vector2()) {
    super({
      name: "OutlineMaterial",
      uniforms: {
        inputBuffer: new Uniform(null),
        texelSize: new Uniform(new Vector2())
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: outline_default,
      vertexShader: outline_default2
    });
    this.toneMapped = false;
    this.uniforms.texelSize.value.set(texelSize.x, texelSize.y);
    this.uniforms.maskTexture = this.uniforms.inputBuffer;
  }
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  setTexelSize(x, y) {
    this.uniforms.texelSize.value.set(x, y);
  }
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};
var smaa_weights_default = "#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)\n#if __VERSION__ < 300\n#define round(v) floor(v + 0.5)\n#endif\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);\n#endif\n}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);\n#endif\n}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){\n#if !defined(DISABLE_DIAG_DETECTION)\nweights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){\n#endif\nvec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);\n#if !defined(DISABLE_DIAG_DETECTION)\n}else{e.r=0.0;}\n#endif\n}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}";
var smaa_weights_default2 = "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}";
var SMAAWeightsMaterial = class extends ShaderMaterial {
  constructor(texelSize = new Vector2(), resolution = new Vector2()) {
    super({
      name: "SMAAWeightsMaterial",
      defines: {
        MAX_SEARCH_STEPS_INT: "16",
        MAX_SEARCH_STEPS_FLOAT: "16.0",
        MAX_SEARCH_STEPS_DIAG_INT: "8",
        MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0",
        CORNER_ROUNDING: "25",
        CORNER_ROUNDING_NORM: "0.25",
        AREATEX_MAX_DISTANCE: "16.0",
        AREATEX_MAX_DISTANCE_DIAG: "20.0",
        AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
        AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
        SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
        SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)"
      },
      uniforms: {
        inputBuffer: new Uniform(null),
        searchTexture: new Uniform(null),
        areaTexture: new Uniform(null),
        resolution: new Uniform(resolution),
        texelSize: new Uniform(texelSize)
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: smaa_weights_default,
      vertexShader: smaa_weights_default2
    });
    this.toneMapped = false;
  }
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  get searchTexture() {
    return this.uniforms.searchTexture.value;
  }
  set searchTexture(value) {
    this.uniforms.searchTexture.value = value;
  }
  get areaTexture() {
    return this.uniforms.areaTexture.value;
  }
  set areaTexture(value) {
    this.uniforms.areaTexture.value = value;
  }
  setLookupTextures(search, area2) {
    this.searchTexture = search;
    this.areaTexture = area2;
  }
  get orthogonalSearchSteps() {
    return Number(this.defines.MAX_SEARCH_STEPS_INT);
  }
  set orthogonalSearchSteps(value) {
    const s = Math.min(Math.max(value, 0), 112);
    this.defines.MAX_SEARCH_STEPS_INT = s.toFixed("0");
    this.defines.MAX_SEARCH_STEPS_FLOAT = s.toFixed("1");
    this.needsUpdate = true;
  }
  setOrthogonalSearchSteps(value) {
    this.orthogonalSearchSteps = value;
  }
  get diagonalSearchSteps() {
    return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT);
  }
  set diagonalSearchSteps(value) {
    const s = Math.min(Math.max(value, 0), 20);
    this.defines.MAX_SEARCH_STEPS_DIAG_INT = s.toFixed("0");
    this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = s.toFixed("1");
    this.needsUpdate = true;
  }
  setDiagonalSearchSteps(value) {
    this.diagonalSearchSteps = value;
  }
  get diagonalDetection() {
    return this.defines.DISABLE_DIAG_DETECTION === void 0;
  }
  set diagonalDetection(value) {
    if (value) {
      delete this.defines.DISABLE_DIAG_DETECTION;
    } else {
      this.defines.DISABLE_DIAG_DETECTION = "1";
    }
    this.needsUpdate = true;
  }
  isDiagonalDetectionEnabled() {
    return this.diagonalDetection;
  }
  setDiagonalDetectionEnabled(value) {
    this.diagonalDetection = value;
  }
  get cornerRounding() {
    return Number(this.defines.CORNER_ROUNDING);
  }
  set cornerRounding(value) {
    const r = Math.min(Math.max(value, 0), 100);
    this.defines.CORNER_ROUNDING = r.toFixed("4");
    this.defines.CORNER_ROUNDING_NORM = (r / 100).toFixed("4");
    this.needsUpdate = true;
  }
  setCornerRounding(value) {
    this.cornerRounding = value;
  }
  get cornerDetection() {
    return this.defines.DISABLE_CORNER_DETECTION === void 0;
  }
  set cornerDetection(value) {
    if (value) {
      delete this.defines.DISABLE_CORNER_DETECTION;
    } else {
      this.defines.DISABLE_CORNER_DETECTION = "1";
    }
    this.needsUpdate = true;
  }
  isCornerRoundingEnabled() {
    return this.cornerDetection;
  }
  setCornerRoundingEnabled(value) {
    this.cornerDetection = value;
  }
  setSize(width, height) {
    const uniforms = this.uniforms;
    uniforms.texelSize.value.set(1 / width, 1 / height);
    uniforms.resolution.value.set(width, height);
  }
};
var ssao_default = "#include <common>\n#include <packing>\n#ifdef NORMAL_DEPTH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}\n#else\nuniform lowp sampler2D normalBuffer;\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}\n#endif\nuniform lowp sampler2D noiseTexture;uniform mat4 inverseProjectionMatrix;uniform mat4 projectionMatrix;uniform vec2 texelSize;uniform vec2 cameraNearFar;uniform float intensity;uniform float minRadiusScale;uniform float fade;uniform float bias;uniform vec2 distanceCutoff;uniform vec2 proximityCutoff;varying vec2 vUv;varying vec2 vUv2;float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#endif\n}vec3 getViewPosition(const in vec2 screenPosition,const in float depth,const in float viewZ){vec4 clipPosition=vec4(vec3(screenPosition,depth)*2.0-1.0,1.0);float clipW=projectionMatrix[2][3]*viewZ+projectionMatrix[3][3];clipPosition*=clipW;return(inverseProjectionMatrix*clipPosition).xyz;}float getAmbientOcclusion(const in vec3 p,const in vec3 n,const in float depth,const in vec2 uv){float radiusScale=1.0-smoothstep(0.0,distanceCutoff.y,depth);radiusScale=radiusScale*(1.0-minRadiusScale)+minRadiusScale;float radius=RADIUS*radiusScale;float noise=texture2D(noiseTexture,vUv2).r;float baseAngle=noise*PI2;float rings=SPIRAL_TURNS*PI2;float occlusion=0.0;int taps=0;for(int i=0;i<SAMPLES_INT;++i){float alpha=(float(i)+0.5)*INV_SAMPLES_FLOAT;float angle=alpha*rings+baseAngle;vec2 rotation=vec2(cos(angle),sin(angle));vec2 coords=alpha*radius*rotation*texelSize+uv;if(coords.s<0.0||coords.s>1.0||coords.t<0.0||coords.t>1.0){continue;}float sampleDepth=readDepth(coords);float viewZ=getViewZ(sampleDepth);\n#ifdef PERSPECTIVE_CAMERA\nfloat linearSampleDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);\n#else\nfloat linearSampleDepth=sampleDepth;\n#endif\nfloat proximity=abs(depth-linearSampleDepth);if(proximity<proximityCutoff.y){float falloff=1.0-smoothstep(proximityCutoff.x,proximityCutoff.y,proximity);vec3 Q=getViewPosition(coords,sampleDepth,viewZ);vec3 v=Q-p;float vv=dot(v,v);float vn=dot(v,n)-bias;float f=max(RADIUS_SQ-vv,0.0)/RADIUS_SQ;occlusion+=(f*f*f*max(vn/(fade+vv),0.0))*falloff;}++taps;}return occlusion/(4.0*max(float(taps),1.0));}void main(){\n#ifdef NORMAL_DEPTH\nvec4 normalDepth=texture2D(normalDepthBuffer,vUv);\n#else\nvec4 normalDepth=vec4(texture2D(normalBuffer,vUv).xyz,readDepth(vUv));\n#endif\nfloat ao=0.0;float depth=normalDepth.a;float viewZ=getViewZ(depth);\n#ifdef PERSPECTIVE_CAMERA\nfloat linearDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);\n#else\nfloat linearDepth=depth;\n#endif\nif(linearDepth<distanceCutoff.y){vec3 viewPosition=getViewPosition(vUv,depth,viewZ);vec3 viewNormal=unpackRGBToNormal(normalDepth.rgb);ao+=getAmbientOcclusion(viewPosition,viewNormal,linearDepth,vUv);float d=smoothstep(distanceCutoff.x,distanceCutoff.y,linearDepth);ao=mix(ao,0.0,d);\n#ifdef LEGACY_INTENSITY\nao=clamp(1.0-pow(1.0-ao,abs(intensity)),0.0,1.0);\n#endif\n}gl_FragColor.r=ao;}";
var ssao_default2 = "uniform vec2 noiseScale;varying vec2 vUv;varying vec2 vUv2;void main(){vUv=position.xy*0.5+0.5;vUv2=vUv*noiseScale;gl_Position=vec4(position.xy,1.0,1.0);}";
var SSAOMaterial = class extends ShaderMaterial {
  constructor(camera) {
    super({
      name: "SSAOMaterial",
      defines: {
        SAMPLES_INT: "0",
        INV_SAMPLES_FLOAT: "0.0",
        SPIRAL_TURNS: "0.0",
        RADIUS: "1.0",
        RADIUS_SQ: "1.0",
        DISTANCE_SCALING: "1",
        DEPTH_PACKING: "0"
      },
      uniforms: {
        depthBuffer: new Uniform(null),
        normalBuffer: new Uniform(null),
        normalDepthBuffer: new Uniform(null),
        noiseTexture: new Uniform(null),
        inverseProjectionMatrix: new Uniform(new Matrix4()),
        projectionMatrix: new Uniform(new Matrix4()),
        texelSize: new Uniform(new Vector2()),
        cameraNearFar: new Uniform(new Vector2()),
        distanceCutoff: new Uniform(new Vector2()),
        proximityCutoff: new Uniform(new Vector2()),
        noiseScale: new Uniform(new Vector2()),
        minRadiusScale: new Uniform(0.33),
        intensity: new Uniform(1),
        fade: new Uniform(0.01),
        bias: new Uniform(0)
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: ssao_default,
      vertexShader: ssao_default2
    });
    this.toneMapped = false;
    this.copyCameraSettings(camera);
    this.resolution = new Vector2();
    this.r = 1;
  }
  get near() {
    return this.uniforms.cameraNearFar.value.x;
  }
  get far() {
    return this.uniforms.cameraNearFar.value.y;
  }
  set normalDepthBuffer(value) {
    this.uniforms.normalDepthBuffer.value = value;
    if (value !== null) {
      this.defines.NORMAL_DEPTH = "1";
    } else {
      delete this.defines.NORMAL_DEPTH;
    }
    this.needsUpdate = true;
  }
  setNormalDepthBuffer(value) {
    this.normalDepthBuffer = value;
  }
  set normalBuffer(value) {
    this.uniforms.normalBuffer.value = value;
  }
  setNormalBuffer(value) {
    this.uniforms.normalBuffer.value = value;
  }
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  setDepthBuffer(buffer2, depthPacking = BasicDepthPacking) {
    this.depthBuffer = buffer2;
    this.depthPacking = depthPacking;
  }
  set noiseTexture(value) {
    this.uniforms.noiseTexture.value = value;
  }
  setNoiseTexture(value) {
    this.uniforms.noiseTexture.value = value;
  }
  get samples() {
    return Number(this.defines.SAMPLES_INT);
  }
  set samples(value) {
    this.defines.SAMPLES_INT = value.toFixed(0);
    this.defines.INV_SAMPLES_FLOAT = (1 / value).toFixed(9);
    this.needsUpdate = true;
  }
  getSamples() {
    return this.samples;
  }
  setSamples(value) {
    this.samples = value;
  }
  get rings() {
    return Number(this.defines.SPIRAL_TURNS);
  }
  set rings(value) {
    this.defines.SPIRAL_TURNS = value.toFixed(1);
    this.needsUpdate = true;
  }
  getRings() {
    return this.rings;
  }
  setRings(value) {
    this.rings = value;
  }
  get intensity() {
    return this.uniforms.intensity.value;
  }
  set intensity(value) {
    this.uniforms.intensity.value = value;
    if (this.defines.LEGACY_INTENSITY === void 0) {
      this.defines.LEGACY_INTENSITY = "1";
      this.needsUpdate = true;
    }
  }
  getIntensity() {
    return this.uniforms.intensity.value;
  }
  setIntensity(value) {
    this.uniforms.intensity.value = value;
  }
  get fade() {
    return this.uniforms.fade.value;
  }
  set fade(value) {
    this.uniforms.fade.value = value;
  }
  getFade() {
    return this.uniforms.fade.value;
  }
  setFade(value) {
    this.uniforms.fade.value = value;
  }
  get bias() {
    return this.uniforms.bias.value;
  }
  set bias(value) {
    this.uniforms.bias.value = value;
  }
  getBias() {
    return this.uniforms.bias.value;
  }
  setBias(value) {
    this.uniforms.bias.value = value;
  }
  get minRadiusScale() {
    return this.uniforms.minRadiusScale.value;
  }
  set minRadiusScale(value) {
    this.uniforms.minRadiusScale.value = value;
  }
  getMinRadiusScale() {
    return this.uniforms.minRadiusScale.value;
  }
  setMinRadiusScale(value) {
    this.uniforms.minRadiusScale.value = value;
  }
  updateRadius() {
    const radius = this.r * this.resolution.height;
    this.defines.RADIUS = radius.toFixed(11);
    this.defines.RADIUS_SQ = (radius * radius).toFixed(11);
    this.needsUpdate = true;
  }
  get radius() {
    return this.r;
  }
  set radius(value) {
    this.r = Math.min(Math.max(value, 1e-6), 1);
    this.updateRadius();
  }
  getRadius() {
    return this.radius;
  }
  setRadius(value) {
    this.radius = value;
  }
  get distanceScaling() {
    return true;
  }
  set distanceScaling(value) {
  }
  isDistanceScalingEnabled() {
    return this.distanceScaling;
  }
  setDistanceScalingEnabled(value) {
    this.distanceScaling = value;
  }
  get distanceThreshold() {
    return this.uniforms.distanceCutoff.value.x;
  }
  set distanceThreshold(value) {
    this.uniforms.distanceCutoff.value.set(
      Math.min(Math.max(value, 0), 1),
      Math.min(Math.max(value + this.distanceFalloff, 0), 1)
    );
  }
  get worldDistanceThreshold() {
    return -orthographicDepthToViewZ(this.distanceThreshold, this.near, this.far);
  }
  set worldDistanceThreshold(value) {
    this.distanceThreshold = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  get distanceFalloff() {
    return this.uniforms.distanceCutoff.value.y - this.distanceThreshold;
  }
  set distanceFalloff(value) {
    this.uniforms.distanceCutoff.value.y = Math.min(Math.max(this.distanceThreshold + value, 0), 1);
  }
  get worldDistanceFalloff() {
    return -orthographicDepthToViewZ(this.distanceFalloff, this.near, this.far);
  }
  set worldDistanceFalloff(value) {
    this.distanceFalloff = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  setDistanceCutoff(threshold, falloff) {
    this.uniforms.distanceCutoff.value.set(
      Math.min(Math.max(threshold, 0), 1),
      Math.min(Math.max(threshold + falloff, 0), 1)
    );
  }
  get proximityThreshold() {
    return this.uniforms.proximityCutoff.value.x;
  }
  set proximityThreshold(value) {
    this.uniforms.proximityCutoff.value.set(
      Math.min(Math.max(value, 0), 1),
      Math.min(Math.max(value + this.proximityFalloff, 0), 1)
    );
  }
  get worldProximityThreshold() {
    return -orthographicDepthToViewZ(this.proximityThreshold, this.near, this.far);
  }
  set worldProximityThreshold(value) {
    this.proximityThreshold = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  get proximityFalloff() {
    return this.uniforms.proximityCutoff.value.y - this.proximityThreshold;
  }
  set proximityFalloff(value) {
    this.uniforms.proximityCutoff.value.y = Math.min(Math.max(this.proximityThreshold + value, 0), 1);
  }
  get worldProximityFalloff() {
    return -orthographicDepthToViewZ(this.proximityFalloff, this.near, this.far);
  }
  set worldProximityFalloff(value) {
    this.proximityFalloff = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  setProximityCutoff(threshold, falloff) {
    this.uniforms.proximityCutoff.value.set(
      Math.min(Math.max(threshold, 0), 1),
      Math.min(Math.max(threshold + falloff, 0), 1)
    );
  }
  setTexelSize(x, y) {
    this.uniforms.texelSize.value.set(x, y);
  }
  adoptCameraSettings(camera) {
    this.copyCameraSettings(camera);
  }
  copyCameraSettings(camera) {
    if (camera) {
      this.uniforms.cameraNearFar.value.set(camera.near, camera.far);
      this.uniforms.projectionMatrix.value.copy(camera.projectionMatrix);
      this.uniforms.inverseProjectionMatrix.value.copy(camera.projectionMatrix).invert();
      if (camera instanceof PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
      this.needsUpdate = true;
    }
  }
  setSize(width, height) {
    const uniforms = this.uniforms;
    const noiseTexture = uniforms.noiseTexture.value;
    if (noiseTexture !== null) {
      uniforms.noiseScale.value.set(
        width / noiseTexture.image.width,
        height / noiseTexture.image.height
      );
    }
    uniforms.texelSize.value.set(1 / width, 1 / height);
    this.resolution.set(width, height);
    this.updateRadius();
  }
};
var convolution_tilt_shift_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform vec4 maskParams;varying vec2 vUv;varying vec2 vUv2;varying vec2 vOffset;float linearGradientMask(const in float x){return smoothstep(maskParams.x,maskParams.y,x)-smoothstep(maskParams.w,maskParams.z,x);}void main(){vec2 dUv=vOffset*(1.0-linearGradientMask(vUv2.y));vec4 sum=texture2D(inputBuffer,vec2(vUv.x-dUv.x,vUv.y+dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x+dUv.x,vUv.y+dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x+dUv.x,vUv.y-dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x-dUv.x,vUv.y-dUv.y));gl_FragColor=sum*0.25;\n#include <encodings_fragment>\n}";
var convolution_tilt_shift_default2 = "uniform vec4 texelSize;uniform float kernel;uniform float scale;uniform float aspect;uniform vec2 rotation;varying vec2 vUv;varying vec2 vUv2;varying vec2 vOffset;void main(){vec2 uv=position.xy*0.5+0.5;vUv=uv;vUv2=(uv-0.5)*2.0*vec2(aspect,1.0);vUv2=vec2(dot(rotation,vUv2),dot(rotation,vec2(vUv2.y,-vUv2.x)));vOffset=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;gl_Position=vec4(position.xy,1.0,1.0);}";
var TiltShiftBlurMaterial = class extends KawaseBlurMaterial {
  constructor({
    kernelSize = KernelSize.MEDIUM,
    offset = 0,
    rotation = 0,
    focusArea = 0.4,
    feather = 0.3
  } = {}) {
    super();
    this.fragmentShader = convolution_tilt_shift_default;
    this.vertexShader = convolution_tilt_shift_default2;
    this.kernelSize = kernelSize;
    this.uniforms.aspect = new Uniform(1);
    this.uniforms.rotation = new Uniform(new Vector2());
    this.uniforms.maskParams = new Uniform(new Vector4());
    this._offset = offset;
    this._focusArea = focusArea;
    this._feather = feather;
    this.rotation = rotation;
    this.updateParams();
  }
  updateParams() {
    const params = this.uniforms.maskParams.value;
    const a2 = Math.max(this.focusArea, 0);
    const b2 = Math.max(a2 - this.feather, 0);
    params.set(
      this.offset - a2,
      this.offset - b2,
      this.offset + a2,
      this.offset + b2
    );
  }
  get rotation() {
    return Math.acos(this.uniforms.rotation.value.x);
  }
  set rotation(value) {
    this.uniforms.rotation.value.set(Math.cos(value), Math.sin(value));
  }
  get offset() {
    return this._offset;
  }
  set offset(value) {
    this._offset = value;
    this.updateParams();
  }
  get focusArea() {
    return this._focusArea;
  }
  set focusArea(value) {
    this._focusArea = value;
    this.updateParams();
  }
  get feather() {
    return this._feather;
  }
  set feather(value) {
    this._feather = value;
    this.updateParams();
  }
  setSize(width, height) {
    super.setSize(width, height);
    this.uniforms.aspect.value = width / height;
  }
};
var convolution_upsampling_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;\n#else\nuniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;\n#endif\nuniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);\n#include <encodings_fragment>\n}";
var convolution_upsampling_default2 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}";
var UpsamplingMaterial = class extends ShaderMaterial {
  constructor() {
    super({
      name: "UpsamplingMaterial",
      uniforms: {
        inputBuffer: new Uniform(null),
        supportBuffer: new Uniform(null),
        texelSize: new Uniform(new Vector2()),
        radius: new Uniform(0.85)
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: convolution_upsampling_default,
      vertexShader: convolution_upsampling_default2
    });
    this.toneMapped = false;
  }
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  set supportBuffer(value) {
    this.uniforms.supportBuffer.value = value;
  }
  get radius() {
    return this.uniforms.radius.value;
  }
  set radius(value) {
    this.uniforms.radius.value = value;
  }
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};
var dummyCamera = new Camera();
var geometry = null;
function getFullscreenTriangle() {
  if (geometry === null) {
    const vertices = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);
    const uvs = new Float32Array([0, 0, 2, 0, 0, 2]);
    geometry = new BufferGeometry();
    if (geometry.setAttribute !== void 0) {
      geometry.setAttribute("position", new BufferAttribute(vertices, 3));
      geometry.setAttribute("uv", new BufferAttribute(uvs, 2));
    } else {
      geometry.addAttribute("position", new BufferAttribute(vertices, 3));
      geometry.addAttribute("uv", new BufferAttribute(uvs, 2));
    }
  }
  return geometry;
}
var Pass = class {
  constructor(name = "Pass", scene = new Scene(), camera = dummyCamera) {
    this.name = name;
    this.renderer = null;
    this.scene = scene;
    this.camera = camera;
    this.screen = null;
    this.rtt = true;
    this.needsSwap = true;
    this.needsDepthTexture = false;
    this.enabled = true;
  }
  get renderToScreen() {
    return !this.rtt;
  }
  set renderToScreen(value) {
    if (this.rtt === value) {
      const material = this.fullscreenMaterial;
      if (material !== null) {
        material.needsUpdate = true;
      }
      this.rtt = !value;
    }
  }
  set mainScene(value) {
  }
  set mainCamera(value) {
  }
  setRenderer(renderer) {
    this.renderer = renderer;
  }
  isEnabled() {
    return this.enabled;
  }
  setEnabled(value) {
    this.enabled = value;
  }
  get fullscreenMaterial() {
    return this.screen !== null ? this.screen.material : null;
  }
  set fullscreenMaterial(value) {
    let screen = this.screen;
    if (screen !== null) {
      screen.material = value;
    } else {
      screen = new Mesh(getFullscreenTriangle(), value);
      screen.frustumCulled = false;
      if (this.scene === null) {
        this.scene = new Scene();
      }
      this.scene.add(screen);
      this.screen = screen;
    }
  }
  getFullscreenMaterial() {
    return this.fullscreenMaterial;
  }
  setFullscreenMaterial(value) {
    this.fullscreenMaterial = value;
  }
  getDepthTexture() {
    return null;
  }
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
  }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    throw new Error("Render method not implemented!");
  }
  setSize(width, height) {
  }
  initialize(renderer, alpha, frameBufferType) {
  }
  dispose() {
    for (const key of Object.keys(this)) {
      const property = this[key];
      const isDisposable = property instanceof WebGLRenderTarget || property instanceof Material || property instanceof Texture || property instanceof Pass;
      if (isDisposable) {
        this[key].dispose();
      }
    }
  }
};
var CopyPass = class extends Pass {
  constructor(renderTarget, autoResize = true) {
    super("CopyPass");
    this.fullscreenMaterial = new CopyMaterial();
    this.needsSwap = false;
    this.renderTarget = renderTarget;
    if (renderTarget === void 0) {
      this.renderTarget = new WebGLRenderTarget(1, 1, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        stencilBuffer: false,
        depthBuffer: false
      });
      this.renderTarget.texture.name = "CopyPass.Target";
    }
    this.autoResize = autoResize;
  }
  get resize() {
    return this.autoResize;
  }
  set resize(value) {
    this.autoResize = value;
  }
  get texture() {
    return this.renderTarget.texture;
  }
  getTexture() {
    return this.renderTarget.texture;
  }
  setAutoResizeEnabled(value) {
    this.autoResize = value;
  }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    this.fullscreenMaterial.inputBuffer = inputBuffer.texture;
    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);
    renderer.render(this.scene, this.camera);
  }
  setSize(width, height) {
    if (this.autoResize) {
      this.renderTarget.setSize(width, height);
    }
  }
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0) {
      this.renderTarget.texture.type = frameBufferType;
      if (frameBufferType !== UnsignedByteType) {
        this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
      } else if (renderer.outputEncoding === sRGBEncoding) {
        this.renderTarget.texture.encoding = sRGBEncoding;
      }
    }
  }
};
var AdaptiveLuminancePass = class extends Pass {
  constructor(luminanceBuffer, { minLuminance = 0.01, adaptationRate = 1 } = {}) {
    super("AdaptiveLuminancePass");
    this.fullscreenMaterial = new AdaptiveLuminanceMaterial();
    this.needsSwap = false;
    this.renderTargetPrevious = new WebGLRenderTarget(1, 1, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      depthBuffer: false
    });
    this.renderTargetPrevious.texture.name = "Luminance.Previous";
    const material = this.fullscreenMaterial;
    material.luminanceBuffer0 = this.renderTargetPrevious.texture;
    material.luminanceBuffer1 = luminanceBuffer;
    material.minLuminance = minLuminance;
    material.adaptationRate = adaptationRate;
    this.renderTargetAdapted = this.renderTargetPrevious.clone();
    this.renderTargetAdapted.texture.name = "Luminance.Adapted";
    this.copyPass = new CopyPass(this.renderTargetPrevious, false);
  }
  get texture() {
    return this.renderTargetAdapted.texture;
  }
  getTexture() {
    return this.renderTargetAdapted.texture;
  }
  set mipLevel1x1(value) {
    this.fullscreenMaterial.mipLevel1x1 = value;
  }
  get adaptationRate() {
    return this.fullscreenMaterial.adaptationRate;
  }
  set adaptationRate(value) {
    this.fullscreenMaterial.adaptationRate = value;
  }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    this.fullscreenMaterial.deltaTime = deltaTime;
    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTargetAdapted);
    renderer.render(this.scene, this.camera);
    this.copyPass.render(renderer, this.renderTargetAdapted);
  }
};
var ClearMaskPass = class extends Pass {
  constructor() {
    super("ClearMaskPass", null, null);
    this.needsSwap = false;
  }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const stencil = renderer.state.buffers.stencil;
    stencil.setLocked(false);
    stencil.setTest(false);
  }
};
var color = new Color();
var ClearPass = class extends Pass {
  constructor(color22 = true, depth = true, stencil = false) {
    super("ClearPass", null, null);
    this.needsSwap = false;
    this.color = color22;
    this.depth = depth;
    this.stencil = stencil;
    this.overrideClearColor = null;
    this.overrideClearAlpha = -1;
  }
  setClearFlags(color22, depth, stencil) {
    this.color = color22;
    this.depth = depth;
    this.stencil = stencil;
  }
  getOverrideClearColor() {
    return this.overrideClearColor;
  }
  setOverrideClearColor(value) {
    this.overrideClearColor = value;
  }
  getOverrideClearAlpha() {
    return this.overrideClearAlpha;
  }
  setOverrideClearAlpha(value) {
    this.overrideClearAlpha = value;
  }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const overrideClearColor = this.overrideClearColor;
    const overrideClearAlpha = this.overrideClearAlpha;
    const clearAlpha = renderer.getClearAlpha();
    const hasOverrideClearColor = overrideClearColor !== null;
    const hasOverrideClearAlpha = overrideClearAlpha >= 0;
    if (hasOverrideClearColor) {
      renderer.getClearColor(color);
      renderer.setClearColor(overrideClearColor, hasOverrideClearAlpha ? overrideClearAlpha : clearAlpha);
    } else if (hasOverrideClearAlpha) {
      renderer.setClearAlpha(overrideClearAlpha);
    }
    renderer.setRenderTarget(this.renderToScreen ? null : inputBuffer);
    renderer.clear(this.color, this.depth, this.stencil);
    if (hasOverrideClearColor) {
      renderer.setClearColor(color, clearAlpha);
    } else if (hasOverrideClearAlpha) {
      renderer.setClearAlpha(clearAlpha);
    }
  }
};
var AUTO_SIZE = -1;
var Resolution = class extends EventDispatcher {
  constructor(resizable, width = AUTO_SIZE, height = AUTO_SIZE, scale = 1) {
    super();
    this.resizable = resizable;
    this.baseSize = new Vector2(1, 1);
    this.preferredSize = new Vector2(width, height);
    this.target = this.preferredSize;
    this.s = scale;
    this.effectiveSize = new Vector2();
    this.addEventListener("change", () => this.updateEffectiveSize());
    this.updateEffectiveSize();
  }
  updateEffectiveSize() {
    const base = this.baseSize;
    const preferred = this.preferredSize;
    const effective = this.effectiveSize;
    const scale = this.scale;
    if (preferred.width !== AUTO_SIZE) {
      effective.width = preferred.width;
    } else if (preferred.height !== AUTO_SIZE) {
      effective.width = Math.round(preferred.height * (base.width / Math.max(base.height, 1)));
    } else {
      effective.width = Math.round(base.width * scale);
    }
    if (preferred.height !== AUTO_SIZE) {
      effective.height = preferred.height;
    } else if (preferred.width !== AUTO_SIZE) {
      effective.height = Math.round(preferred.width / Math.max(base.width / Math.max(base.height, 1), 1));
    } else {
      effective.height = Math.round(base.height * scale);
    }
  }
  get width() {
    return this.effectiveSize.width;
  }
  set width(value) {
    this.preferredWidth = value;
  }
  get height() {
    return this.effectiveSize.height;
  }
  set height(value) {
    this.preferredHeight = value;
  }
  getWidth() {
    return this.width;
  }
  getHeight() {
    return this.height;
  }
  get scale() {
    return this.s;
  }
  set scale(value) {
    if (this.s !== value) {
      this.s = value;
      this.preferredSize.setScalar(AUTO_SIZE);
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  getScale() {
    return this.scale;
  }
  setScale(value) {
    this.scale = value;
  }
  get baseWidth() {
    return this.baseSize.width;
  }
  set baseWidth(value) {
    if (this.baseSize.width !== value) {
      this.baseSize.width = value;
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  getBaseWidth() {
    return this.baseWidth;
  }
  setBaseWidth(value) {
    this.baseWidth = value;
  }
  get baseHeight() {
    return this.baseSize.height;
  }
  set baseHeight(value) {
    if (this.baseSize.height !== value) {
      this.baseSize.height = value;
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  getBaseHeight() {
    return this.baseHeight;
  }
  setBaseHeight(value) {
    this.baseHeight = value;
  }
  setBaseSize(width, height) {
    if (this.baseSize.width !== width || this.baseSize.height !== height) {
      this.baseSize.set(width, height);
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  get preferredWidth() {
    return this.preferredSize.width;
  }
  set preferredWidth(value) {
    if (this.preferredSize.width !== value) {
      this.preferredSize.width = value;
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  getPreferredWidth() {
    return this.preferredWidth;
  }
  setPreferredWidth(value) {
    this.preferredWidth = value;
  }
  get preferredHeight() {
    return this.preferredSize.height;
  }
  set preferredHeight(value) {
    if (this.preferredSize.height !== value) {
      this.preferredSize.height = value;
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  getPreferredHeight() {
    return this.preferredHeight;
  }
  setPreferredHeight(value) {
    this.preferredHeight = value;
  }
  setPreferredSize(width, height) {
    if (this.preferredSize.width !== width || this.preferredSize.height !== height) {
      this.preferredSize.set(width, height);
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  copy(resolution) {
    this.s = resolution.scale;
    this.baseSize.set(resolution.baseWidth, resolution.baseHeight);
    this.preferredSize.set(resolution.preferredWidth, resolution.preferredHeight);
    this.dispatchEvent({ type: "change" });
    this.resizable.setSize(this.baseSize.width, this.baseSize.height);
  }
  static get AUTO_SIZE() {
    return AUTO_SIZE;
  }
};
var workaroundEnabled = false;
var OverrideMaterialManager = class {
  constructor(material = null) {
    this.originalMaterials = /* @__PURE__ */ new Map();
    this.material = null;
    this.materials = null;
    this.materialsBackSide = null;
    this.materialsDoubleSide = null;
    this.materialsFlatShaded = null;
    this.materialsFlatShadedBackSide = null;
    this.materialsFlatShadedDoubleSide = null;
    this.setMaterial(material);
    this.meshCount = 0;
    this.replaceMaterial = (node) => {
      if (node.isMesh) {
        let materials;
        if (node.material.flatShading) {
          switch (node.material.side) {
            case DoubleSide:
              materials = this.materialsFlatShadedDoubleSide;
              break;
            case BackSide:
              materials = this.materialsFlatShadedBackSide;
              break;
            default:
              materials = this.materialsFlatShaded;
              break;
          }
        } else {
          switch (node.material.side) {
            case DoubleSide:
              materials = this.materialsDoubleSide;
              break;
            case BackSide:
              materials = this.materialsBackSide;
              break;
            default:
              materials = this.materials;
              break;
          }
        }
        this.originalMaterials.set(node, node.material);
        if (node.isSkinnedMesh) {
          node.material = materials[2];
        } else if (node.isInstancedMesh) {
          node.material = materials[1];
        } else {
          node.material = materials[0];
        }
        ++this.meshCount;
      }
    };
  }
  setMaterial(material) {
    this.disposeMaterials();
    this.material = material;
    if (material !== null) {
      const materials = this.materials = [
        material.clone(),
        material.clone(),
        material.clone()
      ];
      for (const m2 of materials) {
        m2.uniforms = Object.assign({}, material.uniforms);
        m2.side = FrontSide;
      }
      materials[2].skinning = true;
      this.materialsBackSide = materials.map((m2) => {
        const c2 = m2.clone();
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.side = BackSide;
        return c2;
      });
      this.materialsDoubleSide = materials.map((m2) => {
        const c2 = m2.clone();
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.side = DoubleSide;
        return c2;
      });
      this.materialsFlatShaded = materials.map((m2) => {
        const c2 = m2.clone();
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.flatShading = true;
        return c2;
      });
      this.materialsFlatShadedBackSide = materials.map((m2) => {
        const c2 = m2.clone();
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.flatShading = true;
        c2.side = BackSide;
        return c2;
      });
      this.materialsFlatShadedDoubleSide = materials.map((m2) => {
        const c2 = m2.clone();
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.flatShading = true;
        c2.side = DoubleSide;
        return c2;
      });
    }
  }
  render(renderer, scene, camera) {
    const shadowMapEnabled = renderer.shadowMap.enabled;
    renderer.shadowMap.enabled = false;
    if (workaroundEnabled) {
      const originalMaterials = this.originalMaterials;
      this.meshCount = 0;
      scene.traverse(this.replaceMaterial);
      renderer.render(scene, camera);
      for (const entry of originalMaterials) {
        entry[0].material = entry[1];
      }
      if (this.meshCount !== originalMaterials.size) {
        originalMaterials.clear();
      }
    } else {
      const overrideMaterial = scene.overrideMaterial;
      scene.overrideMaterial = this.material;
      renderer.render(scene, camera);
      scene.overrideMaterial = overrideMaterial;
    }
    renderer.shadowMap.enabled = shadowMapEnabled;
  }
  disposeMaterials() {
    if (this.material !== null) {
      const materials = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
      for (const m2 of materials) {
        m2.dispose();
      }
    }
  }
  dispose() {
    this.originalMaterials.clear();
    this.disposeMaterials();
  }
  static get workaroundEnabled() {
    return workaroundEnabled;
  }
  static set workaroundEnabled(value) {
    workaroundEnabled = value;
  }
};
var RenderPass = class extends Pass {
  constructor(scene, camera, overrideMaterial = null) {
    super("RenderPass", scene, camera);
    this.needsSwap = false;
    this.clearPass = new ClearPass();
    this.overrideMaterialManager = overrideMaterial === null ? null : new OverrideMaterialManager(overrideMaterial);
    this.ignoreBackground = false;
    this.skipShadowMapUpdate = false;
    this.selection = null;
  }
  set mainScene(value) {
    this.scene = value;
  }
  set mainCamera(value) {
    this.camera = value;
  }
  get renderToScreen() {
    return super.renderToScreen;
  }
  set renderToScreen(value) {
    super.renderToScreen = value;
    this.clearPass.renderToScreen = value;
  }
  get overrideMaterial() {
    const manager = this.overrideMaterialManager;
    return manager !== null ? manager.material : null;
  }
  set overrideMaterial(value) {
    const manager = this.overrideMaterialManager;
    if (value !== null) {
      if (manager !== null) {
        manager.setMaterial(value);
      } else {
        this.overrideMaterialManager = new OverrideMaterialManager(value);
      }
    } else if (manager !== null) {
      manager.dispose();
      this.overrideMaterialManager = null;
    }
  }
  getOverrideMaterial() {
    return this.overrideMaterial;
  }
  setOverrideMaterial(value) {
    this.overrideMaterial = value;
  }
  get clear() {
    return this.clearPass.enabled;
  }
  set clear(value) {
    this.clearPass.enabled = value;
  }
  getSelection() {
    return this.selection;
  }
  setSelection(value) {
    this.selection = value;
  }
  isBackgroundDisabled() {
    return this.ignoreBackground;
  }
  setBackgroundDisabled(value) {
    this.ignoreBackground = value;
  }
  isShadowMapDisabled() {
    return this.skipShadowMapUpdate;
  }
  setShadowMapDisabled(value) {
    this.skipShadowMapUpdate = value;
  }
  getClearPass() {
    return this.clearPass;
  }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const scene = this.scene;
    const camera = this.camera;
    const selection = this.selection;
    const mask = camera.layers.mask;
    const background = scene.background;
    const shadowMapAutoUpdate = renderer.shadowMap.autoUpdate;
    const renderTarget = this.renderToScreen ? null : inputBuffer;
    if (selection !== null) {
      camera.layers.set(selection.getLayer());
    }
    if (this.skipShadowMapUpdate) {
      renderer.shadowMap.autoUpdate = false;
    }
    if (this.ignoreBackground || this.clearPass.overrideClearColor !== null) {
      scene.background = null;
    }
    if (this.clearPass.enabled) {
      this.clearPass.render(renderer, inputBuffer);
    }
    renderer.setRenderTarget(renderTarget);
    if (this.overrideMaterialManager !== null) {
      this.overrideMaterialManager.render(renderer, scene, camera);
    } else {
      renderer.render(scene, camera);
    }
    camera.layers.mask = mask;
    scene.background = background;
    renderer.shadowMap.autoUpdate = shadowMapAutoUpdate;
  }
};
var DepthPass = class extends Pass {
  constructor(scene, camera, {
    renderTarget,
    resolutionScale = 1,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("DepthPass");
    this.needsSwap = false;
    this.renderPass = new RenderPass(scene, camera, new MeshDepthMaterial({
      depthPacking: RGBADepthPacking
    }));
    const renderPass = this.renderPass;
    renderPass.skipShadowMapUpdate = true;
    renderPass.ignoreBackground = true;
    const clearPass = renderPass.getClearPass();
    clearPass.overrideClearColor = new Color(16777215);
    clearPass.overrideClearAlpha = 1;
    this.renderTarget = renderTarget;
    if (this.renderTarget === void 0) {
      this.renderTarget = new WebGLRenderTarget(1, 1, {
        minFilter: NearestFilter,
        magFilter: NearestFilter
      });
      this.renderTarget.texture.name = "DepthPass.Target";
    }
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  set mainScene(value) {
    this.renderPass.mainScene = value;
  }
  set mainCamera(value) {
    this.renderPass.mainCamera = value;
  }
  get texture() {
    return this.renderTarget.texture;
  }
  getTexture() {
    return this.renderTarget.texture;
  }
  getResolution() {
    return this.resolution;
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const renderTarget = this.renderToScreen ? null : this.renderTarget;
    this.renderPass.render(renderer, renderTarget);
  }
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
  }
};
var DepthDownsamplingPass = class extends Pass {
  constructor({
    normalBuffer = null,
    resolutionScale = 0.5,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("DepthDownsamplingPass");
    const material = new DepthDownsamplingMaterial();
    material.normalBuffer = normalBuffer;
    this.fullscreenMaterial = material;
    this.needsDepthTexture = true;
    this.needsSwap = false;
    this.renderTarget = new WebGLRenderTarget(1, 1, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      depthBuffer: false,
      type: FloatType
    });
    this.renderTarget.texture.name = "DepthDownsamplingPass.Target";
    this.renderTarget.texture.generateMipmaps = false;
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  get texture() {
    return this.renderTarget.texture;
  }
  getTexture() {
    return this.renderTarget.texture;
  }
  getResolution() {
    return this.resolution;
  }
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    this.fullscreenMaterial.depthBuffer = depthTexture;
    this.fullscreenMaterial.depthPacking = depthPacking;
  }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);
    renderer.render(this.scene, this.camera);
  }
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
    this.fullscreenMaterial.setSize(width, height);
  }
  initialize(renderer, alpha, frameBufferType) {
    const gl = renderer.getContext();
    const renderable = gl.getExtension("EXT_color_buffer_float") || gl.getExtension("EXT_color_buffer_half_float");
    if (!renderable) {
      throw new Error("Rendering to float texture is not supported.");
    }
  }
};
var unpackFactors = new Float32Array([
  255 / 256 / 256 ** 3,
  255 / 256 / 256 ** 2,
  255 / 256 / 256,
  255 / 256
]);
function prefixSubstrings(prefix, substrings, strings) {
  for (const substring of substrings) {
    const prefixed = "$1" + prefix + substring.charAt(0).toUpperCase() + substring.slice(1);
    const regExp = new RegExp("([^\\.])(\\b" + substring + "\\b)", "g");
    for (const entry of strings.entries()) {
      if (entry[1] !== null) {
        strings.set(entry[0], entry[1].replace(regExp, prefixed));
      }
    }
  }
}
function integrateEffect(prefix, effect, data) {
  var _a, _b, _c, _d, _e;
  let fragmentShader2 = effect.getFragmentShader();
  let vertexShader2 = effect.getVertexShader();
  const mainImageExists = fragmentShader2 !== void 0 && /mainImage/.test(fragmentShader2);
  const mainUvExists = fragmentShader2 !== void 0 && /mainUv/.test(fragmentShader2);
  data.attributes |= effect.getAttributes();
  if (fragmentShader2 === void 0) {
    throw new Error(`Missing fragment shader (${effect.name})`);
  } else if (mainUvExists && (data.attributes & EffectAttribute.CONVOLUTION) !== 0) {
    throw new Error(`Effects that transform UVs are incompatible with convolution effects (${effect.name})`);
  } else if (!mainImageExists && !mainUvExists) {
    throw new Error(`Could not find mainImage or mainUv function (${effect.name})`);
  } else {
    const functionRegExp = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g;
    const shaderParts = data.shaderParts;
    let fragmentHead = (_a = shaderParts.get(EffectShaderSection.FRAGMENT_HEAD)) != null ? _a : "";
    let fragmentMainUv = (_b = shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV)) != null ? _b : "";
    let fragmentMainImage = (_c = shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE)) != null ? _c : "";
    let vertexHead = (_d = shaderParts.get(EffectShaderSection.VERTEX_HEAD)) != null ? _d : "";
    let vertexMainSupport = (_e = shaderParts.get(EffectShaderSection.VERTEX_MAIN_SUPPORT)) != null ? _e : "";
    const varyings = /* @__PURE__ */ new Set();
    const names = /* @__PURE__ */ new Set();
    if (mainUvExists) {
      fragmentMainUv += `	${prefix}MainUv(UV);
`;
      data.uvTransformation = true;
    }
    if (vertexShader2 !== null && /mainSupport/.test(vertexShader2)) {
      const needsUv = /mainSupport *\([\w\s]*?uv\s*?\)/.test(vertexShader2);
      vertexMainSupport += `	${prefix}MainSupport(`;
      vertexMainSupport += needsUv ? "vUv);\n" : ");\n";
      for (const m2 of vertexShader2.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g)) {
        for (const n of m2[1].split(/\s*,\s*/)) {
          data.varyings.add(n);
          varyings.add(n);
          names.add(n);
        }
      }
      for (const m2 of vertexShader2.matchAll(functionRegExp)) {
        names.add(m2[1]);
      }
    }
    for (const m2 of fragmentShader2.matchAll(functionRegExp)) {
      names.add(m2[1]);
    }
    for (const d of effect.defines.keys()) {
      names.add(d.replace(/\([\w\s,]*\)/g, ""));
    }
    for (const u of effect.uniforms.keys()) {
      names.add(u);
    }
    names.delete("while");
    names.delete("for");
    names.delete("if");
    effect.uniforms.forEach((val, key) => data.uniforms.set(prefix + key.charAt(0).toUpperCase() + key.slice(1), val));
    effect.defines.forEach((val, key) => data.defines.set(prefix + key.charAt(0).toUpperCase() + key.slice(1), val));
    const shaders = /* @__PURE__ */ new Map([["fragment", fragmentShader2], ["vertex", vertexShader2]]);
    prefixSubstrings(prefix, names, data.defines);
    prefixSubstrings(prefix, names, shaders);
    fragmentShader2 = shaders.get("fragment");
    vertexShader2 = shaders.get("vertex");
    const blendMode = effect.blendMode;
    data.blendModes.set(blendMode.blendFunction, blendMode);
    if (mainImageExists) {
      if (effect.inputColorSpace !== null && effect.inputColorSpace !== data.colorSpace) {
        fragmentMainImage += effect.inputColorSpace === sRGBEncoding ? "color0 = LinearTosRGB(color0);\n	" : "color0 = sRGBToLinear(color0);\n	";
      }
      if (effect.outputColorSpace !== null) {
        data.colorSpace = effect.outputColorSpace;
      } else if (effect.inputColorSpace !== null) {
        data.colorSpace = effect.inputColorSpace;
      }
      const depthParamRegExp = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
      fragmentMainImage += `${prefix}MainImage(color0, UV, `;
      if ((data.attributes & EffectAttribute.DEPTH) !== 0 && depthParamRegExp.test(fragmentShader2)) {
        fragmentMainImage += "depth, ";
        data.readDepth = true;
      }
      fragmentMainImage += "color1);\n	";
      const blendOpacity = prefix + "BlendOpacity";
      data.uniforms.set(blendOpacity, blendMode.opacity);
      fragmentMainImage += `color0 = blend${blendMode.blendFunction}(color0, color1, ${blendOpacity});

	`;
      fragmentHead += `uniform float ${blendOpacity};

`;
    }
    fragmentHead += fragmentShader2 + "\n";
    if (vertexShader2 !== null) {
      vertexHead += vertexShader2 + "\n";
    }
    shaderParts.set(EffectShaderSection.FRAGMENT_HEAD, fragmentHead);
    shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_UV, fragmentMainUv);
    shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE, fragmentMainImage);
    shaderParts.set(EffectShaderSection.VERTEX_HEAD, vertexHead);
    shaderParts.set(EffectShaderSection.VERTEX_MAIN_SUPPORT, vertexMainSupport);
    if (effect.extensions !== null) {
      for (const extension of effect.extensions) {
        data.extensions.add(extension);
      }
    }
  }
}
var EffectPass = class extends Pass {
  constructor(camera, ...effects) {
    super("EffectPass");
    this.fullscreenMaterial = new EffectMaterial(null, null, null, camera);
    this.listener = (event) => this.handleEvent(event);
    this.effects = [];
    this.setEffects(effects);
    this.skipRendering = false;
    this.minTime = 1;
    this.maxTime = Number.POSITIVE_INFINITY;
    this.timeScale = 1;
  }
  set mainScene(value) {
    for (const effect of this.effects) {
      effect.mainScene = value;
    }
  }
  set mainCamera(value) {
    this.fullscreenMaterial.copyCameraSettings(value);
    for (const effect of this.effects) {
      effect.mainCamera = value;
    }
  }
  get encodeOutput() {
    return this.fullscreenMaterial.encodeOutput;
  }
  set encodeOutput(value) {
    this.fullscreenMaterial.encodeOutput = value;
  }
  get dithering() {
    return this.fullscreenMaterial.dithering;
  }
  set dithering(value) {
    const material = this.fullscreenMaterial;
    material.dithering = value;
    material.needsUpdate = true;
  }
  setEffects(effects) {
    for (const effect of this.effects) {
      effect.removeEventListener("change", this.listener);
    }
    this.effects = effects.sort((a2, b2) => b2.attributes - a2.attributes);
    for (const effect of this.effects) {
      effect.addEventListener("change", this.listener);
    }
  }
  updateMaterial() {
    const data = new EffectShaderData();
    let id = 0;
    for (const effect of this.effects) {
      if (effect.blendMode.blendFunction === BlendFunction.DST) {
        data.attributes |= effect.getAttributes() & EffectAttribute.DEPTH;
      } else if ((data.attributes & effect.getAttributes() & EffectAttribute.CONVOLUTION) !== 0) {
        throw new Error(`Convolution effects cannot be merged (${effect.name})`);
      } else {
        integrateEffect("e" + id++, effect, data);
      }
    }
    let fragmentHead = data.shaderParts.get(EffectShaderSection.FRAGMENT_HEAD);
    let fragmentMainImage = data.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE);
    let fragmentMainUv = data.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV);
    const blendRegExp = /\bblend\b/g;
    for (const blendMode of data.blendModes.values()) {
      fragmentHead += blendMode.getShaderCode().replace(blendRegExp, `blend${blendMode.blendFunction}`) + "\n";
    }
    if ((data.attributes & EffectAttribute.DEPTH) !== 0) {
      if (data.readDepth) {
        fragmentMainImage = "float depth = readDepth(UV);\n\n	" + fragmentMainImage;
      }
      this.needsDepthTexture = this.getDepthTexture() === null;
    } else {
      this.needsDepthTexture = false;
    }
    if (data.colorSpace === sRGBEncoding) {
      fragmentMainImage += "color0 = sRGBToLinear(color0);\n	";
    }
    if (data.uvTransformation) {
      fragmentMainUv = "vec2 transformedUv = vUv;\n" + fragmentMainUv;
      data.defines.set("UV", "transformedUv");
    } else {
      data.defines.set("UV", "vUv");
    }
    data.shaderParts.set(EffectShaderSection.FRAGMENT_HEAD, fragmentHead);
    data.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE, fragmentMainImage);
    data.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_UV, fragmentMainUv);
    data.shaderParts.forEach((value, key, map) => map.set(key, value == null ? void 0 : value.trim().replace(/^#/, "\n#")));
    this.skipRendering = id === 0;
    this.needsSwap = !this.skipRendering;
    this.fullscreenMaterial.setShaderData(data);
  }
  recompile() {
    this.updateMaterial();
  }
  getDepthTexture() {
    return this.fullscreenMaterial.depthBuffer;
  }
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    this.fullscreenMaterial.depthBuffer = depthTexture;
    this.fullscreenMaterial.depthPacking = depthPacking;
    for (const effect of this.effects) {
      effect.setDepthTexture(depthTexture, depthPacking);
    }
  }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    for (const effect of this.effects) {
      effect.update(renderer, inputBuffer, deltaTime);
    }
    if (!this.skipRendering || this.renderToScreen) {
      const material = this.fullscreenMaterial;
      material.inputBuffer = inputBuffer.texture;
      material.time += deltaTime * this.timeScale;
      renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
      renderer.render(this.scene, this.camera);
    }
  }
  setSize(width, height) {
    this.fullscreenMaterial.setSize(width, height);
    for (const effect of this.effects) {
      effect.setSize(width, height);
    }
  }
  initialize(renderer, alpha, frameBufferType) {
    this.renderer = renderer;
    for (const effect of this.effects) {
      effect.initialize(renderer, alpha, frameBufferType);
    }
    this.updateMaterial();
    if (frameBufferType !== void 0 && frameBufferType !== UnsignedByteType) {
      this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
    }
  }
  dispose() {
    super.dispose();
    for (const effect of this.effects) {
      effect.removeEventListener("change", this.listener);
      effect.dispose();
    }
  }
  handleEvent(event) {
    switch (event.type) {
      case "change":
        this.recompile();
        break;
    }
  }
};
var KawaseBlurPass = class extends Pass {
  constructor({
    kernelSize = KernelSize.MEDIUM,
    resolutionScale = 0.5,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("KawaseBlurPass");
    this.renderTargetA = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTargetA.texture.name = "Blur.Target.A";
    this.renderTargetB = this.renderTargetA.clone();
    this.renderTargetB.texture.name = "Blur.Target.B";
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
    this._blurMaterial = new KawaseBlurMaterial();
    this._blurMaterial.kernelSize = kernelSize;
    this.copyMaterial = new CopyMaterial();
  }
  getResolution() {
    return this.resolution;
  }
  get blurMaterial() {
    return this._blurMaterial;
  }
  set blurMaterial(value) {
    this._blurMaterial = value;
  }
  get dithering() {
    return this.copyMaterial.dithering;
  }
  set dithering(value) {
    this.copyMaterial.dithering = value;
  }
  get kernelSize() {
    return this.blurMaterial.kernelSize;
  }
  set kernelSize(value) {
    this.blurMaterial.kernelSize = value;
  }
  get width() {
    return this.resolution.width;
  }
  set width(value) {
    this.resolution.preferredWidth = value;
  }
  get height() {
    return this.resolution.height;
  }
  set height(value) {
    this.resolution.preferredHeight = value;
  }
  get scale() {
    return this.blurMaterial.scale;
  }
  set scale(value) {
    this.blurMaterial.scale = value;
  }
  getScale() {
    return this.blurMaterial.scale;
  }
  setScale(value) {
    this.blurMaterial.scale = value;
  }
  getKernelSize() {
    return this.kernelSize;
  }
  setKernelSize(value) {
    this.kernelSize = value;
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const scene = this.scene;
    const camera = this.camera;
    const renderTargetA = this.renderTargetA;
    const renderTargetB = this.renderTargetB;
    const material = this.blurMaterial;
    const kernelSequence = material.kernelSequence;
    let previousBuffer = inputBuffer;
    this.fullscreenMaterial = material;
    for (let i2 = 0, l = kernelSequence.length; i2 < l; ++i2) {
      const buffer2 = (i2 & 1) === 0 ? renderTargetA : renderTargetB;
      material.kernel = kernelSequence[i2];
      material.inputBuffer = previousBuffer.texture;
      renderer.setRenderTarget(buffer2);
      renderer.render(scene, camera);
      previousBuffer = buffer2;
    }
    this.fullscreenMaterial = this.copyMaterial;
    this.copyMaterial.inputBuffer = previousBuffer.texture;
    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
    renderer.render(scene, camera);
  }
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    const w = resolution.width, h = resolution.height;
    this.renderTargetA.setSize(w, h);
    this.renderTargetB.setSize(w, h);
    this.blurMaterial.setSize(width, height);
  }
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0) {
      this.renderTargetA.texture.type = frameBufferType;
      this.renderTargetB.texture.type = frameBufferType;
      if (frameBufferType !== UnsignedByteType) {
        this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
        this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
      } else if (renderer.outputEncoding === sRGBEncoding) {
        this.renderTargetA.texture.encoding = sRGBEncoding;
        this.renderTargetB.texture.encoding = sRGBEncoding;
      }
    }
  }
  static get AUTO_SIZE() {
    return Resolution.AUTO_SIZE;
  }
};
var LuminancePass = class extends Pass {
  constructor({
    renderTarget,
    luminanceRange,
    colorOutput,
    resolutionScale = 1,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("LuminancePass");
    this.fullscreenMaterial = new LuminanceMaterial(colorOutput, luminanceRange);
    this.needsSwap = false;
    this.renderTarget = renderTarget;
    if (this.renderTarget === void 0) {
      this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: false });
      this.renderTarget.texture.name = "LuminancePass.Target";
    }
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  get texture() {
    return this.renderTarget.texture;
  }
  getTexture() {
    return this.renderTarget.texture;
  }
  getResolution() {
    return this.resolution;
  }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const material = this.fullscreenMaterial;
    material.inputBuffer = inputBuffer.texture;
    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);
    renderer.render(this.scene, this.camera);
  }
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
  }
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0 && frameBufferType !== UnsignedByteType) {
      this.renderTarget.texture.type = frameBufferType;
      this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
    }
  }
};
var MaskPass = class extends Pass {
  constructor(scene, camera) {
    super("MaskPass", scene, camera);
    this.needsSwap = false;
    this.clearPass = new ClearPass(false, false, true);
    this.inverse = false;
  }
  set mainScene(value) {
    this.scene = value;
  }
  set mainCamera(value) {
    this.camera = value;
  }
  get inverted() {
    return this.inverse;
  }
  set inverted(value) {
    this.inverse = value;
  }
  get clear() {
    return this.clearPass.enabled;
  }
  set clear(value) {
    this.clearPass.enabled = value;
  }
  getClearPass() {
    return this.clearPass;
  }
  isInverted() {
    return this.inverted;
  }
  setInverted(value) {
    this.inverted = value;
  }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const context = renderer.getContext();
    const buffers = renderer.state.buffers;
    const scene = this.scene;
    const camera = this.camera;
    const clearPass = this.clearPass;
    const writeValue = this.inverted ? 0 : 1;
    const clearValue = 1 - writeValue;
    buffers.color.setMask(false);
    buffers.depth.setMask(false);
    buffers.color.setLocked(true);
    buffers.depth.setLocked(true);
    buffers.stencil.setTest(true);
    buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
    buffers.stencil.setFunc(context.ALWAYS, writeValue, 4294967295);
    buffers.stencil.setClear(clearValue);
    buffers.stencil.setLocked(true);
    if (this.clearPass.enabled) {
      if (this.renderToScreen) {
        clearPass.render(renderer, null);
      } else {
        clearPass.render(renderer, inputBuffer);
        clearPass.render(renderer, outputBuffer);
      }
    }
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      renderer.render(scene, camera);
    } else {
      renderer.setRenderTarget(inputBuffer);
      renderer.render(scene, camera);
      renderer.setRenderTarget(outputBuffer);
      renderer.render(scene, camera);
    }
    buffers.color.setLocked(false);
    buffers.depth.setLocked(false);
    buffers.stencil.setLocked(false);
    buffers.stencil.setFunc(context.EQUAL, 1, 4294967295);
    buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
    buffers.stencil.setLocked(true);
  }
};
var MipmapBlurPass = class extends Pass {
  constructor() {
    super("MipmapBlurPass");
    this.needsSwap = false;
    this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTarget.texture.name = "Upsampling.Mipmap0";
    this.downsamplingMipmaps = [];
    this.upsamplingMipmaps = [];
    this.downsamplingMaterial = new DownsamplingMaterial();
    this.upsamplingMaterial = new UpsamplingMaterial();
    this.resolution = new Vector2();
  }
  get texture() {
    return this.renderTarget.texture;
  }
  get levels() {
    return this.downsamplingMipmaps.length;
  }
  set levels(value) {
    if (this.levels !== value) {
      const renderTarget = this.renderTarget;
      this.dispose();
      this.downsamplingMipmaps = [];
      this.upsamplingMipmaps = [];
      for (let i2 = 0; i2 < value; ++i2) {
        const mipmap = renderTarget.clone();
        mipmap.texture.name = "Downsampling.Mipmap" + i2;
        this.downsamplingMipmaps.push(mipmap);
      }
      this.upsamplingMipmaps.push(renderTarget);
      for (let i2 = 1, l = value - 1; i2 < l; ++i2) {
        const mipmap = renderTarget.clone();
        mipmap.texture.name = "Upsampling.Mipmap" + i2;
        this.upsamplingMipmaps.push(mipmap);
      }
      this.setSize(this.resolution.x, this.resolution.y);
    }
  }
  get radius() {
    return this.upsamplingMaterial.radius;
  }
  set radius(value) {
    this.upsamplingMaterial.radius = value;
  }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const { scene, camera } = this;
    const { downsamplingMaterial, upsamplingMaterial } = this;
    const { downsamplingMipmaps, upsamplingMipmaps } = this;
    let previousBuffer = inputBuffer;
    this.fullscreenMaterial = downsamplingMaterial;
    for (let i2 = 0, l = downsamplingMipmaps.length; i2 < l; ++i2) {
      const mipmap = downsamplingMipmaps[i2];
      downsamplingMaterial.setSize(previousBuffer.width, previousBuffer.height);
      downsamplingMaterial.inputBuffer = previousBuffer.texture;
      renderer.setRenderTarget(mipmap);
      renderer.render(scene, camera);
      previousBuffer = mipmap;
    }
    this.fullscreenMaterial = upsamplingMaterial;
    for (let i2 = upsamplingMipmaps.length - 1; i2 >= 0; --i2) {
      const mipmap = upsamplingMipmaps[i2];
      upsamplingMaterial.setSize(previousBuffer.width, previousBuffer.height);
      upsamplingMaterial.inputBuffer = previousBuffer.texture;
      upsamplingMaterial.supportBuffer = downsamplingMipmaps[i2].texture;
      renderer.setRenderTarget(mipmap);
      renderer.render(scene, camera);
      previousBuffer = mipmap;
    }
  }
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.set(width, height);
    let w = resolution.width, h = resolution.height;
    for (let i2 = 0, l = this.downsamplingMipmaps.length; i2 < l; ++i2) {
      w = Math.round(w * 0.5);
      h = Math.round(h * 0.5);
      this.downsamplingMipmaps[i2].setSize(w, h);
      if (i2 < this.upsamplingMipmaps.length) {
        this.upsamplingMipmaps[i2].setSize(w, h);
      }
    }
  }
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0) {
      const mipmaps = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);
      for (const mipmap of mipmaps) {
        mipmap.texture.type = frameBufferType;
      }
      if (frameBufferType !== UnsignedByteType) {
        this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
        this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
      } else if (renderer.outputEncoding === sRGBEncoding) {
        for (const mipmap of mipmaps) {
          mipmap.texture.encoding = sRGBEncoding;
        }
      }
    }
  }
  dispose() {
    super.dispose();
    for (const mipmap of this.downsamplingMipmaps.concat(this.upsamplingMipmaps)) {
      mipmap.dispose();
    }
  }
};
var NormalPass = class extends Pass {
  constructor(scene, camera, {
    renderTarget,
    resolutionScale = 1,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("NormalPass");
    this.needsSwap = false;
    this.renderPass = new RenderPass(scene, camera, new MeshNormalMaterial());
    const renderPass = this.renderPass;
    renderPass.ignoreBackground = true;
    renderPass.skipShadowMapUpdate = true;
    const clearPass = renderPass.getClearPass();
    clearPass.overrideClearColor = new Color(7829503);
    clearPass.overrideClearAlpha = 1;
    this.renderTarget = renderTarget;
    if (this.renderTarget === void 0) {
      this.renderTarget = new WebGLRenderTarget(1, 1, {
        minFilter: NearestFilter,
        magFilter: NearestFilter
      });
      this.renderTarget.texture.name = "NormalPass.Target";
    }
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  set mainScene(value) {
    this.renderPass.mainScene = value;
  }
  set mainCamera(value) {
    this.renderPass.mainCamera = value;
  }
  get texture() {
    return this.renderTarget.texture;
  }
  getTexture() {
    return this.renderTarget.texture;
  }
  getResolution() {
    return this.resolution;
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const renderTarget = this.renderToScreen ? null : this.renderTarget;
    this.renderPass.render(renderer, renderTarget, renderTarget);
  }
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
  }
};
var ShaderPass = class extends Pass {
  constructor(material, input = "inputBuffer") {
    super("ShaderPass");
    this.fullscreenMaterial = material;
    this.input = input;
  }
  setInput(input) {
    this.input = input;
  }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const uniforms = this.fullscreenMaterial.uniforms;
    if (inputBuffer !== null && uniforms !== void 0 && uniforms[this.input] !== void 0) {
      uniforms[this.input].value = inputBuffer.texture;
    }
    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
    renderer.render(this.scene, this.camera);
  }
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0 && frameBufferType !== UnsignedByteType) {
      this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
    }
  }
};
var TiltShiftBlurPass = class extends KawaseBlurPass {
  constructor({
    offset = 0,
    rotation = 0,
    focusArea = 0.4,
    feather = 0.3,
    kernelSize = KernelSize.MEDIUM,
    resolutionScale = 0.5,
    resolutionX = Resolution.AUTO_SIZE,
    resolutionY = Resolution.AUTO_SIZE
  } = {}) {
    super({ kernelSize, resolutionScale, resolutionX, resolutionY });
    this.blurMaterial = new TiltShiftBlurMaterial({ kernelSize, offset, rotation, focusArea, feather });
  }
};
var MILLISECONDS_TO_SECONDS = 1 / 1e3;
var SECONDS_TO_MILLISECONDS = 1e3;
var Timer = class {
  constructor() {
    this.previousTime = 0;
    this.currentTime = 0;
    this.delta = 0;
    this.fixedDelta = 1e3 / 60;
    this.elapsed = 0;
    this.timescale = 1;
    this.fixedDeltaEnabled = false;
    this.autoReset = false;
  }
  setFixedDeltaEnabled(enabled) {
    this.fixedDeltaEnabled = enabled;
    return this;
  }
  isAutoResetEnabled(enabled) {
    return this.autoReset;
  }
  setAutoResetEnabled(enabled) {
    if (typeof document !== "undefined" && document.hidden !== void 0) {
      if (enabled) {
        document.addEventListener("visibilitychange", this);
      } else {
        document.removeEventListener("visibilitychange", this);
      }
      this.autoReset = enabled;
    }
    return this;
  }
  getDelta() {
    return this.delta * MILLISECONDS_TO_SECONDS;
  }
  getFixedDelta() {
    return this.fixedDelta * MILLISECONDS_TO_SECONDS;
  }
  setFixedDelta(fixedDelta) {
    this.fixedDelta = fixedDelta * SECONDS_TO_MILLISECONDS;
    return this;
  }
  getElapsed() {
    return this.elapsed * MILLISECONDS_TO_SECONDS;
  }
  getTimescale() {
    return this.timescale;
  }
  setTimescale(timescale) {
    this.timescale = timescale;
    return this;
  }
  update(timestamp) {
    if (this.fixedDeltaEnabled) {
      this.delta = this.fixedDelta;
    } else {
      this.previousTime = this.currentTime;
      this.currentTime = timestamp !== void 0 ? timestamp : performance.now();
      this.delta = this.currentTime - this.previousTime;
    }
    this.delta *= this.timescale;
    this.elapsed += this.delta;
    return this;
  }
  reset() {
    this.delta = 0;
    this.elapsed = 0;
    this.currentTime = performance.now();
    return this;
  }
  handleEvent(event) {
    if (!document.hidden) {
      this.currentTime = performance.now();
    }
  }
  dispose() {
    this.setAutoResetEnabled(false);
  }
};
var EffectComposer = class {
  constructor(renderer = null, {
    depthBuffer = true,
    stencilBuffer = false,
    multisampling = 0,
    frameBufferType
  } = {}) {
    this.renderer = null;
    this.inputBuffer = this.createBuffer(depthBuffer, stencilBuffer, frameBufferType, multisampling);
    this.outputBuffer = this.inputBuffer.clone();
    this.copyPass = new CopyPass();
    this.depthTexture = null;
    this.passes = [];
    this.timer = new Timer();
    this.autoRenderToScreen = true;
    this.setRenderer(renderer);
  }
  get multisampling() {
    return this.inputBuffer.samples || 0;
  }
  set multisampling(value) {
    const buffer2 = this.inputBuffer;
    const multisampling = this.multisampling;
    if (multisampling > 0 && value > 0) {
      this.inputBuffer.samples = value;
      this.outputBuffer.samples = value;
      this.inputBuffer.dispose();
      this.outputBuffer.dispose();
    } else if (multisampling !== value) {
      this.inputBuffer.dispose();
      this.outputBuffer.dispose();
      this.inputBuffer = this.createBuffer(
        buffer2.depthBuffer,
        buffer2.stencilBuffer,
        buffer2.texture.type,
        value
      );
      this.inputBuffer.depthTexture = this.depthTexture;
      this.outputBuffer = this.inputBuffer.clone();
    }
  }
  getTimer() {
    return this.timer;
  }
  getRenderer() {
    return this.renderer;
  }
  setRenderer(renderer) {
    this.renderer = renderer;
    if (renderer !== null) {
      const size2 = renderer.getSize(new Vector2());
      const alpha = renderer.getContext().getContextAttributes().alpha;
      const frameBufferType = this.inputBuffer.texture.type;
      if (frameBufferType === UnsignedByteType && renderer.outputEncoding === sRGBEncoding) {
        this.inputBuffer.texture.encoding = sRGBEncoding;
        this.outputBuffer.texture.encoding = sRGBEncoding;
        this.inputBuffer.dispose();
        this.outputBuffer.dispose();
      }
      renderer.autoClear = false;
      this.setSize(size2.width, size2.height);
      for (const pass of this.passes) {
        pass.initialize(renderer, alpha, frameBufferType);
      }
    }
  }
  replaceRenderer(renderer, updateDOM = true) {
    const oldRenderer = this.renderer;
    const parent = oldRenderer.domElement.parentNode;
    this.setRenderer(renderer);
    if (updateDOM && parent !== null) {
      parent.removeChild(oldRenderer.domElement);
      parent.appendChild(renderer.domElement);
    }
    return oldRenderer;
  }
  createDepthTexture() {
    const depthTexture = this.depthTexture = new DepthTexture();
    this.inputBuffer.depthTexture = depthTexture;
    this.inputBuffer.dispose();
    if (this.inputBuffer.stencilBuffer) {
      depthTexture.format = DepthStencilFormat;
      depthTexture.type = UnsignedInt248Type;
    } else {
      depthTexture.type = UnsignedIntType;
    }
    return depthTexture;
  }
  deleteDepthTexture() {
    if (this.depthTexture !== null) {
      this.depthTexture.dispose();
      this.depthTexture = null;
      this.inputBuffer.depthTexture = null;
      this.inputBuffer.dispose();
      for (const pass of this.passes) {
        pass.setDepthTexture(null);
      }
    }
  }
  createBuffer(depthBuffer, stencilBuffer, type2, multisampling) {
    const renderer = this.renderer;
    const size2 = renderer === null ? new Vector2() : renderer.getDrawingBufferSize(new Vector2());
    const options = {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      stencilBuffer,
      depthBuffer,
      type: type2
    };
    let renderTarget;
    if (multisampling > 0) {
      renderTarget = Number(REVISION.replace(/\D+/g, "")) < 138 ? new WebGLMultisampleRenderTarget(size2.width, size2.height, options) : new WebGLRenderTarget(size2.width, size2.height, options);
      renderTarget.ignoreDepthForMultisampleCopy = false;
      renderTarget.samples = multisampling;
    } else {
      renderTarget = new WebGLRenderTarget(size2.width, size2.height, options);
    }
    if (type2 === UnsignedByteType && renderer !== null && renderer.outputEncoding === sRGBEncoding) {
      renderTarget.texture.encoding = sRGBEncoding;
    }
    renderTarget.texture.name = "EffectComposer.Buffer";
    renderTarget.texture.generateMipmaps = false;
    return renderTarget;
  }
  setMainScene(scene) {
    for (const pass of this.passes) {
      pass.mainScene = scene;
    }
  }
  setMainCamera(camera) {
    for (const pass of this.passes) {
      pass.mainCamera = camera;
    }
  }
  addPass(pass, index) {
    const passes = this.passes;
    const renderer = this.renderer;
    const drawingBufferSize = renderer.getDrawingBufferSize(new Vector2());
    const alpha = renderer.getContext().getContextAttributes().alpha;
    const frameBufferType = this.inputBuffer.texture.type;
    pass.setRenderer(renderer);
    pass.setSize(drawingBufferSize.width, drawingBufferSize.height);
    pass.initialize(renderer, alpha, frameBufferType);
    if (this.autoRenderToScreen) {
      if (passes.length > 0) {
        passes[passes.length - 1].renderToScreen = false;
      }
      if (pass.renderToScreen) {
        this.autoRenderToScreen = false;
      }
    }
    if (index !== void 0) {
      passes.splice(index, 0, pass);
    } else {
      passes.push(pass);
    }
    if (this.autoRenderToScreen) {
      passes[passes.length - 1].renderToScreen = true;
    }
    if (pass.needsDepthTexture || this.depthTexture !== null) {
      if (this.depthTexture === null) {
        const depthTexture = this.createDepthTexture();
        for (pass of passes) {
          pass.setDepthTexture(depthTexture);
        }
      } else {
        pass.setDepthTexture(this.depthTexture);
      }
    }
  }
  removePass(pass) {
    const passes = this.passes;
    const index = passes.indexOf(pass);
    const exists = index !== -1;
    const removed = exists && passes.splice(index, 1).length > 0;
    if (removed) {
      if (this.depthTexture !== null) {
        const reducer = (a2, b2) => a2 || b2.needsDepthTexture;
        const depthTextureRequired = passes.reduce(reducer, false);
        if (!depthTextureRequired) {
          if (pass.getDepthTexture() === this.depthTexture) {
            pass.setDepthTexture(null);
          }
          this.deleteDepthTexture();
        }
      }
      if (this.autoRenderToScreen) {
        if (index === passes.length) {
          pass.renderToScreen = false;
          if (passes.length > 0) {
            passes[passes.length - 1].renderToScreen = true;
          }
        }
      }
    }
  }
  removeAllPasses() {
    const passes = this.passes;
    this.deleteDepthTexture();
    if (passes.length > 0) {
      if (this.autoRenderToScreen) {
        passes[passes.length - 1].renderToScreen = false;
      }
      this.passes = [];
    }
  }
  render(deltaTime) {
    const renderer = this.renderer;
    const copyPass = this.copyPass;
    let inputBuffer = this.inputBuffer;
    let outputBuffer = this.outputBuffer;
    let stencilTest = false;
    let context, stencil, buffer2;
    if (deltaTime === void 0) {
      deltaTime = this.timer.update().getDelta();
    }
    for (const pass of this.passes) {
      if (pass.enabled) {
        pass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);
        if (pass.needsSwap) {
          if (stencilTest) {
            copyPass.renderToScreen = pass.renderToScreen;
            context = renderer.getContext();
            stencil = renderer.state.buffers.stencil;
            stencil.setFunc(context.NOTEQUAL, 1, 4294967295);
            copyPass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);
            stencil.setFunc(context.EQUAL, 1, 4294967295);
          }
          buffer2 = inputBuffer;
          inputBuffer = outputBuffer;
          outputBuffer = buffer2;
        }
        if (pass instanceof MaskPass) {
          stencilTest = true;
        } else if (pass instanceof ClearMaskPass) {
          stencilTest = false;
        }
      }
    }
  }
  setSize(width, height, updateStyle) {
    const renderer = this.renderer;
    const currentSize = renderer.getSize(new Vector2());
    if (width === void 0 || height === void 0) {
      width = currentSize.width;
      height = currentSize.height;
    }
    if (currentSize.width !== width || currentSize.height !== height) {
      renderer.setSize(width, height, updateStyle);
    }
    const drawingBufferSize = renderer.getDrawingBufferSize(new Vector2());
    this.inputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);
    this.outputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);
    for (const pass of this.passes) {
      pass.setSize(drawingBufferSize.width, drawingBufferSize.height);
    }
  }
  reset() {
    const autoReset = this.timer.isAutoResetEnabled();
    this.dispose();
    this.autoRenderToScreen = true;
    this.timer.setAutoResetEnabled(autoReset);
  }
  dispose() {
    for (const pass of this.passes) {
      pass.dispose();
    }
    this.passes = [];
    if (this.inputBuffer !== null) {
      this.inputBuffer.dispose();
    }
    if (this.outputBuffer !== null) {
      this.outputBuffer.dispose();
    }
    this.deleteDepthTexture();
    this.copyPass.dispose();
    this.timer.dispose();
  }
};
var EffectShaderData = class {
  constructor() {
    this.shaderParts = /* @__PURE__ */ new Map([
      [EffectShaderSection.FRAGMENT_HEAD, null],
      [EffectShaderSection.FRAGMENT_MAIN_UV, null],
      [EffectShaderSection.FRAGMENT_MAIN_IMAGE, null],
      [EffectShaderSection.VERTEX_HEAD, null],
      [EffectShaderSection.VERTEX_MAIN_SUPPORT, null]
    ]);
    this.defines = /* @__PURE__ */ new Map();
    this.uniforms = /* @__PURE__ */ new Map();
    this.blendModes = /* @__PURE__ */ new Map();
    this.extensions = /* @__PURE__ */ new Set();
    this.attributes = EffectAttribute.NONE;
    this.varyings = /* @__PURE__ */ new Set();
    this.uvTransformation = false;
    this.readDepth = false;
    this.colorSpace = LinearEncoding;
  }
};
var Selection = class extends Set {
  constructor(iterable, layer = 10) {
    super();
    this.l = layer;
    this.exclusive = false;
    if (iterable !== void 0) {
      this.set(iterable);
    }
  }
  get layer() {
    return this.l;
  }
  set layer(value) {
    const currentLayer = this.l;
    for (const object of this) {
      object.layers.disable(currentLayer);
      object.layers.enable(value);
    }
    this.l = value;
  }
  getLayer() {
    return this.layer;
  }
  setLayer(value) {
    this.layer = value;
  }
  isExclusive() {
    return this.exclusive;
  }
  setExclusive(value) {
    this.exclusive = value;
  }
  clear() {
    const layer = this.layer;
    for (const object of this) {
      object.layers.disable(layer);
    }
    return super.clear();
  }
  set(objects) {
    this.clear();
    for (const object of objects) {
      this.add(object);
    }
    return this;
  }
  indexOf(object) {
    return this.has(object) ? 0 : -1;
  }
  add(object) {
    if (this.exclusive) {
      object.layers.set(this.layer);
    } else {
      object.layers.enable(this.layer);
    }
    return super.add(object);
  }
  delete(object) {
    if (this.has(object)) {
      object.layers.disable(this.layer);
    }
    return super.delete(object);
  }
  toggle(object) {
    let result;
    if (this.has(object)) {
      this.delete(object);
      result = false;
    } else {
      this.add(object);
      result = true;
    }
    return result;
  }
  setVisible(visible) {
    for (const object of this) {
      if (visible) {
        object.layers.enable(0);
      } else {
        object.layers.disable(0);
      }
    }
    return this;
  }
};
var add_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}";
var alpha_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}";
var average_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}";
var color_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}";
var color_burn_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}";
var color_dodge_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}";
var darken_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}";
var difference_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}";
var divide_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}";
var exclusion_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}";
var hard_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}";
var hard_mix_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}";
var hue_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}";
var invert_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}";
var invert_rgb_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}";
var lighten_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}";
var linear_burn_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}";
var linear_dodge_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}";
var linear_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}";
var luminosity_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}";
var multiply_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}";
var negation_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}";
var normal_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}";
var overlay_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}";
var pin_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}";
var reflect_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}";
var saturation_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}";
var screen_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}";
var soft_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}";
var src_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}";
var subtract_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}";
var vivid_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}";
var blendFunctions = /* @__PURE__ */ new Map([
  [BlendFunction.ADD, add_default],
  [BlendFunction.ALPHA, alpha_default],
  [BlendFunction.AVERAGE, average_default],
  [BlendFunction.COLOR, color_default],
  [BlendFunction.COLOR_BURN, color_burn_default],
  [BlendFunction.COLOR_DODGE, color_dodge_default],
  [BlendFunction.DARKEN, darken_default],
  [BlendFunction.DIFFERENCE, difference_default],
  [BlendFunction.DIVIDE, divide_default],
  [BlendFunction.DST, null],
  [BlendFunction.EXCLUSION, exclusion_default],
  [BlendFunction.HARD_LIGHT, hard_light_default],
  [BlendFunction.HARD_MIX, hard_mix_default],
  [BlendFunction.HUE, hue_default],
  [BlendFunction.INVERT, invert_default],
  [BlendFunction.INVERT_RGB, invert_rgb_default],
  [BlendFunction.LIGHTEN, lighten_default],
  [BlendFunction.LINEAR_BURN, linear_burn_default],
  [BlendFunction.LINEAR_DODGE, linear_dodge_default],
  [BlendFunction.LINEAR_LIGHT, linear_light_default],
  [BlendFunction.LUMINOSITY, luminosity_default],
  [BlendFunction.MULTIPLY, multiply_default],
  [BlendFunction.NEGATION, negation_default],
  [BlendFunction.NORMAL, normal_default],
  [BlendFunction.OVERLAY, overlay_default],
  [BlendFunction.PIN_LIGHT, pin_light_default],
  [BlendFunction.REFLECT, reflect_default],
  [BlendFunction.SATURATION, saturation_default],
  [BlendFunction.SCREEN, screen_default],
  [BlendFunction.SOFT_LIGHT, soft_light_default],
  [BlendFunction.SRC, src_default],
  [BlendFunction.SUBTRACT, subtract_default],
  [BlendFunction.VIVID_LIGHT, vivid_light_default]
]);
var BlendMode = class extends EventDispatcher {
  constructor(blendFunction, opacity = 1) {
    super();
    this._blendFunction = blendFunction;
    this.opacity = new Uniform(opacity);
  }
  getOpacity() {
    return this.opacity.value;
  }
  setOpacity(value) {
    this.opacity.value = value;
  }
  get blendFunction() {
    return this._blendFunction;
  }
  set blendFunction(value) {
    this._blendFunction = value;
    this.dispatchEvent({ type: "change" });
  }
  getBlendFunction() {
    return this.blendFunction;
  }
  setBlendFunction(value) {
    this.blendFunction = value;
  }
  getShaderCode() {
    return blendFunctions.get(this.blendFunction);
  }
};
var Effect = class extends EventDispatcher {
  constructor(name, fragmentShader2, {
    attributes = EffectAttribute.NONE,
    blendFunction = BlendFunction.NORMAL,
    defines = /* @__PURE__ */ new Map(),
    uniforms = /* @__PURE__ */ new Map(),
    extensions = null,
    vertexShader: vertexShader2 = null
  } = {}) {
    super();
    this.name = name;
    this.renderer = null;
    this.attributes = attributes;
    this.fragmentShader = fragmentShader2;
    this.vertexShader = vertexShader2;
    this.defines = defines;
    this.uniforms = uniforms;
    this.extensions = extensions;
    this.blendMode = new BlendMode(blendFunction);
    this.blendMode.addEventListener("change", (event) => this.setChanged());
    this._inputColorSpace = LinearEncoding;
    this._outputColorSpace = null;
  }
  get inputColorSpace() {
    return this._inputColorSpace;
  }
  set inputColorSpace(value) {
    this._inputColorSpace = value;
    this.setChanged();
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(value) {
    this._outputColorSpace = value;
    this.setChanged();
  }
  set mainScene(value) {
  }
  set mainCamera(value) {
  }
  getName() {
    return this.name;
  }
  setRenderer(renderer) {
    this.renderer = renderer;
  }
  getDefines() {
    return this.defines;
  }
  getUniforms() {
    return this.uniforms;
  }
  getExtensions() {
    return this.extensions;
  }
  getBlendMode() {
    return this.blendMode;
  }
  getAttributes() {
    return this.attributes;
  }
  setAttributes(attributes) {
    this.attributes = attributes;
    this.setChanged();
  }
  getFragmentShader() {
    return this.fragmentShader;
  }
  setFragmentShader(fragmentShader2) {
    this.fragmentShader = fragmentShader2;
    this.setChanged();
  }
  getVertexShader() {
    return this.vertexShader;
  }
  setVertexShader(vertexShader2) {
    this.vertexShader = vertexShader2;
    this.setChanged();
  }
  setChanged() {
    this.dispatchEvent({ type: "change" });
  }
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
  }
  update(renderer, inputBuffer, deltaTime) {
  }
  setSize(width, height) {
  }
  initialize(renderer, alpha, frameBufferType) {
  }
  dispose() {
    for (const key of Object.keys(this)) {
      const property = this[key];
      const isDisposable = property instanceof WebGLRenderTarget || property instanceof Material || property instanceof Texture || property instanceof Pass;
      if (isDisposable) {
        this[key].dispose();
      }
    }
  }
};
var bloom_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nuniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=texture2D(map,uv)*intensity;}";
var BloomEffect = class extends Effect {
  constructor({
    blendFunction = BlendFunction.SCREEN,
    luminanceThreshold = 0.9,
    luminanceSmoothing = 0.025,
    mipmapBlur = false,
    intensity = 1,
    radius = 0.85,
    levels = 8,
    kernelSize = KernelSize.LARGE,
    resolutionScale = 0.5,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("BloomEffect", bloom_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["map", new Uniform(null)],
        ["intensity", new Uniform(intensity)]
      ])
    });
    this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTarget.texture.name = "Bloom.Target";
    this.blurPass = new KawaseBlurPass({ kernelSize });
    this.luminancePass = new LuminancePass({ colorOutput: true });
    this.luminanceMaterial.threshold = luminanceThreshold;
    this.luminanceMaterial.smoothing = luminanceSmoothing;
    this.mipmapBlurPass = new MipmapBlurPass();
    this.mipmapBlurPass.enabled = mipmapBlur;
    this.mipmapBlurPass.radius = radius;
    this.mipmapBlurPass.levels = levels;
    this.uniforms.get("map").value = mipmapBlur ? this.mipmapBlurPass.texture : this.renderTarget.texture;
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  get texture() {
    return this.mipmapBlurPass.enabled ? this.mipmapBlurPass.texture : this.renderTarget.texture;
  }
  getTexture() {
    return this.texture;
  }
  getResolution() {
    return this.resolution;
  }
  getBlurPass() {
    return this.blurPass;
  }
  getLuminancePass() {
    return this.luminancePass;
  }
  get luminanceMaterial() {
    return this.luminancePass.fullscreenMaterial;
  }
  getLuminanceMaterial() {
    return this.luminancePass.fullscreenMaterial;
  }
  get width() {
    return this.resolution.width;
  }
  set width(value) {
    this.resolution.preferredWidth = value;
  }
  get height() {
    return this.resolution.height;
  }
  set height(value) {
    this.resolution.preferredHeight = value;
  }
  get dithering() {
    return this.blurPass.dithering;
  }
  set dithering(value) {
    this.blurPass.dithering = value;
  }
  get kernelSize() {
    return this.blurPass.kernelSize;
  }
  set kernelSize(value) {
    this.blurPass.kernelSize = value;
  }
  get distinction() {
    console.warn(this.name, "distinction was removed");
    return 1;
  }
  set distinction(value) {
    console.warn(this.name, "distinction was removed");
  }
  get intensity() {
    return this.uniforms.get("intensity").value;
  }
  set intensity(value) {
    this.uniforms.get("intensity").value = value;
  }
  getIntensity() {
    return this.intensity;
  }
  setIntensity(value) {
    this.intensity = value;
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  update(renderer, inputBuffer, deltaTime) {
    const renderTarget = this.renderTarget;
    const luminancePass = this.luminancePass;
    if (luminancePass.enabled) {
      luminancePass.render(renderer, inputBuffer);
      if (this.mipmapBlurPass.enabled) {
        this.mipmapBlurPass.render(renderer, luminancePass.renderTarget);
      } else {
        this.blurPass.render(renderer, luminancePass.renderTarget, renderTarget);
      }
    } else {
      if (this.mipmapBlurPass.enabled) {
        this.mipmapBlurPass.render(renderer, inputBuffer);
      } else {
        this.blurPass.render(renderer, inputBuffer, renderTarget);
      }
    }
  }
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
    this.blurPass.resolution.copy(resolution);
    this.luminancePass.setSize(width, height);
    this.mipmapBlurPass.setSize(width, height);
  }
  initialize(renderer, alpha, frameBufferType) {
    this.blurPass.initialize(renderer, alpha, frameBufferType);
    this.luminancePass.initialize(renderer, alpha, frameBufferType);
    this.mipmapBlurPass.initialize(renderer, alpha, frameBufferType);
    if (frameBufferType !== void 0) {
      this.renderTarget.texture.type = frameBufferType;
      if (renderer.outputEncoding === sRGBEncoding) {
        this.renderTarget.texture.encoding = sRGBEncoding;
      }
    }
  }
};
var brightness_contrast_default = "uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(color+vec3(0.5),inputColor.a);}";
var BrightnessContrastEffect = class extends Effect {
  constructor({ blendFunction = BlendFunction.SRC, brightness = 0, contrast = 0 } = {}) {
    super("BrightnessContrastEffect", brightness_contrast_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["brightness", new Uniform(brightness)],
        ["contrast", new Uniform(contrast)]
      ])
    });
    this.inputColorSpace = sRGBEncoding;
  }
  get brightness() {
    return this.uniforms.get("brightness").value;
  }
  set brightness(value) {
    this.uniforms.get("brightness").value = value;
  }
  getBrightness(value) {
    return this.brightness;
  }
  setBrightness(value) {
    this.brightness = value;
  }
  get contrast() {
    return this.uniforms.get("contrast").value;
  }
  set contrast(value) {
    this.uniforms.get("contrast").value = value;
  }
  getContrast(value) {
    return this.contrast;
  }
  setContrast(value) {
    this.contrast = value;
  }
};
var color_average_default = "void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(vec3(average(inputColor.rgb)),inputColor.a);}";
var ColorAverageEffect = class extends Effect {
  constructor(blendFunction) {
    super("ColorAverageEffect", color_average_default, { blendFunction });
  }
};
var color_depth_default = "uniform float factor;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(floor(inputColor.rgb*factor+0.5)/factor,inputColor.a);}";
var ColorDepthEffect = class extends Effect {
  constructor({ blendFunction, bits = 16 } = {}) {
    super("ColorDepthEffect", color_depth_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["factor", new Uniform(1)]
      ])
    });
    this.bits = 0;
    this.bitDepth = bits;
  }
  get bitDepth() {
    return this.bits;
  }
  set bitDepth(value) {
    this.bits = value;
    this.uniforms.get("factor").value = Math.pow(2, value / 3);
  }
  getBitDepth() {
    return this.bitDepth;
  }
  setBitDepth(value) {
    this.bitDepth = value;
  }
};
var chromatic_aberration_default = "#ifdef RADIAL_MODULATION\nuniform float modulationOffset;\n#endif\nvarying float vActive;varying vec2 vUvR;varying vec2 vUvB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 ra=inputColor.ra;vec2 ba=inputColor.ba;\n#ifdef RADIAL_MODULATION\nconst vec2 center=vec2(0.5);float d=distance(uv,center)*2.0;d=max(d-modulationOffset,0.0);if(vActive>0.0&&d>0.0){ra=texture2D(inputBuffer,mix(uv,vUvR,d)).ra;ba=texture2D(inputBuffer,mix(uv,vUvB,d)).ba;}\n#else\nif(vActive>0.0){ra=texture2D(inputBuffer,vUvR).ra;ba=texture2D(inputBuffer,vUvB).ba;}\n#endif\noutputColor=vec4(ra.x,inputColor.g,ba.x,max(max(ra.y,ba.y),inputColor.a));}";
var chromatic_aberration_default2 = "uniform vec2 offset;varying float vActive;varying vec2 vUvR;varying vec2 vUvB;void mainSupport(const in vec2 uv){vec2 shift=offset*vec2(1.0,aspect);vActive=(shift.x!=0.0||shift.y!=0.0)?1.0:0.0;vUvR=uv+shift;vUvB=uv-shift;}";
var ChromaticAberrationEffect = class extends Effect {
  constructor({
    offset = new Vector2(1e-3, 5e-4),
    radialModulation = false,
    modulationOffset = 0.15
  } = {}) {
    super("ChromaticAberrationEffect", chromatic_aberration_default, {
      vertexShader: chromatic_aberration_default2,
      attributes: EffectAttribute.CONVOLUTION,
      uniforms: /* @__PURE__ */ new Map([
        ["offset", new Uniform(offset)],
        ["modulationOffset", new Uniform(modulationOffset)]
      ])
    });
    this.radialModulation = radialModulation;
  }
  get offset() {
    return this.uniforms.get("offset").value;
  }
  set offset(value) {
    this.uniforms.get("offset").value = value;
  }
  get radialModulation() {
    return this.defines.has("RADIAL_MODULATION");
  }
  set radialModulation(value) {
    if (value) {
      this.defines.set("RADIAL_MODULATION", "1");
    } else {
      this.defines.delete("RADIAL_MODULATION");
    }
    this.setChanged();
  }
  get modulationOffset() {
    return this.uniforms.get("modulationOffset").value;
  }
  set modulationOffset(value) {
    this.uniforms.get("modulationOffset").value = value;
  }
  getOffset() {
    return this.offset;
  }
  setOffset(value) {
    this.offset = value;
  }
};
var depth_default = "void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){\n#ifdef INVERTED\nvec3 color=vec3(1.0-depth);\n#else\nvec3 color=vec3(depth);\n#endif\noutputColor=vec4(color,inputColor.a);}";
var DepthEffect = class extends Effect {
  constructor({ blendFunction = BlendFunction.SRC, inverted = false } = {}) {
    super("DepthEffect", depth_default, {
      blendFunction,
      attributes: EffectAttribute.DEPTH
    });
    this.inverted = inverted;
  }
  get inverted() {
    return this.defines.has("INVERTED");
  }
  set inverted(value) {
    if (this.inverted !== value) {
      if (value) {
        this.defines.set("INVERTED", "1");
      } else {
        this.defines.delete("INVERTED");
      }
      this.setChanged();
    }
  }
  isInverted() {
    return this.inverted;
  }
  setInverted(value) {
    this.inverted = value;
  }
};
var depth_of_field_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;\n#else\nuniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;\n#endif\nuniform lowp sampler2D nearCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);float cocNear=texture2D(nearCoCBuffer,uv).r;cocNear=min(cocNear*scale,1.0);vec4 result=inputColor*(1.0-colorFar.a)+colorFar;result=mix(result,colorNear,cocNear);outputColor=result;}";
var DepthOfFieldEffect = class extends Effect {
  constructor(camera, {
    blendFunction,
    worldFocusDistance,
    worldFocusRange,
    focusDistance = 0,
    focalLength = 0.1,
    focusRange = focalLength,
    bokehScale = 1,
    resolutionScale = 1,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("DepthOfFieldEffect", depth_of_field_default, {
      blendFunction,
      attributes: EffectAttribute.DEPTH,
      uniforms: /* @__PURE__ */ new Map([
        ["nearColorBuffer", new Uniform(null)],
        ["farColorBuffer", new Uniform(null)],
        ["nearCoCBuffer", new Uniform(null)],
        ["scale", new Uniform(1)]
      ])
    });
    this.camera = camera;
    this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTarget.texture.name = "DoF.Intermediate";
    this.renderTargetMasked = this.renderTarget.clone();
    this.renderTargetMasked.texture.name = "DoF.Masked.Far";
    this.renderTargetNear = this.renderTarget.clone();
    this.renderTargetNear.texture.name = "DoF.Bokeh.Near";
    this.uniforms.get("nearColorBuffer").value = this.renderTargetNear.texture;
    this.renderTargetFar = this.renderTarget.clone();
    this.renderTargetFar.texture.name = "DoF.Bokeh.Far";
    this.uniforms.get("farColorBuffer").value = this.renderTargetFar.texture;
    this.renderTargetCoC = this.renderTarget.clone();
    this.renderTargetCoC.texture.name = "DoF.CoC";
    this.renderTargetCoCBlurred = this.renderTargetCoC.clone();
    this.renderTargetCoCBlurred.texture.name = "DoF.CoC.Blurred";
    this.uniforms.get("nearCoCBuffer").value = this.renderTargetCoCBlurred.texture;
    this.cocPass = new ShaderPass(new CircleOfConfusionMaterial(camera));
    const cocMaterial = this.cocMaterial;
    cocMaterial.focusDistance = focusDistance;
    cocMaterial.focusRange = focusRange;
    if (worldFocusDistance !== void 0) {
      cocMaterial.worldFocusDistance = worldFocusDistance;
    }
    if (worldFocusRange !== void 0) {
      cocMaterial.worldFocusRange = worldFocusRange;
    }
    this.blurPass = new KawaseBlurPass({ resolutionScale, resolutionX, resolutionY, kernelSize: KernelSize.MEDIUM });
    this.maskPass = new ShaderPass(new MaskMaterial(this.renderTargetCoC.texture));
    const maskMaterial = this.maskPass.fullscreenMaterial;
    maskMaterial.maskFunction = MaskFunction.MULTIPLY;
    maskMaterial.colorChannel = ColorChannel.GREEN;
    this.bokehNearBasePass = new ShaderPass(new BokehMaterial(false, true));
    this.bokehNearBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture;
    this.bokehNearFillPass = new ShaderPass(new BokehMaterial(true, true));
    this.bokehNearFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture;
    this.bokehFarBasePass = new ShaderPass(new BokehMaterial(false, false));
    this.bokehFarBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture;
    this.bokehFarFillPass = new ShaderPass(new BokehMaterial(true, false));
    this.bokehFarFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture;
    this.target = null;
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
    this.bokehScale = bokehScale;
  }
  set mainCamera(value) {
    this.camera = value;
    this.cocMaterial.copyCameraSettings(value);
  }
  get cocTexture() {
    return this.renderTargetCoC.texture;
  }
  get cocMaterial() {
    return this.cocPass.fullscreenMaterial;
  }
  get circleOfConfusionMaterial() {
    return this.cocMaterial;
  }
  getCircleOfConfusionMaterial() {
    return this.circleOfConfusionMaterial;
  }
  getBlurPass() {
    return this.blurPass;
  }
  getResolution() {
    return this.resolution;
  }
  get bokehScale() {
    return this.uniforms.get("scale").value;
  }
  set bokehScale(value) {
    this.bokehNearBasePass.fullscreenMaterial.scale = value;
    this.bokehNearFillPass.fullscreenMaterial.scale = value;
    this.bokehFarBasePass.fullscreenMaterial.scale = value;
    this.bokehFarFillPass.fullscreenMaterial.scale = value;
    this.maskPass.fullscreenMaterial.strength = value;
    this.uniforms.get("scale").value = value;
  }
  getBokehScale() {
    return this.bokehScale;
  }
  setBokehScale(value) {
    this.bokehScale = value;
  }
  getTarget() {
    return this.target;
  }
  setTarget(value) {
    this.target = value;
  }
  calculateFocusDistance(target) {
    const camera = this.camera;
    const distance2 = camera.position.distanceTo(target);
    return viewZToOrthographicDepth(-distance2, camera.near, camera.far);
  }
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    this.circleOfConfusionMaterial.depthBuffer = depthTexture;
    this.circleOfConfusionMaterial.depthPacking = depthPacking;
  }
  update(renderer, inputBuffer, deltaTime) {
    const renderTarget = this.renderTarget;
    const renderTargetCoC = this.renderTargetCoC;
    const renderTargetCoCBlurred = this.renderTargetCoCBlurred;
    const renderTargetMasked = this.renderTargetMasked;
    if (this.target !== null) {
      const distance2 = this.calculateFocusDistance(this.target);
      this.circleOfConfusionMaterial.focusDistance = distance2;
    }
    this.cocPass.render(renderer, null, renderTargetCoC);
    this.blurPass.render(renderer, renderTargetCoC, renderTargetCoCBlurred);
    this.maskPass.render(renderer, inputBuffer, renderTargetMasked);
    this.bokehFarBasePass.render(renderer, renderTargetMasked, renderTarget);
    this.bokehFarFillPass.render(renderer, renderTarget, this.renderTargetFar);
    this.bokehNearBasePass.render(renderer, inputBuffer, renderTarget);
    this.bokehNearFillPass.render(renderer, renderTarget, this.renderTargetNear);
  }
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    const w = resolution.width, h = resolution.height;
    this.cocPass.setSize(width, height);
    this.blurPass.setSize(width, height);
    this.maskPass.setSize(width, height);
    this.renderTargetCoC.setSize(width, height);
    this.renderTargetMasked.setSize(width, height);
    this.renderTarget.setSize(w, h);
    this.renderTargetNear.setSize(w, h);
    this.renderTargetFar.setSize(w, h);
    this.renderTargetCoCBlurred.setSize(w, h);
    this.bokehNearBasePass.fullscreenMaterial.setSize(width, height);
    this.bokehNearFillPass.fullscreenMaterial.setSize(width, height);
    this.bokehFarBasePass.fullscreenMaterial.setSize(width, height);
    this.bokehFarFillPass.fullscreenMaterial.setSize(width, height);
  }
  initialize(renderer, alpha, frameBufferType) {
    this.cocPass.initialize(renderer, alpha, frameBufferType);
    this.maskPass.initialize(renderer, alpha, frameBufferType);
    this.bokehNearBasePass.initialize(renderer, alpha, frameBufferType);
    this.bokehNearFillPass.initialize(renderer, alpha, frameBufferType);
    this.bokehFarBasePass.initialize(renderer, alpha, frameBufferType);
    this.bokehFarFillPass.initialize(renderer, alpha, frameBufferType);
    this.blurPass.initialize(renderer, alpha, UnsignedByteType);
    if (frameBufferType !== void 0) {
      this.renderTarget.texture.type = frameBufferType;
      this.renderTargetNear.texture.type = frameBufferType;
      this.renderTargetFar.texture.type = frameBufferType;
      this.renderTargetMasked.texture.type = frameBufferType;
      if (renderer.outputEncoding === sRGBEncoding) {
        this.renderTarget.texture.encoding = sRGBEncoding;
        this.renderTargetNear.texture.encoding = sRGBEncoding;
        this.renderTargetFar.texture.encoding = sRGBEncoding;
        this.renderTargetMasked.texture.encoding = sRGBEncoding;
      }
    }
  }
};
var dot_screen_default = "uniform vec2 angle;uniform float scale;float pattern(const in vec2 uv){vec2 point=scale*vec2(dot(angle.yx,vec2(uv.x,-uv.y)),dot(angle,uv));return(sin(point.x)*sin(point.y))*4.0;}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(inputColor.rgb*10.0-5.0+pattern(uv*resolution));outputColor=vec4(color,inputColor.a);}";
var DotScreenEffect = class extends Effect {
  constructor({ blendFunction, angle = Math.PI * 0.5, scale = 1 } = {}) {
    super("DotScreenEffect", dot_screen_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["angle", new Uniform(new Vector2())],
        ["scale", new Uniform(scale)]
      ])
    });
    this.angle = angle;
  }
  get angle() {
    return Math.acos(this.uniforms.get("angle").value.y);
  }
  set angle(value) {
    this.uniforms.get("angle").value.set(Math.sin(value), Math.cos(value));
  }
  getAngle() {
    return this.angle;
  }
  setAngle(value) {
    this.angle = value;
  }
  get scale() {
    return this.uniforms.get("scale").value;
  }
  set scale(value) {
    this.uniforms.get("scale").value = value;
  }
};
function getNoise(size2, format, type2) {
  const channels = /* @__PURE__ */ new Map([
    [LuminanceFormat, 1],
    [RedFormat, 1],
    [RGFormat, 2],
    [RGBAFormat, 4]
  ]);
  let data;
  if (!channels.has(format)) {
    console.error("Invalid noise texture format");
  }
  if (type2 === UnsignedByteType) {
    data = new Uint8Array(size2 * channels.get(format));
    for (let i2 = 0, l = data.length; i2 < l; ++i2) {
      data[i2] = Math.random() * 255 + 0.5;
    }
  } else {
    data = new Float32Array(size2 * channels.get(format));
    for (let i2 = 0, l = data.length; i2 < l; ++i2) {
      data[i2] = Math.random();
    }
  }
  return data;
}
var NoiseTexture = class extends DataTexture {
  constructor(width, height, format = LuminanceFormat, type2 = UnsignedByteType) {
    super(getNoise(width * height, format, type2), width, height, format, type2);
    this.needsUpdate = true;
  }
};
var glitch_default = "uniform lowp sampler2D perturbationMap;uniform bool active;uniform float columns;uniform float random;uniform vec2 seeds;uniform vec2 distortion;void mainUv(inout vec2 uv){if(active){if(uv.y<distortion.x+columns&&uv.y>distortion.x-columns*random){float sx=clamp(ceil(seeds.x),0.0,1.0);uv.y=sx*(1.0-(uv.y+distortion.y))+(1.0-sx)*distortion.y;}if(uv.x<distortion.y+columns&&uv.x>distortion.y-columns*random){float sy=clamp(ceil(seeds.y),0.0,1.0);uv.x=sy*distortion.x+(1.0-sy)*(1.0-(uv.x+distortion.x));}vec2 normal=texture2D(perturbationMap,uv*random*random).rg;uv+=normal*seeds*(random*0.2);}}";
var textureTag = "Glitch.Generated";
function randomFloat(low, high) {
  return low + Math.random() * (high - low);
}
var GlitchEffect = class extends Effect {
  constructor({
    chromaticAberrationOffset = null,
    delay = new Vector2(1.5, 3.5),
    duration = new Vector2(0.6, 1),
    strength = new Vector2(0.3, 1),
    columns = 0.05,
    ratio = 0.85,
    perturbationMap = null,
    dtSize = 64
  } = {}) {
    super("GlitchEffect", glitch_default, {
      uniforms: /* @__PURE__ */ new Map([
        ["perturbationMap", new Uniform(null)],
        ["columns", new Uniform(columns)],
        ["active", new Uniform(false)],
        ["random", new Uniform(1)],
        ["seeds", new Uniform(new Vector2())],
        ["distortion", new Uniform(new Vector2())]
      ])
    });
    if (perturbationMap === null) {
      const map = new NoiseTexture(dtSize, dtSize, RGBAFormat);
      map.name = textureTag;
      this.perturbationMap = map;
    } else {
      this.perturbationMap = perturbationMap;
    }
    this.time = 0;
    this.distortion = this.uniforms.get("distortion").value;
    this.delay = delay;
    this.duration = duration;
    this.breakPoint = new Vector2(
      randomFloat(this.delay.x, this.delay.y),
      randomFloat(this.duration.x, this.duration.y)
    );
    this.strength = strength;
    this.mode = GlitchMode.SPORADIC;
    this.ratio = ratio;
    this.chromaticAberrationOffset = chromaticAberrationOffset;
  }
  get seeds() {
    return this.uniforms.get("seeds").value;
  }
  get active() {
    return this.uniforms.get("active").value;
  }
  isActive() {
    return this.active;
  }
  get minDelay() {
    return this.delay.x;
  }
  set minDelay(value) {
    this.delay.x = value;
  }
  getMinDelay() {
    return this.delay.x;
  }
  setMinDelay(value) {
    this.delay.x = value;
  }
  get maxDelay() {
    return this.delay.y;
  }
  set maxDelay(value) {
    this.delay.y = value;
  }
  getMaxDelay() {
    return this.delay.y;
  }
  setMaxDelay(value) {
    this.delay.y = value;
  }
  get minDuration() {
    return this.duration.x;
  }
  set minDuration(value) {
    this.duration.x = value;
  }
  getMinDuration() {
    return this.duration.x;
  }
  setMinDuration(value) {
    this.duration.x = value;
  }
  get maxDuration() {
    return this.duration.y;
  }
  set maxDuration(value) {
    this.duration.y = value;
  }
  getMaxDuration() {
    return this.duration.y;
  }
  setMaxDuration(value) {
    this.duration.y = value;
  }
  get minStrength() {
    return this.strength.x;
  }
  set minStrength(value) {
    this.strength.x = value;
  }
  getMinStrength() {
    return this.strength.x;
  }
  setMinStrength(value) {
    this.strength.x = value;
  }
  get maxStrength() {
    return this.strength.y;
  }
  set maxStrength(value) {
    this.strength.y = value;
  }
  getMaxStrength() {
    return this.strength.y;
  }
  setMaxStrength(value) {
    this.strength.y = value;
  }
  getMode() {
    return this.mode;
  }
  setMode(value) {
    this.mode = value;
  }
  getGlitchRatio() {
    return 1 - this.ratio;
  }
  setGlitchRatio(value) {
    this.ratio = Math.min(Math.max(1 - value, 0), 1);
  }
  get columns() {
    return this.uniforms.get("columns").value;
  }
  set columns(value) {
    this.uniforms.get("columns").value = value;
  }
  getGlitchColumns() {
    return this.columns;
  }
  setGlitchColumns(value) {
    this.columns = value;
  }
  getChromaticAberrationOffset() {
    return this.chromaticAberrationOffset;
  }
  setChromaticAberrationOffset(value) {
    this.chromaticAberrationOffset = value;
  }
  get perturbationMap() {
    return this.uniforms.get("perturbationMap").value;
  }
  set perturbationMap(value) {
    const currentMap = this.perturbationMap;
    if (currentMap !== null && currentMap.name === textureTag) {
      currentMap.dispose();
    }
    value.minFilter = value.magFilter = NearestFilter;
    value.wrapS = value.wrapT = RepeatWrapping;
    value.generateMipmaps = false;
    this.uniforms.get("perturbationMap").value = value;
  }
  getPerturbationMap() {
    return this.perturbationMap;
  }
  setPerturbationMap(value) {
    this.perturbationMap = value;
  }
  generatePerturbationMap(value = 64) {
    const map = new NoiseTexture(value, value, RGBAFormat);
    map.name = textureTag;
    return map;
  }
  update(renderer, inputBuffer, deltaTime) {
    const mode = this.mode;
    const breakPoint = this.breakPoint;
    const offset = this.chromaticAberrationOffset;
    const s = this.strength;
    let time = this.time;
    let active = false;
    let r = 0, a2 = 0;
    let trigger;
    if (mode !== GlitchMode.DISABLED) {
      if (mode === GlitchMode.SPORADIC) {
        time += deltaTime;
        trigger = time > breakPoint.x;
        if (time >= breakPoint.x + breakPoint.y) {
          breakPoint.set(
            randomFloat(this.delay.x, this.delay.y),
            randomFloat(this.duration.x, this.duration.y)
          );
          time = 0;
        }
      }
      r = Math.random();
      this.uniforms.get("random").value = r;
      if (trigger && r > this.ratio || mode === GlitchMode.CONSTANT_WILD) {
        active = true;
        r *= s.y * 0.03;
        a2 = randomFloat(-Math.PI, Math.PI);
        this.seeds.set(randomFloat(-s.y, s.y), randomFloat(-s.y, s.y));
        this.distortion.set(randomFloat(0, 1), randomFloat(0, 1));
      } else if (trigger || mode === GlitchMode.CONSTANT_MILD) {
        active = true;
        r *= s.x * 0.03;
        a2 = randomFloat(-Math.PI, Math.PI);
        this.seeds.set(randomFloat(-s.x, s.x), randomFloat(-s.x, s.x));
        this.distortion.set(randomFloat(0, 1), randomFloat(0, 1));
      }
      this.time = time;
    }
    if (offset !== null) {
      if (active) {
        offset.set(Math.cos(a2), Math.sin(a2)).multiplyScalar(r);
      } else {
        offset.set(0, 0);
      }
    }
    this.uniforms.get("active").value = active;
  }
  dispose() {
    const map = this.perturbationMap;
    if (map !== null && map.name === textureTag) {
      map.dispose();
    }
  }
};
var god_rays_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=texture2D(map,uv);}";
var v = new Vector3();
var m = new Matrix4();
var GodRaysEffect = class extends Effect {
  constructor(camera, lightSource, {
    blendFunction = BlendFunction.SCREEN,
    samples = 60,
    density = 0.96,
    decay = 0.9,
    weight = 0.4,
    exposure = 0.6,
    clampMax = 1,
    blur = true,
    kernelSize = KernelSize.SMALL,
    resolutionScale = 0.5,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("GodRaysEffect", god_rays_default, {
      blendFunction,
      attributes: EffectAttribute.DEPTH,
      uniforms: /* @__PURE__ */ new Map([
        ["map", new Uniform(null)]
      ])
    });
    this.camera = camera;
    this.lightSource = lightSource;
    this.lightSource.material.depthWrite = false;
    this.lightSource.material.transparent = true;
    this.lightScene = new Scene();
    this.screenPosition = new Vector2();
    this.renderTargetA = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTargetA.texture.name = "GodRays.Target.A";
    this.renderTargetB = this.renderTargetA.clone();
    this.renderTargetB.texture.name = "GodRays.Target.B";
    this.uniforms.get("map").value = this.renderTargetB.texture;
    this.renderTargetLight = new WebGLRenderTarget(1, 1);
    this.renderTargetLight.texture.name = "GodRays.Light";
    this.renderTargetLight.depthTexture = new DepthTexture();
    this.renderPassLight = new RenderPass(this.lightScene, camera);
    this.renderPassLight.clearPass.overrideClearColor = new Color(0);
    this.clearPass = new ClearPass(true, false, false);
    this.clearPass.overrideClearColor = new Color(0);
    this.blurPass = new KawaseBlurPass({ kernelSize });
    this.blurPass.enabled = blur;
    this.depthMaskPass = new ShaderPass(new DepthMaskMaterial());
    const depthMaskMaterial = this.depthMaskMaterial;
    depthMaskMaterial.depthBuffer1 = this.renderTargetLight.depthTexture;
    depthMaskMaterial.copyCameraSettings(camera);
    this.godRaysPass = new ShaderPass(new GodRaysMaterial(this.screenPosition));
    const godRaysMaterial = this.godRaysMaterial;
    godRaysMaterial.density = density;
    godRaysMaterial.decay = decay;
    godRaysMaterial.weight = weight;
    godRaysMaterial.exposure = exposure;
    godRaysMaterial.maxIntensity = clampMax;
    godRaysMaterial.samples = samples;
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  set mainCamera(value) {
    this.camera = value;
    this.renderPassLight.mainCamera = value;
    this.depthMaskMaterial.copyCameraSettings(value);
  }
  getBlurPass() {
    return this.blurPass;
  }
  get texture() {
    return this.renderTargetB.texture;
  }
  getTexture() {
    return this.texture;
  }
  get depthMaskMaterial() {
    return this.depthMaskPass.fullscreenMaterial;
  }
  get godRaysMaterial() {
    return this.godRaysPass.fullscreenMaterial;
  }
  getGodRaysMaterial() {
    return this.godRaysMaterial;
  }
  getResolution() {
    return this.resolution;
  }
  get width() {
    return this.resolution.width;
  }
  set width(value) {
    this.resolution.preferredWidth = value;
  }
  get height() {
    return this.resolution.height;
  }
  set height(value) {
    this.resolution.preferredHeight = value;
  }
  get dithering() {
    return this.godRaysMaterial.dithering;
  }
  set dithering(value) {
    const material = this.godRaysMaterial;
    material.dithering = value;
    material.needsUpdate = true;
  }
  get blur() {
    return this.blurPass.enabled;
  }
  set blur(value) {
    this.blurPass.enabled = value;
  }
  get kernelSize() {
    return this.blurPass.kernelSize;
  }
  set kernelSize(value) {
    this.blurPass.kernelSize = value;
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  get samples() {
    return this.godRaysMaterial.samples;
  }
  set samples(value) {
    this.godRaysMaterial.samples = value;
  }
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    this.depthMaskPass.fullscreenMaterial.depthBuffer0 = depthTexture;
    this.depthMaskPass.fullscreenMaterial.depthPacking0 = depthPacking;
  }
  update(renderer, inputBuffer, deltaTime) {
    const lightSource = this.lightSource;
    const parent = lightSource.parent;
    const matrixAutoUpdate = lightSource.matrixAutoUpdate;
    const renderTargetA = this.renderTargetA;
    const renderTargetLight = this.renderTargetLight;
    lightSource.material.depthWrite = true;
    lightSource.matrixAutoUpdate = false;
    lightSource.updateWorldMatrix(true, false);
    if (parent !== null) {
      if (!matrixAutoUpdate) {
        m.copy(lightSource.matrix);
      }
      lightSource.matrix.copy(lightSource.matrixWorld);
    }
    this.lightScene.add(lightSource);
    this.renderPassLight.render(renderer, renderTargetLight);
    this.clearPass.render(renderer, renderTargetA);
    this.depthMaskPass.render(renderer, renderTargetLight, renderTargetA);
    lightSource.material.depthWrite = false;
    lightSource.matrixAutoUpdate = matrixAutoUpdate;
    if (parent !== null) {
      if (!matrixAutoUpdate) {
        lightSource.matrix.copy(m);
      }
      parent.add(lightSource);
    }
    v.setFromMatrixPosition(lightSource.matrixWorld).project(this.camera);
    this.screenPosition.set(
      Math.min(Math.max((v.x + 1) * 0.5, -1), 2),
      Math.min(Math.max((v.y + 1) * 0.5, -1), 2)
    );
    if (this.blurPass.enabled) {
      this.blurPass.render(renderer, renderTargetA, renderTargetA);
    }
    this.godRaysPass.render(renderer, renderTargetA, this.renderTargetB);
  }
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    const w = resolution.width, h = resolution.height;
    this.renderTargetA.setSize(w, h);
    this.renderTargetB.setSize(w, h);
    this.renderTargetLight.setSize(w, h);
    this.blurPass.resolution.copy(resolution);
  }
  initialize(renderer, alpha, frameBufferType) {
    this.blurPass.initialize(renderer, alpha, frameBufferType);
    this.renderPassLight.initialize(renderer, alpha, frameBufferType);
    this.depthMaskPass.initialize(renderer, alpha, frameBufferType);
    this.godRaysPass.initialize(renderer, alpha, frameBufferType);
    if (frameBufferType !== void 0) {
      this.renderTargetA.texture.type = frameBufferType;
      this.renderTargetB.texture.type = frameBufferType;
      this.renderTargetLight.texture.type = frameBufferType;
      if (renderer.outputEncoding === sRGBEncoding) {
        this.renderTargetA.texture.encoding = sRGBEncoding;
        this.renderTargetB.texture.encoding = sRGBEncoding;
        this.renderTargetLight.texture.encoding = sRGBEncoding;
      }
    }
  }
};
var grid_default = "uniform vec2 scale;uniform float lineWidth;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float grid=0.5-max(abs(mod(uv.x*scale.x,1.0)-0.5),abs(mod(uv.y*scale.y,1.0)-0.5));outputColor=vec4(vec3(smoothstep(0.0,lineWidth,grid)),inputColor.a);}";
var GridEffect = class extends Effect {
  constructor({ blendFunction = BlendFunction.OVERLAY, scale = 1, lineWidth = 0 } = {}) {
    super("GridEffect", grid_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["scale", new Uniform(new Vector2())],
        ["lineWidth", new Uniform(lineWidth)]
      ])
    });
    this.resolution = new Vector2();
    this.s = 0;
    this.scale = scale;
    this.l = 0;
    this.lineWidth = lineWidth;
  }
  get scale() {
    return this.s;
  }
  set scale(value) {
    this.s = Math.max(value, 1e-6);
    this.setSize(this.resolution.width, this.resolution.height);
  }
  getScale() {
    return this.scale;
  }
  setScale(value) {
    this.scale = value;
  }
  get lineWidth() {
    return this.l;
  }
  set lineWidth(value) {
    this.l = value;
    this.setSize(this.resolution.width, this.resolution.height);
  }
  getLineWidth() {
    return this.lineWidth;
  }
  setLineWidth(value) {
    this.lineWidth = value;
  }
  setSize(width, height) {
    this.resolution.set(width, height);
    const aspect = width / height;
    const scale = this.scale * (height * 0.125);
    this.uniforms.get("scale").value.set(aspect * scale, scale);
    this.uniforms.get("lineWidth").value = scale / height + this.lineWidth;
  }
};
var hue_saturation_default = "uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}";
var HueSaturationEffect = class extends Effect {
  constructor({ blendFunction = BlendFunction.SRC, hue = 0, saturation = 0 } = {}) {
    super("HueSaturationEffect", hue_saturation_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["hue", new Uniform(new Vector3())],
        ["saturation", new Uniform(saturation)]
      ])
    });
    this.hue = hue;
  }
  get saturation() {
    return this.uniforms.get("saturation").value;
  }
  set saturation(value) {
    this.uniforms.get("saturation").value = value;
  }
  getSaturation() {
    return this.saturation;
  }
  setSaturation(value) {
    this.saturation = value;
  }
  get hue() {
    const hue = this.uniforms.get("hue").value;
    return Math.acos((hue.x * 3 - 1) / 2);
  }
  set hue(value) {
    const s = Math.sin(value), c2 = Math.cos(value);
    this.uniforms.get("hue").value.set(
      (2 * c2 + 1) / 3,
      (-Math.sqrt(3) * s - c2 + 1) / 3,
      (Math.sqrt(3) * s - c2 + 1) / 3
    );
  }
  getHue() {
    return this.hue;
  }
  setHue(value) {
    this.hue = value;
  }
};
function createCanvas(width, height, data) {
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  canvas.width = width;
  canvas.height = height;
  if (data instanceof Image) {
    context.drawImage(data, 0, 0);
  } else {
    const imageData = context.createImageData(width, height);
    imageData.data.set(data);
    context.putImageData(imageData, 0, 0);
  }
  return canvas;
}
var RawImageData = class {
  constructor(width = 0, height = 0, data = null) {
    this.width = width;
    this.height = height;
    this.data = data;
  }
  toCanvas() {
    return typeof document === "undefined" ? null : createCanvas(this.width, this.height, this.data);
  }
  static from(image) {
    const { width, height } = image;
    let data;
    if (image instanceof Image) {
      const canvas = createCanvas(width, height, image);
      if (canvas !== null) {
        const context = canvas.getContext("2d");
        data = context.getImageData(0, 0, width, height).data;
      }
    } else {
      data = image.data;
    }
    return new RawImageData(width, height, data);
  }
};
var worker_default = '"use strict";(()=>{var O=Math.pow;var _={SCALE_UP:"lut.scaleup"};var k=[new Float32Array(3),new Float32Array(3)],n=[new Float32Array(3),new Float32Array(3),new Float32Array(3),new Float32Array(3)],Z=[[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([0,1,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([0,1,1]),new Float32Array([1,1,1])]];function d(a,t,r,m){let i=r[0]-t[0],e=r[1]-t[1],y=r[2]-t[2],h=a[0]-t[0],A=a[1]-t[1],w=a[2]-t[2],c=e*w-y*A,l=y*h-i*w,x=i*A-e*h,u=Math.sqrt(c*c+l*l+x*x),b=u*.5,s=c/u,F=l/u,f=x/u,p=-(a[0]*s+a[1]*F+a[2]*f),M=m[0]*s+m[1]*F+m[2]*f;return Math.abs(M+p)*b/3}function V(a,t,r,m,i,e){let y=(r+m*t+i*t*t)*4;e[0]=a[y+0],e[1]=a[y+1],e[2]=a[y+2]}function j(a,t,r,m,i,e){let y=r*(t-1),h=m*(t-1),A=i*(t-1),w=Math.floor(y),c=Math.floor(h),l=Math.floor(A),x=Math.ceil(y),u=Math.ceil(h),b=Math.ceil(A),s=y-w,F=h-c,f=A-l;if(w===y&&c===h&&l===A)V(a,t,y,h,A,e);else{let p;s>=F&&F>=f?p=Z[0]:s>=f&&f>=F?p=Z[1]:f>=s&&s>=F?p=Z[2]:F>=s&&s>=f?p=Z[3]:F>=f&&f>=s?p=Z[4]:f>=F&&F>=s&&(p=Z[5]);let[M,g,X,Y]=p,P=k[0];P[0]=s,P[1]=F,P[2]=f;let o=k[1],L=x-w,S=u-c,U=b-l;o[0]=L*M[0]+w,o[1]=S*M[1]+c,o[2]=U*M[2]+l,V(a,t,o[0],o[1],o[2],n[0]),o[0]=L*g[0]+w,o[1]=S*g[1]+c,o[2]=U*g[2]+l,V(a,t,o[0],o[1],o[2],n[1]),o[0]=L*X[0]+w,o[1]=S*X[1]+c,o[2]=U*X[2]+l,V(a,t,o[0],o[1],o[2],n[2]),o[0]=L*Y[0]+w,o[1]=S*Y[1]+c,o[2]=U*Y[2]+l,V(a,t,o[0],o[1],o[2],n[3]);let T=d(g,X,Y,P)*6,q=d(M,X,Y,P)*6,C=d(M,g,Y,P)*6,E=d(M,g,X,P)*6;n[0][0]*=T,n[0][1]*=T,n[0][2]*=T,n[1][0]*=q,n[1][1]*=q,n[1][2]*=q,n[2][0]*=C,n[2][1]*=C,n[2][2]*=C,n[3][0]*=E,n[3][1]*=E,n[3][2]*=E,e[0]=n[0][0]+n[1][0]+n[2][0]+n[3][0],e[1]=n[0][1]+n[1][1]+n[2][1]+n[3][1],e[2]=n[0][2]+n[1][2]+n[2][2]+n[3][2]}}var v=class{static expand(t,r){let m=Math.cbrt(t.length/4),i=new Float32Array(3),e=new t.constructor(O(r,3)*4),y=t instanceof Uint8Array?255:1,h=O(r,2),A=1/(r-1);for(let w=0;w<r;++w)for(let c=0;c<r;++c)for(let l=0;l<r;++l){let x=l*A,u=c*A,b=w*A,s=Math.round(l+c*r+w*h)*4;j(t,m,x,u,b,i),e[s+0]=i[0],e[s+1]=i[1],e[s+2]=i[2],e[s+3]=y}return e}};self.addEventListener("message",a=>{let t=a.data,r=t.data;switch(t.operation){case _.SCALE_UP:r=v.expand(r,t.size);break}postMessage(r,[r.buffer]),close()});})();\n';
var c = new Color();
var LookupTexture = class extends DataTexture3D {
  constructor(data, size2) {
    super(data, size2, size2, size2);
    this.type = FloatType;
    this.format = RGBAFormat;
    this.encoding = LinearEncoding;
    this.minFilter = LinearFilter;
    this.magFilter = LinearFilter;
    this.wrapS = ClampToEdgeWrapping;
    this.wrapT = ClampToEdgeWrapping;
    this.wrapR = ClampToEdgeWrapping;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
    this.domainMin = new Vector3(0, 0, 0);
    this.domainMax = new Vector3(1, 1, 1);
  }
  get isLookupTexture3D() {
    return true;
  }
  scaleUp(size2, transferData = true) {
    const image = this.image;
    let promise;
    if (size2 <= image.width) {
      promise = Promise.reject(new Error("The target size must be greater than the current size"));
    } else {
      promise = new Promise((resolve, reject) => {
        const workerURL = URL.createObjectURL(new Blob([worker_default], {
          type: "text/javascript"
        }));
        const worker = new Worker(workerURL);
        worker.addEventListener("error", (event) => reject(event.error));
        worker.addEventListener("message", (event) => {
          const lut = new LookupTexture(event.data, size2);
          lut.encoding = this.encoding;
          lut.type = this.type;
          lut.name = this.name;
          URL.revokeObjectURL(workerURL);
          resolve(lut);
        });
        const transferList = transferData ? [image.data.buffer] : [];
        worker.postMessage({
          operation: LUTOperation.SCALE_UP,
          data: image.data,
          size: size2
        }, transferList);
      });
    }
    return promise;
  }
  applyLUT(lut) {
    const img0 = this.image;
    const img1 = lut.image;
    const size0 = Math.min(img0.width, img0.height, img0.depth);
    const size1 = Math.min(img1.width, img1.height, img1.depth);
    if (size0 !== size1) {
      console.error("Size mismatch");
    } else if (lut.type !== FloatType || this.type !== FloatType) {
      console.error("Both LUTs must be FloatType textures");
    } else if (lut.format !== RGBAFormat || this.format !== RGBAFormat) {
      console.error("Both LUTs must be RGBA textures");
    } else {
      const data0 = img0.data;
      const data1 = img1.data;
      const size2 = size0;
      const sizeSq = size2 ** 2;
      const s = size2 - 1;
      for (let i2 = 0, l = size2 ** 3; i2 < l; ++i2) {
        const i4 = i2 * 4;
        const r = data0[i4 + 0] * s;
        const g = data0[i4 + 1] * s;
        const b2 = data0[i4 + 2] * s;
        const iRGB = Math.round(r + g * size2 + b2 * sizeSq) * 4;
        data0[i4 + 0] = data1[iRGB + 0];
        data0[i4 + 1] = data1[iRGB + 1];
        data0[i4 + 2] = data1[iRGB + 2];
      }
      this.needsUpdate = true;
    }
    return this;
  }
  convertToUint8() {
    if (this.type === FloatType) {
      const floatData = this.image.data;
      const uint8Data = new Uint8Array(floatData.length);
      for (let i2 = 0, l = floatData.length; i2 < l; ++i2) {
        uint8Data[i2] = floatData[i2] * 255 + 0.5;
      }
      this.image.data = uint8Data;
      this.type = UnsignedByteType;
      this.needsUpdate = true;
    }
    return this;
  }
  convertToFloat() {
    if (this.type === UnsignedByteType) {
      const uint8Data = this.image.data;
      const floatData = new Float32Array(uint8Data.length);
      for (let i2 = 0, l = uint8Data.length; i2 < l; ++i2) {
        floatData[i2] = uint8Data[i2] / 255;
      }
      this.image.data = floatData;
      this.type = FloatType;
      this.needsUpdate = true;
    }
    return this;
  }
  convertToRGBA() {
    console.warn("LookupTexture", "convertToRGBA() is deprecated, LUTs are now RGBA by default");
    return this;
  }
  convertLinearToSRGB() {
    const data = this.image.data;
    if (this.type === FloatType) {
      for (let i2 = 0, l = data.length; i2 < l; i2 += 4) {
        c.fromArray(data, i2).convertLinearToSRGB().toArray(data, i2);
      }
      this.encoding = sRGBEncoding;
      this.needsUpdate = true;
    } else {
      console.error("Color space conversion requires FloatType data");
    }
    return this;
  }
  convertSRGBToLinear() {
    const data = this.image.data;
    if (this.type === FloatType) {
      for (let i2 = 0, l = data.length; i2 < l; i2 += 4) {
        c.fromArray(data, i2).convertSRGBToLinear().toArray(data, i2);
      }
      this.encoding = LinearEncoding;
      this.needsUpdate = true;
    } else {
      console.error("Color space conversion requires FloatType data");
    }
    return this;
  }
  toDataTexture() {
    const width = this.image.width;
    const height = this.image.height * this.image.depth;
    const texture2 = new DataTexture(this.image.data, width, height);
    texture2.name = this.name;
    texture2.type = this.type;
    texture2.format = this.format;
    texture2.encoding = this.encoding;
    texture2.minFilter = LinearFilter;
    texture2.magFilter = LinearFilter;
    texture2.wrapS = this.wrapS;
    texture2.wrapT = this.wrapT;
    texture2.generateMipmaps = false;
    texture2.needsUpdate = true;
    return texture2;
  }
  static from(texture2) {
    const image = texture2.image;
    const { width, height } = image;
    const size2 = Math.min(width, height);
    let data;
    if (image instanceof Image) {
      const rawImageData = RawImageData.from(image);
      const src = rawImageData.data;
      if (width > height) {
        data = new Uint8Array(src.length);
        for (let z = 0; z < size2; ++z) {
          for (let y = 0; y < size2; ++y) {
            for (let x = 0; x < size2; ++x) {
              const i4 = (x + z * size2 + y * size2 * size2) * 4;
              const j4 = (x + y * size2 + z * size2 * size2) * 4;
              data[j4 + 0] = src[i4 + 0];
              data[j4 + 1] = src[i4 + 1];
              data[j4 + 2] = src[i4 + 2];
              data[j4 + 3] = src[i4 + 3];
            }
          }
        }
      } else {
        data = new Uint8Array(src.buffer);
      }
    } else {
      data = image.data.slice();
    }
    const lut = new LookupTexture(data, size2);
    lut.encoding = texture2.encoding;
    lut.type = texture2.type;
    lut.name = texture2.name;
    return lut;
  }
  static createNeutral(size2) {
    const data = new Float32Array(size2 ** 3 * 4);
    const sizeSq = size2 ** 2;
    const s = 1 / (size2 - 1);
    for (let r = 0; r < size2; ++r) {
      for (let g = 0; g < size2; ++g) {
        for (let b2 = 0; b2 < size2; ++b2) {
          const i4 = (r + g * size2 + b2 * sizeSq) * 4;
          data[i4 + 0] = r * s;
          data[i4 + 1] = g * s;
          data[i4 + 2] = b2 * s;
          data[i4 + 3] = 1;
        }
      }
    }
    const lut = new LookupTexture(data, size2);
    lut.name = "neutral";
    return lut;
  }
};
var P = [
  new Float32Array(3),
  new Float32Array(3)
];
var C = [
  new Float32Array(3),
  new Float32Array(3),
  new Float32Array(3),
  new Float32Array(3)
];
var T = [
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([1, 0, 0]),
    new Float32Array([1, 1, 0]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([1, 0, 0]),
    new Float32Array([1, 0, 1]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 0, 1]),
    new Float32Array([1, 0, 1]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 1, 0]),
    new Float32Array([1, 1, 0]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 1, 0]),
    new Float32Array([0, 1, 1]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 0, 1]),
    new Float32Array([0, 1, 1]),
    new Float32Array([1, 1, 1])
  ]
];
var area = [
  new Float32Array(2),
  new Float32Array(2)
];
var orthogonalSubsamplingOffsets = new Float32Array([
  0,
  -0.25,
  0.25,
  -0.125,
  0.125,
  -0.375,
  0.375
]);
var diagonalSubsamplingOffsets = [
  new Float32Array([0, 0]),
  new Float32Array([0.25, -0.25]),
  new Float32Array([-0.25, 0.25]),
  new Float32Array([0.125, -0.125]),
  new Float32Array([-0.125, 0.125])
];
var orthogonalEdges = [
  new Uint8Array([0, 0]),
  new Uint8Array([3, 0]),
  new Uint8Array([0, 3]),
  new Uint8Array([3, 3]),
  new Uint8Array([1, 0]),
  new Uint8Array([4, 0]),
  new Uint8Array([1, 3]),
  new Uint8Array([4, 3]),
  new Uint8Array([0, 1]),
  new Uint8Array([3, 1]),
  new Uint8Array([0, 4]),
  new Uint8Array([3, 4]),
  new Uint8Array([1, 1]),
  new Uint8Array([4, 1]),
  new Uint8Array([1, 4]),
  new Uint8Array([4, 4])
];
var diagonalEdges = [
  new Uint8Array([0, 0]),
  new Uint8Array([1, 0]),
  new Uint8Array([0, 2]),
  new Uint8Array([1, 2]),
  new Uint8Array([2, 0]),
  new Uint8Array([3, 0]),
  new Uint8Array([2, 2]),
  new Uint8Array([3, 2]),
  new Uint8Array([0, 1]),
  new Uint8Array([1, 1]),
  new Uint8Array([0, 3]),
  new Uint8Array([1, 3]),
  new Uint8Array([2, 1]),
  new Uint8Array([3, 1]),
  new Uint8Array([2, 3]),
  new Uint8Array([3, 3])
];
var edges = /* @__PURE__ */ new Map([
  [bilinear(0, 0, 0, 0), new Float32Array([0, 0, 0, 0])],
  [bilinear(0, 0, 0, 1), new Float32Array([0, 0, 0, 1])],
  [bilinear(0, 0, 1, 0), new Float32Array([0, 0, 1, 0])],
  [bilinear(0, 0, 1, 1), new Float32Array([0, 0, 1, 1])],
  [bilinear(0, 1, 0, 0), new Float32Array([0, 1, 0, 0])],
  [bilinear(0, 1, 0, 1), new Float32Array([0, 1, 0, 1])],
  [bilinear(0, 1, 1, 0), new Float32Array([0, 1, 1, 0])],
  [bilinear(0, 1, 1, 1), new Float32Array([0, 1, 1, 1])],
  [bilinear(1, 0, 0, 0), new Float32Array([1, 0, 0, 0])],
  [bilinear(1, 0, 0, 1), new Float32Array([1, 0, 0, 1])],
  [bilinear(1, 0, 1, 0), new Float32Array([1, 0, 1, 0])],
  [bilinear(1, 0, 1, 1), new Float32Array([1, 0, 1, 1])],
  [bilinear(1, 1, 0, 0), new Float32Array([1, 1, 0, 0])],
  [bilinear(1, 1, 0, 1), new Float32Array([1, 1, 0, 1])],
  [bilinear(1, 1, 1, 0), new Float32Array([1, 1, 1, 0])],
  [bilinear(1, 1, 1, 1), new Float32Array([1, 1, 1, 1])]
]);
function lerp2(a2, b2, p) {
  return a2 + (b2 - a2) * p;
}
function bilinear(e0, e1, e2, e3) {
  const a2 = lerp2(e0, e1, 1 - 0.25);
  const b2 = lerp2(e2, e3, 1 - 0.25);
  return lerp2(a2, b2, 1 - 0.125);
}
var lut_3d_default = "uniform vec3 scale;uniform vec3 offset;\n#ifdef CUSTOM_INPUT_DOMAIN\nuniform vec3 domainMin;uniform vec3 domainMax;\n#endif\n#ifdef LUT_3D\n#ifdef LUT_PRECISION_HIGH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler3D lut;\n#else\nuniform mediump sampler3D lut;\n#endif\n#else\nuniform lowp sampler3D lut;\n#endif\nvec4 applyLUT(const in vec3 rgb){\n#ifdef TETRAHEDRAL_INTERPOLATION\nvec3 p=floor(rgb);vec3 f=rgb-p;vec3 v1=(p+0.5)*LUT_TEXEL_WIDTH;vec3 v4=(p+1.5)*LUT_TEXEL_WIDTH;vec3 v2,v3;vec3 frac;if(f.r>=f.g){if(f.g>f.b){frac=f.rgb;v2=vec3(v4.x,v1.y,v1.z);v3=vec3(v4.x,v4.y,v1.z);}else if(f.r>=f.b){frac=f.rbg;v2=vec3(v4.x,v1.y,v1.z);v3=vec3(v4.x,v1.y,v4.z);}else{frac=f.brg;v2=vec3(v1.x,v1.y,v4.z);v3=vec3(v4.x,v1.y,v4.z);}}else{if(f.b>f.g){frac=f.bgr;v2=vec3(v1.x,v1.y,v4.z);v3=vec3(v1.x,v4.y,v4.z);}else if(f.r>=f.b){frac=f.grb;v2=vec3(v1.x,v4.y,v1.z);v3=vec3(v4.x,v4.y,v1.z);}else{frac=f.gbr;v2=vec3(v1.x,v4.y,v1.z);v3=vec3(v1.x,v4.y,v4.z);}}vec4 n1=texture(lut,v1);vec4 n2=texture(lut,v2);vec4 n3=texture(lut,v3);vec4 n4=texture(lut,v4);vec4 weights=vec4(1.0-frac.x,frac.x-frac.y,frac.y-frac.z,frac.z);vec4 result=weights*mat4(vec4(n1.r,n2.r,n3.r,n4.r),vec4(n1.g,n2.g,n3.g,n4.g),vec4(n1.b,n2.b,n3.b,n4.b),vec4(1.0));return vec4(result.rgb,1.0);\n#else\nreturn texture(lut,rgb);\n#endif\n}\n#else\n#ifdef LUT_PRECISION_HIGH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D lut;\n#else\nuniform mediump sampler2D lut;\n#endif\n#else\nuniform lowp sampler2D lut;\n#endif\nvec4 applyLUT(const in vec3 rgb){float slice=rgb.b*LUT_SIZE;float slice0=floor(slice);float interp=slice-slice0;float centeredInterp=interp-0.5;float slice1=slice0+sign(centeredInterp);\n#ifdef LUT_STRIP_HORIZONTAL\nfloat xOffset=clamp(rgb.r*LUT_TEXEL_HEIGHT,LUT_TEXEL_WIDTH*0.5,LUT_TEXEL_HEIGHT-LUT_TEXEL_WIDTH*0.5);vec2 uv0=vec2(slice0*LUT_TEXEL_HEIGHT+xOffset,rgb.g);vec2 uv1=vec2(slice1*LUT_TEXEL_HEIGHT+xOffset,rgb.g);\n#else\nfloat yOffset=clamp(rgb.g*LUT_TEXEL_WIDTH,LUT_TEXEL_HEIGHT*0.5,LUT_TEXEL_WIDTH-LUT_TEXEL_HEIGHT*0.5);vec2 uv0=vec2(rgb.r,slice0*LUT_TEXEL_WIDTH+yOffset);vec2 uv1=vec2(rgb.r,slice1*LUT_TEXEL_WIDTH+yOffset);\n#endif\nvec4 sample0=texture2D(lut,uv0);vec4 sample1=texture2D(lut,uv1);return mix(sample0,sample1,abs(centeredInterp));}\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 c=inputColor.rgb;\n#ifdef CUSTOM_INPUT_DOMAIN\nif(c.r>=domainMin.r&&c.g>=domainMin.g&&c.b>=domainMin.b&&c.r<=domainMax.r&&c.g<=domainMax.g&&c.b<=domainMax.b){c=applyLUT(scale*c+offset).rgb;}else{c=inputColor.rgb;}\n#else\n#if !defined(LUT_3D) || defined(TETRAHEDRAL_INTERPOLATION)\nc=clamp(c,0.0,1.0);\n#endif\nc=applyLUT(scale*c+offset).rgb;\n#endif\noutputColor=vec4(c,inputColor.a);}";
var LUT3DEffect = class extends Effect {
  constructor(lut, {
    blendFunction = BlendFunction.SRC,
    tetrahedralInterpolation = false,
    inputEncoding = sRGBEncoding
  } = {}) {
    super("LUT3DEffect", lut_3d_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["lut", new Uniform(null)],
        ["scale", new Uniform(new Vector3())],
        ["offset", new Uniform(new Vector3())],
        ["domainMin", new Uniform(null)],
        ["domainMax", new Uniform(null)]
      ])
    });
    this.tetrahedralInterpolation = tetrahedralInterpolation;
    this.inputColorSpace = inputEncoding;
    this.lut = lut;
  }
  get inputEncoding() {
    return this.inputColorSpace;
  }
  set inputEncoding(value) {
    this.inputColorSpace = value;
  }
  getInputEncoding() {
    return this.inputColorSpace;
  }
  setInputEncoding(value) {
    this.inputColorSpace = value;
  }
  getOutputEncoding() {
    return this.outputColorSpace;
  }
  get lut() {
    return this.uniforms.get("lut").value;
  }
  set lut(value) {
    const defines = this.defines;
    const uniforms = this.uniforms;
    if (this.lut !== value) {
      uniforms.get("lut").value = value;
      if (value !== null) {
        const image = value.image;
        const tetrahedralInterpolation = this.tetrahedralInterpolation;
        defines.clear();
        defines.set("LUT_SIZE", Math.min(image.width, image.height).toFixed(16));
        defines.set("LUT_TEXEL_WIDTH", (1 / image.width).toFixed(16));
        defines.set("LUT_TEXEL_HEIGHT", (1 / image.height).toFixed(16));
        uniforms.get("domainMin").value = null;
        uniforms.get("domainMax").value = null;
        if (value.type === FloatType || value.type === HalfFloatType) {
          defines.set("LUT_PRECISION_HIGH", "1");
        }
        if (image.width > image.height) {
          defines.set("LUT_STRIP_HORIZONTAL", "1");
        } else if (value instanceof DataTexture3D) {
          defines.set("LUT_3D", "1");
        }
        if (value instanceof LookupTexture) {
          const min2 = value.domainMin;
          const max2 = value.domainMax;
          if (min2.x !== 0 || min2.y !== 0 || min2.z !== 0 || max2.x !== 1 || max2.y !== 1 || max2.z !== 1) {
            defines.set("CUSTOM_INPUT_DOMAIN", "1");
            uniforms.get("domainMin").value = min2.clone();
            uniforms.get("domainMax").value = max2.clone();
          }
        }
        this.tetrahedralInterpolation = tetrahedralInterpolation;
      }
    }
  }
  getLUT() {
    return this.lut;
  }
  setLUT(value) {
    this.lut = value;
  }
  updateScaleOffset() {
    const lut = this.lut;
    if (lut !== null) {
      const size2 = Math.min(lut.image.width, lut.image.height);
      const scale = this.uniforms.get("scale").value;
      const offset = this.uniforms.get("offset").value;
      if (this.tetrahedralInterpolation && lut instanceof DataTexture3D) {
        if (this.defines.has("CUSTOM_INPUT_DOMAIN")) {
          const domainScale = lut.domainMax.clone().sub(lut.domainMin);
          scale.setScalar(size2 - 1).divide(domainScale);
          offset.copy(lut.domainMin).negate().multiply(scale);
        } else {
          scale.setScalar(size2 - 1);
          offset.setScalar(0);
        }
      } else {
        if (this.defines.has("CUSTOM_INPUT_DOMAIN")) {
          const domainScale = lut.domainMax.clone().sub(lut.domainMin).multiplyScalar(size2);
          scale.setScalar(size2 - 1).divide(domainScale);
          offset.copy(lut.domainMin).negate().multiply(scale).addScalar(1 / (2 * size2));
        } else {
          scale.setScalar((size2 - 1) / size2);
          offset.setScalar(1 / (2 * size2));
        }
      }
    }
  }
  configureTetrahedralInterpolation() {
    const lut = this.lut;
    if (lut !== null) {
      lut.minFilter = LinearFilter;
      lut.magFilter = LinearFilter;
      if (this.tetrahedralInterpolation) {
        if (lut instanceof DataTexture3D) {
          lut.minFilter = NearestFilter;
          lut.magFilter = NearestFilter;
        } else {
          console.warn("Tetrahedral interpolation requires a 3D texture");
        }
      }
      if (lut.source === void 0) {
        lut.needsUpdate = true;
      }
    }
  }
  get tetrahedralInterpolation() {
    return this.defines.has("TETRAHEDRAL_INTERPOLATION");
  }
  set tetrahedralInterpolation(value) {
    if (value) {
      this.defines.set("TETRAHEDRAL_INTERPOLATION", "1");
    } else {
      this.defines.delete("TETRAHEDRAL_INTERPOLATION");
    }
    this.configureTetrahedralInterpolation();
    this.updateScaleOffset();
    this.setChanged();
  }
  setTetrahedralInterpolationEnabled(value) {
    this.tetrahedralInterpolation = value;
  }
};
var noise_default = "void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*time));\n#ifdef PREMULTIPLY\noutputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);\n#else\noutputColor=vec4(noise,inputColor.a);\n#endif\n}";
var NoiseEffect = class extends Effect {
  constructor({ blendFunction = BlendFunction.SCREEN, premultiply = false } = {}) {
    super("NoiseEffect", noise_default, { blendFunction });
    this.premultiply = premultiply;
  }
  get premultiply() {
    return this.defines.has("PREMULTIPLY");
  }
  set premultiply(value) {
    if (this.premultiply !== value) {
      if (value) {
        this.defines.set("PREMULTIPLY", "1");
      } else {
        this.defines.delete("PREMULTIPLY");
      }
      this.setChanged();
    }
  }
  isPremultiplied() {
    return this.premultiply;
  }
  setPremultiplied(value) {
    this.premultiply = value;
  }
};
var outline_default3 = "uniform lowp sampler2D edgeTexture;uniform lowp sampler2D maskTexture;uniform vec3 visibleEdgeColor;uniform vec3 hiddenEdgeColor;uniform float pulse;uniform float edgeStrength;\n#ifdef USE_PATTERN\nuniform lowp sampler2D patternTexture;varying vec2 vUvPattern;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 edge=texture2D(edgeTexture,uv).rg;vec2 mask=texture2D(maskTexture,uv).rg;\n#ifndef X_RAY\nedge.y=0.0;\n#endif\nedge*=(edgeStrength*mask.x*pulse);vec3 color=edge.x*visibleEdgeColor+edge.y*hiddenEdgeColor;float visibilityFactor=0.0;\n#ifdef USE_PATTERN\nvec4 patternColor=texelToLinear(texture2D(patternTexture,vUvPattern));\n#ifdef X_RAY\nfloat hiddenFactor=0.5;\n#else\nfloat hiddenFactor=0.0;\n#endif\nvisibilityFactor=(1.0-mask.y>0.0)?1.0:hiddenFactor;visibilityFactor*=(1.0-mask.x)*patternColor.a;color+=visibilityFactor*patternColor.rgb;\n#endif\nfloat alpha=max(max(edge.x,edge.y),visibilityFactor);\n#ifdef ALPHA\noutputColor=vec4(color,alpha);\n#else\noutputColor=vec4(color,max(alpha,inputColor.a));\n#endif\n}";
var outline_default4 = "uniform float patternScale;varying vec2 vUvPattern;void mainSupport(const in vec2 uv){vUvPattern=uv*vec2(aspect,1.0)*patternScale;}";
var OutlineEffect = class extends Effect {
  constructor(scene, camera, {
    blendFunction = BlendFunction.SCREEN,
    patternTexture = null,
    patternScale = 1,
    edgeStrength = 1,
    pulseSpeed = 0,
    visibleEdgeColor = 16777215,
    hiddenEdgeColor = 2230538,
    kernelSize = KernelSize.VERY_SMALL,
    blur = false,
    xRay = true,
    multisampling = 0,
    resolutionScale = 0.5,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("OutlineEffect", outline_default3, {
      uniforms: /* @__PURE__ */ new Map([
        ["maskTexture", new Uniform(null)],
        ["edgeTexture", new Uniform(null)],
        ["edgeStrength", new Uniform(edgeStrength)],
        ["visibleEdgeColor", new Uniform(new Color(visibleEdgeColor))],
        ["hiddenEdgeColor", new Uniform(new Color(hiddenEdgeColor))],
        ["pulse", new Uniform(1)],
        ["patternScale", new Uniform(patternScale)],
        ["patternTexture", new Uniform(null)]
      ])
    });
    this.blendMode.addEventListener("change", (event) => {
      if (this.blendMode.getBlendFunction() === BlendFunction.ALPHA) {
        this.defines.set("ALPHA", "1");
      } else {
        this.defines.delete("ALPHA");
      }
      this.setChanged();
    });
    this.blendMode.setBlendFunction(blendFunction);
    this.patternTexture = patternTexture;
    this.xRay = xRay;
    this.scene = scene;
    this.camera = camera;
    this.renderTargetMask = new WebGLRenderTarget(1, 1);
    this.renderTargetMask.samples = multisampling;
    this.renderTargetMask.texture.name = "Outline.Mask";
    this.uniforms.get("maskTexture").value = this.renderTargetMask.texture;
    this.renderTargetOutline = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTargetOutline.texture.name = "Outline.Edges";
    this.uniforms.get("edgeTexture").value = this.renderTargetOutline.texture;
    this.clearPass = new ClearPass();
    this.clearPass.overrideClearColor = new Color(0);
    this.clearPass.overrideClearAlpha = 1;
    this.depthPass = new DepthPass(scene, camera);
    this.maskPass = new RenderPass(scene, camera, new DepthComparisonMaterial(this.depthPass.texture, camera));
    const clearPass = this.maskPass.clearPass;
    clearPass.overrideClearColor = new Color(16777215);
    clearPass.overrideClearAlpha = 1;
    this.blurPass = new KawaseBlurPass({ resolutionScale, resolutionX, resolutionY, kernelSize });
    this.blurPass.enabled = blur;
    const resolution = this.blurPass.resolution;
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
    this.outlinePass = new ShaderPass(new OutlineMaterial());
    const outlineMaterial = this.outlinePass.fullscreenMaterial;
    outlineMaterial.inputBuffer = this.renderTargetMask.texture;
    this.time = 0;
    this.active = false;
    this.selection = new Selection();
    this.selection.layer = 10;
    this.pulseSpeed = pulseSpeed;
  }
  set mainScene(value) {
    this.scene = value;
    this.depthPass.mainScene = value;
    this.maskPass.mainScene = value;
  }
  set mainCamera(value) {
    this.camera = value;
    this.depthPass.mainCamera = value;
    this.maskPass.mainCamera = value;
    this.maskPass.overrideMaterial.copyCameraSettings(value);
  }
  get resolution() {
    return this.blurPass.resolution;
  }
  getResolution() {
    return this.blurPass.getResolution();
  }
  get multisampling() {
    return this.renderTargetMask.samples;
  }
  set multisampling(value) {
    this.renderTargetMask.samples = value;
    this.renderTargetMask.dispose();
  }
  get patternScale() {
    return this.uniforms.get("patternScale").value;
  }
  set patternScale(value) {
    this.uniforms.get("patternScale").value = value;
  }
  get edgeStrength() {
    return this.uniforms.get("edgeStrength").value;
  }
  set edgeStrength(value) {
    this.uniforms.get("edgeStrength").value = value;
  }
  get visibleEdgeColor() {
    return this.uniforms.get("visibleEdgeColor").value;
  }
  set visibleEdgeColor(value) {
    this.uniforms.get("visibleEdgeColor").value = value;
  }
  get hiddenEdgeColor() {
    return this.uniforms.get("hiddenEdgeColor").value;
  }
  set hiddenEdgeColor(value) {
    this.uniforms.get("hiddenEdgeColor").value = value;
  }
  getBlurPass() {
    return this.blurPass;
  }
  getSelection() {
    return this.selection;
  }
  getPulseSpeed() {
    return this.pulseSpeed;
  }
  setPulseSpeed(value) {
    this.pulseSpeed = value;
  }
  get width() {
    return this.resolution.width;
  }
  set width(value) {
    this.resolution.preferredWidth = value;
  }
  get height() {
    return this.resolution.height;
  }
  set height(value) {
    this.resolution.preferredHeight = value;
  }
  get selectionLayer() {
    return this.selection.layer;
  }
  set selectionLayer(value) {
    this.selection.layer = value;
  }
  get dithering() {
    return this.blurPass.dithering;
  }
  set dithering(value) {
    this.blurPass.dithering = value;
  }
  get kernelSize() {
    return this.blurPass.kernelSize;
  }
  set kernelSize(value) {
    this.blurPass.kernelSize = value;
  }
  get blur() {
    return this.blurPass.enabled;
  }
  set blur(value) {
    this.blurPass.enabled = value;
  }
  get xRay() {
    return this.defines.has("X_RAY");
  }
  set xRay(value) {
    if (this.xRay !== value) {
      if (value) {
        this.defines.set("X_RAY", "1");
      } else {
        this.defines.delete("X_RAY");
      }
      this.setChanged();
    }
  }
  isXRayEnabled() {
    return this.xRay;
  }
  setXRayEnabled(value) {
    this.xRay = value;
  }
  get patternTexture() {
    return this.uniforms.get("patternTexture").value;
  }
  set patternTexture(value) {
    if (value !== null) {
      value.wrapS = value.wrapT = RepeatWrapping;
      this.defines.set("USE_PATTERN", "1");
      this.setVertexShader(outline_default4);
    } else {
      this.defines.delete("USE_PATTERN");
      this.setVertexShader(null);
    }
    if (this.renderer !== null) {
      const decoding = getTextureDecoding(value, this.renderer.capabilities.isWebGL2);
      this.defines.set("texelToLinear(texel)", decoding);
    }
    this.uniforms.get("patternTexture").value = value;
    this.setChanged();
  }
  setPatternTexture(value) {
    this.patternTexture = value;
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  setSelection(objects) {
    this.selection.set(objects);
    return this;
  }
  clearSelection() {
    this.selection.clear();
    return this;
  }
  selectObject(object) {
    this.selection.add(object);
    return this;
  }
  deselectObject(object) {
    this.selection.delete(object);
    return this;
  }
  update(renderer, inputBuffer, deltaTime) {
    const scene = this.scene;
    const camera = this.camera;
    const selection = this.selection;
    const uniforms = this.uniforms;
    const pulse = uniforms.get("pulse");
    const background = scene.background;
    const mask = camera.layers.mask;
    if (selection.size > 0) {
      scene.background = null;
      pulse.value = 1;
      if (this.pulseSpeed > 0) {
        pulse.value = Math.cos(this.time * this.pulseSpeed * 10) * 0.375 + 0.625;
      }
      this.active = true;
      this.time += deltaTime;
      selection.setVisible(false);
      this.depthPass.render(renderer);
      selection.setVisible(true);
      camera.layers.set(selection.layer);
      this.maskPass.render(renderer, this.renderTargetMask);
      camera.layers.mask = mask;
      scene.background = background;
      this.outlinePass.render(renderer, null, this.renderTargetOutline);
      if (this.blurPass.enabled) {
        this.blurPass.render(renderer, this.renderTargetOutline, this.renderTargetOutline);
      }
    } else if (this.active) {
      this.clearPass.render(renderer, this.renderTargetOutline);
      this.active = false;
    }
  }
  setSize(width, height) {
    this.blurPass.setSize(width, height);
    this.renderTargetMask.setSize(width, height);
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    const w = resolution.width, h = resolution.height;
    this.depthPass.setSize(w, h);
    this.renderTargetOutline.setSize(w, h);
    this.outlinePass.fullscreenMaterial.setSize(w, h);
  }
  initialize(renderer, alpha, frameBufferType) {
    const texture2 = this.patternTexture;
    const decoding = getTextureDecoding(texture2, renderer.capabilities.isWebGL2);
    this.defines.set("texelToLinear(texel)", decoding);
    this.blurPass.initialize(renderer, alpha, UnsignedByteType);
    if (frameBufferType !== void 0) {
      this.depthPass.initialize(renderer, alpha, frameBufferType);
      this.maskPass.initialize(renderer, alpha, frameBufferType);
      this.outlinePass.initialize(renderer, alpha, frameBufferType);
    }
  }
};
var pixelation_default = "uniform bool active;uniform vec4 d;void mainUv(inout vec2 uv){if(active){uv=d.xy*(floor(uv*d.zw)+0.5);}}";
var PixelationEffect = class extends Effect {
  constructor(granularity = 30) {
    super("PixelationEffect", pixelation_default, {
      uniforms: /* @__PURE__ */ new Map([
        ["active", new Uniform(false)],
        ["d", new Uniform(new Vector4())]
      ])
    });
    this.resolution = new Vector2();
    this._granularity = 0;
    this.granularity = granularity;
  }
  get granularity() {
    return this._granularity;
  }
  set granularity(value) {
    let d = Math.floor(value);
    if (d % 2 > 0) {
      d += 1;
    }
    this._granularity = d;
    this.uniforms.get("active").value = d > 0;
    this.setSize(this.resolution.width, this.resolution.height);
  }
  getGranularity() {
    return this.granularity;
  }
  setGranularity(value) {
    this.granularity = value;
  }
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.set(width, height);
    const d = this.granularity;
    const x = d / resolution.x;
    const y = d / resolution.y;
    this.uniforms.get("d").value.set(x, y, 1 / x, 1 / y);
  }
};
var scanlines_default = "uniform float count;\n#ifdef SCROLL\nuniform float scrollSpeed;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float y=uv.y;\n#ifdef SCROLL\ny+=time*scrollSpeed;\n#endif\nvec2 sl=vec2(sin(y*count),cos(y*count));outputColor=vec4(sl.xyx,inputColor.a);}";
var ScanlineEffect = class extends Effect {
  constructor({ blendFunction = BlendFunction.OVERLAY, density = 1.25, scrollSpeed = 0 } = {}) {
    super("ScanlineEffect", scanlines_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["count", new Uniform(0)],
        ["scrollSpeed", new Uniform(0)]
      ])
    });
    this.resolution = new Vector2();
    this.d = density;
    this.scrollSpeed = scrollSpeed;
  }
  get density() {
    return this.d;
  }
  set density(value) {
    this.d = value;
    this.setSize(this.resolution.width, this.resolution.height);
  }
  getDensity() {
    return this.density;
  }
  setDensity(value) {
    this.density = value;
  }
  get scrollSpeed() {
    return this.uniforms.get("scrollSpeed").value;
  }
  set scrollSpeed(value) {
    this.uniforms.get("scrollSpeed").value = value;
    if (value === 0) {
      if (this.defines.delete("SCROLL")) {
        this.setChanged();
      }
    } else if (!this.defines.has("SCROLL")) {
      this.defines.set("SCROLL", "1");
      this.setChanged();
    }
  }
  setSize(width, height) {
    this.resolution.set(width, height);
    this.uniforms.get("count").value = Math.round(height * this.density);
  }
};
var shock_wave_default = "uniform bool active;uniform vec2 center;uniform float waveSize;uniform float radius;uniform float maxRadius;uniform float amplitude;varying float vSize;void mainUv(inout vec2 uv){if(active){vec2 aspectCorrection=vec2(aspect,1.0);vec2 difference=uv*aspectCorrection-center*aspectCorrection;float distance=sqrt(dot(difference,difference))*vSize;if(distance>radius){if(distance<radius+waveSize){float angle=(distance-radius)*PI2/waveSize;float cosSin=(1.0-cos(angle))*0.5;float extent=maxRadius+waveSize;float decay=max(extent-distance*distance,0.0)/extent;uv-=((cosSin*amplitude*difference)/distance)*decay;}}}}";
var shock_wave_default2 = "uniform float size;uniform float cameraDistance;varying float vSize;void mainSupport(){vSize=(0.1*cameraDistance)/size;}";
var HALF_PI = Math.PI * 0.5;
var v2 = new Vector3();
var ab = new Vector3();
var ShockWaveEffect = class extends Effect {
  constructor(camera, position = new Vector3(), {
    speed = 2,
    maxRadius = 1,
    waveSize = 0.2,
    amplitude = 0.05
  } = {}) {
    super("ShockWaveEffect", shock_wave_default, {
      vertexShader: shock_wave_default2,
      uniforms: /* @__PURE__ */ new Map([
        ["active", new Uniform(false)],
        ["center", new Uniform(new Vector2(0.5, 0.5))],
        ["cameraDistance", new Uniform(1)],
        ["size", new Uniform(1)],
        ["radius", new Uniform(-waveSize)],
        ["maxRadius", new Uniform(maxRadius)],
        ["waveSize", new Uniform(waveSize)],
        ["amplitude", new Uniform(amplitude)]
      ])
    });
    this.position = position;
    this.speed = speed;
    this.camera = camera;
    this.screenPosition = this.uniforms.get("center").value;
    this.time = 0;
    this.active = false;
  }
  set mainCamera(value) {
    this.camera = value;
  }
  get amplitude() {
    return this.uniforms.get("amplitude").value;
  }
  set amplitude(value) {
    this.uniforms.get("amplitude").value = value;
  }
  get waveSize() {
    return this.uniforms.get("waveSize").value;
  }
  set waveSize(value) {
    this.uniforms.get("waveSize").value = value;
  }
  get maxRadius() {
    return this.uniforms.get("maxRadius").value;
  }
  set maxRadius(value) {
    this.uniforms.get("maxRadius").value = value;
  }
  get epicenter() {
    return this.position;
  }
  set epicenter(value) {
    this.position = value;
  }
  getPosition() {
    return this.position;
  }
  setPosition(value) {
    this.position = value;
  }
  getSpeed() {
    return this.speed;
  }
  setSpeed(value) {
    this.speed = value;
  }
  explode() {
    this.time = 0;
    this.active = true;
    this.uniforms.get("active").value = true;
  }
  update(renderer, inputBuffer, delta) {
    const position = this.position;
    const camera = this.camera;
    const uniforms = this.uniforms;
    const uActive = uniforms.get("active");
    if (this.active) {
      const waveSize = uniforms.get("waveSize").value;
      camera.getWorldDirection(v2);
      ab.copy(camera.position).sub(position);
      uActive.value = v2.angleTo(ab) > HALF_PI;
      if (uActive.value) {
        uniforms.get("cameraDistance").value = camera.position.distanceTo(position);
        v2.copy(position).project(camera);
        this.screenPosition.set((v2.x + 1) * 0.5, (v2.y + 1) * 0.5);
      }
      this.time += delta * this.speed;
      const radius = this.time - waveSize;
      uniforms.get("radius").value = radius;
      if (radius >= (uniforms.get("maxRadius").value + waveSize) * 2) {
        this.active = false;
        uActive.value = false;
      }
    }
  }
};
var SelectiveBloomEffect = class extends BloomEffect {
  constructor(scene, camera, options) {
    super(options);
    this.setAttributes(this.getAttributes() | EffectAttribute.DEPTH);
    this.camera = camera;
    this.depthPass = new DepthPass(scene, camera);
    this.clearPass = new ClearPass(true, false, false);
    this.clearPass.overrideClearColor = new Color(0);
    this.depthMaskPass = new ShaderPass(new DepthMaskMaterial());
    const depthMaskMaterial = this.depthMaskMaterial;
    depthMaskMaterial.copyCameraSettings(camera);
    depthMaskMaterial.depthBuffer1 = this.depthPass.texture;
    depthMaskMaterial.depthPacking1 = RGBADepthPacking;
    depthMaskMaterial.depthMode = EqualDepth;
    this.renderTargetMasked = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTargetMasked.texture.name = "Bloom.Masked";
    this.selection = new Selection();
    this.selection.layer = 11;
    this._inverted = false;
    this._ignoreBackground = false;
  }
  set mainScene(value) {
    this.depthPass.mainScene = value;
  }
  set mainCamera(value) {
    this.camera = value;
    this.depthPass.mainCamera = value;
    this.depthMaskMaterial.copyCameraSettings(value);
  }
  getSelection() {
    return this.selection;
  }
  get depthMaskMaterial() {
    return this.depthMaskPass.fullscreenMaterial;
  }
  get inverted() {
    return this._inverted;
  }
  set inverted(value) {
    this._inverted = value;
    this.depthMaskMaterial.depthMode = value ? NotEqualDepth : EqualDepth;
  }
  isInverted() {
    return this.inverted;
  }
  setInverted(value) {
    this.inverted = value;
  }
  get ignoreBackground() {
    return this._ignoreBackground;
  }
  set ignoreBackground(value) {
    this._ignoreBackground = value;
    this.depthMaskMaterial.maxDepthStrategy = value ? DepthTestStrategy.DISCARD_MAX_DEPTH : DepthTestStrategy.KEEP_MAX_DEPTH;
  }
  isBackgroundDisabled() {
    return this.ignoreBackground;
  }
  setBackgroundDisabled(value) {
    this.ignoreBackground = value;
  }
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    this.depthMaskMaterial.depthBuffer0 = depthTexture;
    this.depthMaskMaterial.depthPacking0 = depthPacking;
  }
  update(renderer, inputBuffer, deltaTime) {
    const camera = this.camera;
    const selection = this.selection;
    const inverted = this.inverted;
    let renderTarget = inputBuffer;
    if (this.ignoreBackground || !inverted || selection.size > 0) {
      const mask = camera.layers.mask;
      camera.layers.set(selection.layer);
      this.depthPass.render(renderer);
      camera.layers.mask = mask;
      renderTarget = this.renderTargetMasked;
      this.clearPass.render(renderer, renderTarget);
      this.depthMaskPass.render(renderer, inputBuffer, renderTarget);
    }
    super.update(renderer, renderTarget, deltaTime);
  }
  setSize(width, height) {
    super.setSize(width, height);
    this.renderTargetMasked.setSize(width, height);
    this.depthPass.setSize(width, height);
  }
  initialize(renderer, alpha, frameBufferType) {
    super.initialize(renderer, alpha, frameBufferType);
    this.clearPass.initialize(renderer, alpha, frameBufferType);
    this.depthPass.initialize(renderer, alpha, frameBufferType);
    this.depthMaskPass.initialize(renderer, alpha, frameBufferType);
    if (frameBufferType !== void 0) {
      this.renderTargetMasked.texture.type = frameBufferType;
      if (renderer.outputEncoding === sRGBEncoding) {
        this.renderTargetMasked.texture.encoding = sRGBEncoding;
      }
    }
  }
};
var sepia_default = "uniform vec3 weightsR;uniform vec3 weightsG;uniform vec3 weightsB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,weightsR),dot(inputColor.rgb,weightsG),dot(inputColor.rgb,weightsB));outputColor=vec4(color,inputColor.a);}";
var SepiaEffect = class extends Effect {
  constructor({ blendFunction, intensity = 1 } = {}) {
    super("SepiaEffect", sepia_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["weightsR", new Uniform(new Vector3(0.393, 0.769, 0.189))],
        ["weightsG", new Uniform(new Vector3(0.349, 0.686, 0.168))],
        ["weightsB", new Uniform(new Vector3(0.272, 0.534, 0.131))]
      ])
    });
  }
  get intensity() {
    return this.blendMode.opacity.value;
  }
  set intensity(value) {
    this.blendMode.opacity.value = value;
  }
  getIntensity() {
    return this.intensity;
  }
  setIntensity(value) {
    this.intensity = value;
  }
  get weightsR() {
    return this.uniforms.get("weightsR").value;
  }
  get weightsG() {
    return this.uniforms.get("weightsG").value;
  }
  get weightsB() {
    return this.uniforms.get("weightsB").value;
  }
};
var searchImageDataURL_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC";
var areaImageDataURL_default = "data:image/png;base64,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";
var smaa_default = "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}";
var smaa_default2 = "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}";
var SMAAEffect = class extends Effect {
  constructor({
    blendFunction = BlendFunction.SRC,
    preset = SMAAPreset.MEDIUM,
    edgeDetectionMode = EdgeDetectionMode.COLOR,
    predicationMode = PredicationMode.DISABLED
  } = {}) {
    super("SMAAEffect", smaa_default, {
      vertexShader: smaa_default2,
      blendFunction,
      attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH,
      uniforms: /* @__PURE__ */ new Map([
        ["weightMap", new Uniform(null)]
      ])
    });
    let searchImage, areaImage;
    if (arguments.length > 1) {
      searchImage = arguments[0];
      areaImage = arguments[1];
      if (arguments.length > 2) {
        preset = arguments[2];
      }
      if (arguments.length > 3) {
        edgeDetectionMode = arguments[3];
      }
    }
    this.renderTargetEdges = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTargetEdges.texture.name = "SMAA.Edges";
    this.renderTargetWeights = this.renderTargetEdges.clone();
    this.renderTargetWeights.texture.name = "SMAA.Weights";
    this.uniforms.get("weightMap").value = this.renderTargetWeights.texture;
    this.clearPass = new ClearPass(true, false, false);
    this.clearPass.overrideClearColor = new Color(0);
    this.clearPass.overrideClearAlpha = 1;
    this.edgeDetectionPass = new ShaderPass(new EdgeDetectionMaterial());
    this.edgeDetectionMaterial.edgeDetectionMode = edgeDetectionMode;
    this.edgeDetectionMaterial.predicationMode = predicationMode;
    this.weightsPass = new ShaderPass(new SMAAWeightsMaterial());
    const loadingManager = new LoadingManager();
    loadingManager.onLoad = () => {
      const searchTexture = new Texture(searchImage);
      searchTexture.name = "SMAA.Search";
      searchTexture.magFilter = NearestFilter;
      searchTexture.minFilter = NearestFilter;
      searchTexture.generateMipmaps = false;
      searchTexture.needsUpdate = true;
      searchTexture.flipY = true;
      this.weightsMaterial.searchTexture = searchTexture;
      const areaTexture = new Texture(areaImage);
      areaTexture.name = "SMAA.Area";
      areaTexture.magFilter = LinearFilter;
      areaTexture.minFilter = LinearFilter;
      areaTexture.generateMipmaps = false;
      areaTexture.needsUpdate = true;
      areaTexture.flipY = false;
      this.weightsMaterial.areaTexture = areaTexture;
      this.dispatchEvent({ type: "load" });
    };
    loadingManager.itemStart("search");
    loadingManager.itemStart("area");
    if (searchImage !== void 0 && areaImage !== void 0) {
      loadingManager.itemEnd("search");
      loadingManager.itemEnd("area");
    } else if (typeof Image !== "undefined") {
      searchImage = new Image();
      areaImage = new Image();
      searchImage.addEventListener("load", () => loadingManager.itemEnd("search"));
      areaImage.addEventListener("load", () => loadingManager.itemEnd("area"));
      searchImage.src = searchImageDataURL_default;
      areaImage.src = areaImageDataURL_default;
    }
    this.applyPreset(preset);
  }
  get edgesTexture() {
    return this.renderTargetEdges.texture;
  }
  getEdgesTexture() {
    return this.edgesTexture;
  }
  get weightsTexture() {
    return this.renderTargetWeights.texture;
  }
  getWeightsTexture() {
    return this.weightsTexture;
  }
  get edgeDetectionMaterial() {
    return this.edgeDetectionPass.fullscreenMaterial;
  }
  get colorEdgesMaterial() {
    return this.edgeDetectionMaterial;
  }
  getEdgeDetectionMaterial() {
    return this.edgeDetectionMaterial;
  }
  get weightsMaterial() {
    return this.weightsPass.fullscreenMaterial;
  }
  getWeightsMaterial() {
    return this.weightsMaterial;
  }
  setEdgeDetectionThreshold(threshold) {
    this.edgeDetectionMaterial.edgeDetectionThreshold = threshold;
  }
  setOrthogonalSearchSteps(steps) {
    this.weightsMaterial.orthogonalSearchSteps = steps;
  }
  applyPreset(preset) {
    const edgeDetectionMaterial = this.edgeDetectionMaterial;
    const weightsMaterial = this.weightsMaterial;
    switch (preset) {
      case SMAAPreset.LOW:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.15;
        weightsMaterial.orthogonalSearchSteps = 4;
        weightsMaterial.diagonalDetection = false;
        weightsMaterial.cornerDetection = false;
        break;
      case SMAAPreset.MEDIUM:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.1;
        weightsMaterial.orthogonalSearchSteps = 8;
        weightsMaterial.diagonalDetection = false;
        weightsMaterial.cornerDetection = false;
        break;
      case SMAAPreset.HIGH:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.1;
        weightsMaterial.orthogonalSearchSteps = 16;
        weightsMaterial.diagonalSearchSteps = 8;
        weightsMaterial.cornerRounding = 25;
        weightsMaterial.diagonalDetection = true;
        weightsMaterial.cornerDetection = true;
        break;
      case SMAAPreset.ULTRA:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.05;
        weightsMaterial.orthogonalSearchSteps = 32;
        weightsMaterial.diagonalSearchSteps = 16;
        weightsMaterial.cornerRounding = 25;
        weightsMaterial.diagonalDetection = true;
        weightsMaterial.cornerDetection = true;
        break;
    }
  }
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    this.edgeDetectionMaterial.depthBuffer = depthTexture;
    this.edgeDetectionMaterial.depthPacking = depthPacking;
  }
  update(renderer, inputBuffer, deltaTime) {
    this.clearPass.render(renderer, this.renderTargetEdges);
    this.edgeDetectionPass.render(renderer, inputBuffer, this.renderTargetEdges);
    this.weightsPass.render(renderer, this.renderTargetEdges, this.renderTargetWeights);
  }
  setSize(width, height) {
    this.edgeDetectionMaterial.setSize(width, height);
    this.weightsMaterial.setSize(width, height);
    this.renderTargetEdges.setSize(width, height);
    this.renderTargetWeights.setSize(width, height);
  }
  dispose() {
    const { searchTexture, areaTexture } = this.weightsMaterial;
    if (searchTexture !== null && areaTexture !== null) {
      searchTexture.dispose();
      areaTexture.dispose();
    }
    super.dispose();
  }
  static get searchImageDataURL() {
    return searchImageDataURL_default;
  }
  static get areaImageDataURL() {
    return areaImageDataURL_default;
  }
};
var ssao_default3 = "uniform lowp sampler2D aoBuffer;uniform float luminanceInfluence;uniform float intensity;\n#if THREE_REVISION < 143\n#define luminance(v) linearToRelativeLuminance(v)\n#endif\n#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH)\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\n#endif\n#ifdef COLORIZE\nuniform vec3 color;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){float aoLinear=texture2D(aoBuffer,uv).r;\n#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH) && __VERSION__ == 300\nvec4 normalDepth[4];normalDepth[0]=textureOffset(normalDepthBuffer,uv,ivec2(0,0));normalDepth[1]=textureOffset(normalDepthBuffer,uv,ivec2(0,1));normalDepth[2]=textureOffset(normalDepthBuffer,uv,ivec2(1,0));normalDepth[3]=textureOffset(normalDepthBuffer,uv,ivec2(1,1));float dot01=dot(normalDepth[0].rgb,normalDepth[1].rgb);float dot02=dot(normalDepth[0].rgb,normalDepth[2].rgb);float dot03=dot(normalDepth[0].rgb,normalDepth[3].rgb);float minDot=min(dot01,min(dot02,dot03));float s=step(THRESHOLD,minDot);float smallestDistance=1.0;int index;for(int i=0;i<4;++i){float distance=abs(depth-normalDepth[i].a);if(distance<smallestDistance){smallestDistance=distance;index=i;}}ivec2 offsets[4];offsets[0]=ivec2(0,0);offsets[1]=ivec2(0,1);offsets[2]=ivec2(1,0);offsets[3]=ivec2(1,1);ivec2 coord=ivec2(uv*vec2(textureSize(aoBuffer,0)))+offsets[index];float aoNearest=texelFetch(aoBuffer,coord,0).r;float ao=mix(aoNearest,aoLinear,s);\n#else\nfloat ao=aoLinear;\n#endif\nfloat l=luminance(inputColor.rgb);ao=mix(ao,0.0,l*luminanceInfluence);ao=clamp(ao*intensity,0.0,1.0);\n#ifdef COLORIZE\noutputColor=vec4(1.0-ao*(1.0-color),inputColor.a);\n#else\noutputColor=vec4(vec3(1.0-ao),inputColor.a);\n#endif\n}";
var NOISE_TEXTURE_SIZE = 64;
var SSAOEffect = class extends Effect {
  constructor(camera, normalBuffer, {
    blendFunction = BlendFunction.MULTIPLY,
    samples = 9,
    rings = 7,
    normalDepthBuffer = null,
    depthAwareUpsampling = true,
    worldDistanceThreshold,
    worldDistanceFalloff,
    worldProximityThreshold,
    worldProximityFalloff,
    distanceThreshold = 0.97,
    distanceFalloff = 0.03,
    rangeThreshold = 5e-4,
    rangeFalloff = 1e-3,
    minRadiusScale = 0.1,
    luminanceInfluence = 0.7,
    radius = 0.1825,
    intensity = 1,
    bias = 0.025,
    fade = 0.01,
    color: color22 = null,
    resolutionScale = 1,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("SSAOEffect", ssao_default3, {
      blendFunction,
      attributes: EffectAttribute.DEPTH,
      defines: /* @__PURE__ */ new Map([
        ["THRESHOLD", "0.997"]
      ]),
      uniforms: /* @__PURE__ */ new Map([
        ["aoBuffer", new Uniform(null)],
        ["normalDepthBuffer", new Uniform(normalDepthBuffer)],
        ["luminanceInfluence", new Uniform(luminanceInfluence)],
        ["color", new Uniform(null)],
        ["intensity", new Uniform(intensity)],
        ["scale", new Uniform(0)]
      ])
    });
    this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTarget.texture.name = "AO.Target";
    this.uniforms.get("aoBuffer").value = this.renderTarget.texture;
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
    this.camera = camera;
    this.depthDownsamplingPass = new DepthDownsamplingPass({ normalBuffer, resolutionScale });
    this.depthDownsamplingPass.enabled = normalDepthBuffer === null;
    this.ssaoPass = new ShaderPass(new SSAOMaterial(camera));
    const noiseTexture = new NoiseTexture(NOISE_TEXTURE_SIZE, NOISE_TEXTURE_SIZE, RGBAFormat);
    noiseTexture.wrapS = noiseTexture.wrapT = RepeatWrapping;
    const ssaoMaterial = this.ssaoMaterial;
    ssaoMaterial.normalBuffer = normalBuffer;
    ssaoMaterial.noiseTexture = noiseTexture;
    ssaoMaterial.minRadiusScale = minRadiusScale;
    ssaoMaterial.samples = samples;
    ssaoMaterial.radius = radius;
    ssaoMaterial.rings = rings;
    ssaoMaterial.fade = fade;
    ssaoMaterial.bias = bias;
    ssaoMaterial.distanceThreshold = distanceThreshold;
    ssaoMaterial.distanceFalloff = distanceFalloff;
    ssaoMaterial.proximityThreshold = rangeThreshold;
    ssaoMaterial.proximityFalloff = rangeFalloff;
    if (worldDistanceThreshold !== void 0) {
      ssaoMaterial.worldDistanceThreshold = worldDistanceThreshold;
    }
    if (worldDistanceFalloff !== void 0) {
      ssaoMaterial.worldDistanceFalloff = worldDistanceFalloff;
    }
    if (worldProximityThreshold !== void 0) {
      ssaoMaterial.worldProximityThreshold = worldProximityThreshold;
    }
    if (worldProximityFalloff !== void 0) {
      ssaoMaterial.worldProximityFalloff = worldProximityFalloff;
    }
    if (normalDepthBuffer !== null) {
      this.ssaoMaterial.normalDepthBuffer = normalDepthBuffer;
      this.defines.set("NORMAL_DEPTH", "1");
    }
    this.depthAwareUpsampling = depthAwareUpsampling;
    this.color = color22;
  }
  set mainCamera(value) {
    this.camera = value;
    this.ssaoMaterial.copyCameraSettings(value);
  }
  getResolution() {
    return this.resolution;
  }
  get ssaoMaterial() {
    return this.ssaoPass.fullscreenMaterial;
  }
  getSSAOMaterial() {
    return this.ssaoMaterial;
  }
  get samples() {
    return this.ssaoMaterial.samples;
  }
  set samples(value) {
    this.ssaoMaterial.samples = value;
  }
  get rings() {
    return this.ssaoMaterial.rings;
  }
  set rings(value) {
    this.ssaoMaterial.rings = value;
  }
  get radius() {
    return this.ssaoMaterial.radius;
  }
  set radius(value) {
    this.ssaoMaterial.radius = value;
  }
  get depthAwareUpsampling() {
    return this.defines.has("DEPTH_AWARE_UPSAMPLING");
  }
  set depthAwareUpsampling(value) {
    if (this.depthAwareUpsampling !== value) {
      if (value) {
        this.defines.set("DEPTH_AWARE_UPSAMPLING", "1");
      } else {
        this.defines.delete("DEPTH_AWARE_UPSAMPLING");
      }
      this.setChanged();
    }
  }
  isDepthAwareUpsamplingEnabled() {
    return this.depthAwareUpsampling;
  }
  setDepthAwareUpsamplingEnabled(value) {
    this.depthAwareUpsampling = value;
  }
  get distanceScaling() {
    return true;
  }
  set distanceScaling(value) {
  }
  get color() {
    return this.uniforms.get("color").value;
  }
  set color(value) {
    const uniforms = this.uniforms;
    const defines = this.defines;
    if (value !== null) {
      if (defines.has("COLORIZE")) {
        uniforms.get("color").value.set(value);
      } else {
        defines.set("COLORIZE", "1");
        uniforms.get("color").value = new Color(value);
        this.setChanged();
      }
    } else if (defines.has("COLORIZE")) {
      defines.delete("COLORIZE");
      uniforms.get("color").value = null;
      this.setChanged();
    }
  }
  get luminanceInfluence() {
    return this.uniforms.get("luminanceInfluence").value;
  }
  set luminanceInfluence(value) {
    this.uniforms.get("luminanceInfluence").value = value;
  }
  get intensity() {
    return this.uniforms.get("intensity").value;
  }
  set intensity(value) {
    this.uniforms.get("intensity").value = value;
  }
  getColor() {
    return this.color;
  }
  setColor(value) {
    this.color = value;
  }
  setDistanceCutoff(threshold, falloff) {
    this.ssaoMaterial.distanceThreshold = threshold;
    this.ssaoMaterial.distanceFalloff = falloff;
  }
  setProximityCutoff(threshold, falloff) {
    this.ssaoMaterial.proximityThreshold = threshold;
    this.ssaoMaterial.proximityFalloff = falloff;
  }
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    this.depthDownsamplingPass.setDepthTexture(depthTexture, depthPacking);
    this.ssaoMaterial.depthBuffer = depthTexture;
    this.ssaoMaterial.depthPacking = depthPacking;
  }
  update(renderer, inputBuffer, deltaTime) {
    const renderTarget = this.renderTarget;
    if (this.depthDownsamplingPass.enabled) {
      this.depthDownsamplingPass.render(renderer);
    }
    this.ssaoPass.render(renderer, null, renderTarget);
  }
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    const w = resolution.width, h = resolution.height;
    this.ssaoMaterial.copyCameraSettings(this.camera);
    this.ssaoMaterial.setSize(w, h);
    this.renderTarget.setSize(w, h);
    this.depthDownsamplingPass.resolution.scale = resolution.scale;
    this.depthDownsamplingPass.setSize(width, height);
  }
  initialize(renderer, alpha, frameBufferType) {
    try {
      let normalDepthBuffer = this.uniforms.get("normalDepthBuffer").value;
      if (normalDepthBuffer === null) {
        this.depthDownsamplingPass.initialize(renderer, alpha, frameBufferType);
        normalDepthBuffer = this.depthDownsamplingPass.texture;
        this.uniforms.get("normalDepthBuffer").value = normalDepthBuffer;
        this.ssaoMaterial.normalDepthBuffer = normalDepthBuffer;
        this.defines.set("NORMAL_DEPTH", "1");
      }
    } catch (e) {
      this.depthDownsamplingPass.enabled = false;
    }
  }
};
var texture_default = "#ifdef TEXTURE_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nvarying vec2 vUv2;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){\n#ifdef UV_TRANSFORM\nvec4 texel=texelToLinear(texture2D(map,vUv2));\n#else\nvec4 texel=texelToLinear(texture2D(map,uv));\n#endif\noutputColor=TEXEL;}";
var texture_default2 = "#ifdef ASPECT_CORRECTION\nuniform float scale;\n#else\nuniform mat3 uvTransform;\n#endif\nvarying vec2 vUv2;void mainSupport(const in vec2 uv){\n#ifdef ASPECT_CORRECTION\nvUv2=uv*vec2(aspect,1.0)*scale;\n#else\nvUv2=(uvTransform*vec3(uv,1.0)).xy;\n#endif\n}";
var TextureEffect = class extends Effect {
  constructor({ blendFunction, texture: texture2 = null, aspectCorrection = false } = {}) {
    super("TextureEffect", texture_default, {
      blendFunction,
      defines: /* @__PURE__ */ new Map([
        ["TEXEL", "texel"]
      ]),
      uniforms: /* @__PURE__ */ new Map([
        ["map", new Uniform(null)],
        ["scale", new Uniform(1)],
        ["uvTransform", new Uniform(null)]
      ])
    });
    this.texture = texture2;
    this.aspectCorrection = aspectCorrection;
  }
  get texture() {
    return this.uniforms.get("map").value;
  }
  set texture(value) {
    const prevTexture = this.texture;
    const uniforms = this.uniforms;
    const defines = this.defines;
    if (prevTexture !== value) {
      uniforms.get("map").value = value;
      uniforms.get("uvTransform").value = value.matrix;
      defines.delete("TEXTURE_PRECISION_HIGH");
      if (this.renderer !== null) {
        const decoding = getTextureDecoding(value, this.renderer.capabilities.isWebGL2);
        defines.set("texelToLinear(texel)", decoding);
      }
      if (value !== null) {
        if (value.matrixAutoUpdate) {
          defines.set("UV_TRANSFORM", "1");
          this.setVertexShader(texture_default2);
        } else {
          defines.delete("UV_TRANSFORM");
          this.setVertexShader(null);
        }
        if (value.type !== UnsignedByteType) {
          defines.set("TEXTURE_PRECISION_HIGH", "1");
        }
        if (prevTexture === null || prevTexture.type !== value.type || prevTexture.encoding !== value.encoding) {
          this.setChanged();
        }
      }
    }
  }
  getTexture() {
    return this.texture;
  }
  setTexture(value) {
    this.texture = value;
  }
  get aspectCorrection() {
    return this.defines.has("ASPECT_CORRECTION");
  }
  set aspectCorrection(value) {
    if (this.aspectCorrection !== value) {
      if (value) {
        this.defines.set("ASPECT_CORRECTION", "1");
      } else {
        this.defines.delete("ASPECT_CORRECTION");
      }
      this.setChanged();
    }
  }
  get uvTransform() {
    const texture2 = this.texture;
    return texture2 !== null && texture2.matrixAutoUpdate;
  }
  set uvTransform(value) {
    const texture2 = this.texture;
    if (texture2 !== null) {
      texture2.matrixAutoUpdate = value;
    }
  }
  setTextureSwizzleRGBA(r, g = r, b2 = r, a2 = r) {
    const rgba = "rgba";
    let swizzle = "";
    if (r !== ColorChannel.RED || g !== ColorChannel.GREEN || b2 !== ColorChannel.BLUE || a2 !== ColorChannel.ALPHA) {
      swizzle = [".", rgba[r], rgba[g], rgba[b2], rgba[a2]].join("");
    }
    this.defines.set("TEXEL", "texel" + swizzle);
    this.setChanged();
  }
  update(renderer, inputBuffer, deltaTime) {
    if (this.texture.matrixAutoUpdate) {
      this.texture.updateMatrix();
    }
  }
  initialize(renderer, alpha, frameBufferType) {
    const decoding = getTextureDecoding(this.texture, renderer.capabilities.isWebGL2);
    this.defines.set("texelToLinear(texel)", decoding);
    this.renderer = renderer;
  }
};
var tilt_shift_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nuniform vec4 maskParams;varying vec2 vUv2;float linearGradientMask(const in float x){return smoothstep(maskParams.x,maskParams.y,x)-smoothstep(maskParams.w,maskParams.z,x);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float mask=linearGradientMask(vUv2.y);vec4 texel=texture2D(map,uv);outputColor=mix(texel,inputColor,mask);}";
var tilt_shift_default2 = "uniform vec2 rotation;varying vec2 vUv2;void mainSupport(const in vec2 uv){vUv2=(uv-0.5)*2.0*vec2(aspect,1.0);vUv2=vec2(dot(rotation,vUv2),dot(rotation,vec2(vUv2.y,-vUv2.x)));}";
var TiltShiftEffect = class extends Effect {
  constructor({
    blendFunction,
    offset = 0,
    rotation = 0,
    focusArea = 0.4,
    feather = 0.3,
    bias = 0.06,
    kernelSize = KernelSize.MEDIUM,
    resolutionScale = 0.5,
    resolutionX = Resolution.AUTO_SIZE,
    resolutionY = Resolution.AUTO_SIZE
  } = {}) {
    super("TiltShiftEffect", tilt_shift_default, {
      vertexShader: tilt_shift_default2,
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["rotation", new Uniform(new Vector2())],
        ["maskParams", new Uniform(new Vector4())],
        ["map", new Uniform(null)]
      ])
    });
    this._offset = offset;
    this._focusArea = focusArea;
    this._feather = feather;
    this._bias = bias;
    this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTarget.texture.name = "TiltShift.Target";
    this.uniforms.get("map").value = this.renderTarget.texture;
    this.blurPass = new TiltShiftBlurPass({
      kernelSize,
      resolutionScale,
      resolutionX,
      resolutionY,
      offset,
      rotation,
      focusArea,
      feather
    });
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
    this.rotation = rotation;
    this.updateParams();
  }
  updateParams() {
    const params = this.uniforms.get("maskParams").value;
    const a2 = Math.max(this.focusArea - this.bias, 0);
    const b2 = Math.max(a2 - Math.max(this.feather - this.bias, 0), 0);
    params.set(
      this.offset - a2,
      this.offset - b2,
      this.offset + a2,
      this.offset + b2
    );
  }
  get rotation() {
    return Math.acos(this.uniforms.get("rotation").value.x);
  }
  set rotation(value) {
    this.uniforms.get("rotation").value.set(Math.cos(value), Math.sin(value));
    this.blurPass.blurMaterial.rotation = value;
  }
  get offset() {
    return this._offset;
  }
  set offset(value) {
    this._offset = value;
    this.blurPass.blurMaterial.offset = value;
    this.updateParams();
  }
  get focusArea() {
    return this._focusArea;
  }
  set focusArea(value) {
    this._focusArea = value;
    this.blurPass.blurMaterial.focusArea = value;
    this.updateParams();
  }
  get feather() {
    return this._feather;
  }
  set feather(value) {
    this._feather = value;
    this.blurPass.blurMaterial.feather = value;
    this.updateParams();
  }
  get bias() {
    return this._bias;
  }
  set bias(value) {
    this._bias = value;
    this.updateParams();
  }
  update(renderer, inputBuffer, deltaTime) {
    this.blurPass.render(renderer, inputBuffer, this.renderTarget);
  }
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
    this.blurPass.resolution.copy(resolution);
  }
  initialize(renderer, alpha, frameBufferType) {
    this.blurPass.initialize(renderer, alpha, frameBufferType);
    if (frameBufferType !== void 0) {
      this.renderTarget.texture.type = frameBufferType;
      if (renderer.outputEncoding === sRGBEncoding) {
        this.renderTarget.texture.encoding = sRGBEncoding;
      }
    }
  }
};
var tone_mapping_default = "#include <tonemapping_pars_fragment>\n#if THREE_REVISION < 143\n#define luminance(v) linearToRelativeLuminance(v)\n#endif\nuniform lowp sampler2D luminanceBuffer;uniform float whitePoint;uniform float middleGrey;\n#if TONE_MAPPING_MODE != 2\nuniform float averageLuminance;\n#endif\nvec3 Reinhard2ToneMapping(vec3 color){color*=toneMappingExposure;float l=luminance(color);\n#if TONE_MAPPING_MODE == 2\nfloat lumAvg=unpackRGBAToFloat(texture2D(luminanceBuffer,vec2(0.5)));\n#else\nfloat lumAvg=averageLuminance;\n#endif\nfloat lumScaled=(l*middleGrey)/max(lumAvg,1e-6);float lumCompressed=lumScaled*(1.0+lumScaled/(whitePoint*whitePoint));lumCompressed/=(1.0+lumScaled);return clamp(lumCompressed*color,0.0,1.0);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){\n#if TONE_MAPPING_MODE == 1 || TONE_MAPPING_MODE == 2\noutputColor=vec4(Reinhard2ToneMapping(inputColor.rgb),inputColor.a);\n#else\noutputColor=vec4(toneMapping(inputColor.rgb),inputColor.a);\n#endif\n}";
var ToneMappingEffect = class extends Effect {
  constructor({
    blendFunction = BlendFunction.SRC,
    adaptive = true,
    mode = adaptive ? ToneMappingMode.REINHARD2_ADAPTIVE : ToneMappingMode.REINHARD2,
    resolution = 256,
    maxLuminance = 16,
    whitePoint = maxLuminance,
    middleGrey = 0.6,
    minLuminance = 0.01,
    averageLuminance = 1,
    adaptationRate = 1
  } = {}) {
    super("ToneMappingEffect", tone_mapping_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["luminanceBuffer", new Uniform(null)],
        ["maxLuminance", new Uniform(maxLuminance)],
        ["whitePoint", new Uniform(whitePoint)],
        ["middleGrey", new Uniform(middleGrey)],
        ["averageLuminance", new Uniform(averageLuminance)]
      ])
    });
    this.renderTargetLuminance = new WebGLRenderTarget(1, 1, {
      minFilter: LinearMipmapLinearFilter,
      depthBuffer: false
    });
    this.renderTargetLuminance.texture.generateMipmaps = true;
    this.renderTargetLuminance.texture.name = "Luminance";
    this.luminancePass = new LuminancePass({
      renderTarget: this.renderTargetLuminance
    });
    this.adaptiveLuminancePass = new AdaptiveLuminancePass(this.luminancePass.texture, {
      minLuminance,
      adaptationRate
    });
    this.uniforms.get("luminanceBuffer").value = this.adaptiveLuminancePass.texture;
    this.resolution = resolution;
    this.mode = mode;
  }
  get mode() {
    return Number(this.defines.get("TONE_MAPPING_MODE"));
  }
  set mode(value) {
    if (this.mode !== value) {
      this.defines.clear();
      this.defines.set("TONE_MAPPING_MODE", value.toFixed(0));
      switch (value) {
        case ToneMappingMode.REINHARD:
          this.defines.set("toneMapping(texel)", "ReinhardToneMapping(texel)");
          break;
        case ToneMappingMode.OPTIMIZED_CINEON:
          this.defines.set("toneMapping(texel)", "OptimizedCineonToneMapping(texel)");
          break;
        case ToneMappingMode.ACES_FILMIC:
          this.defines.set("toneMapping(texel)", "ACESFilmicToneMapping(texel)");
          break;
        default:
          this.defines.set("toneMapping(texel)", "texel");
          break;
      }
      this.adaptiveLuminancePass.enabled = value === ToneMappingMode.REINHARD2_ADAPTIVE;
      this.setChanged();
    }
  }
  getMode() {
    return this.mode;
  }
  setMode(value) {
    this.mode = value;
  }
  get whitePoint() {
    return this.uniforms.get("whitePoint").value;
  }
  set whitePoint(value) {
    this.uniforms.get("whitePoint").value = value;
  }
  get middleGrey() {
    return this.uniforms.get("middleGrey").value;
  }
  set middleGrey(value) {
    this.uniforms.get("middleGrey").value = value;
  }
  get averageLuminance() {
    return this.uniforms.get("averageLuminance").value;
  }
  set averageLuminance(value) {
    this.uniforms.get("averageLuminance").value = value;
  }
  get adaptiveLuminanceMaterial() {
    return this.adaptiveLuminancePass.fullscreenMaterial;
  }
  getAdaptiveLuminanceMaterial() {
    return this.adaptiveLuminanceMaterial;
  }
  get resolution() {
    return this.luminancePass.resolution.width;
  }
  set resolution(value) {
    const exponent = Math.max(0, Math.ceil(Math.log2(value)));
    const size2 = Math.pow(2, exponent);
    this.luminancePass.resolution.setPreferredSize(size2, size2);
    this.adaptiveLuminanceMaterial.mipLevel1x1 = exponent;
  }
  getResolution() {
    return this.resolution;
  }
  setResolution(value) {
    this.resolution = value;
  }
  get adaptive() {
    return this.mode === ToneMappingMode.REINHARD2_ADAPTIVE;
  }
  set adaptive(value) {
    this.mode = value ? ToneMappingMode.REINHARD2_ADAPTIVE : ToneMappingMode.REINHARD2;
  }
  get adaptationRate() {
    return this.adaptiveLuminanceMaterial.adaptationRate;
  }
  set adaptationRate(value) {
    this.adaptiveLuminanceMaterial.adaptationRate = value;
  }
  get distinction() {
    console.warn(this.name, "distinction was removed.");
    return 1;
  }
  set distinction(value) {
    console.warn(this.name, "distinction was removed.");
  }
  update(renderer, inputBuffer, deltaTime) {
    if (this.adaptiveLuminancePass.enabled) {
      this.luminancePass.render(renderer, inputBuffer);
      this.adaptiveLuminancePass.render(renderer, null, null, deltaTime);
    }
  }
  initialize(renderer, alpha, frameBufferType) {
    this.adaptiveLuminancePass.initialize(renderer, alpha, frameBufferType);
  }
};
var vignette_default = "uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;\n#if VIGNETTE_TECHNIQUE == 0\nfloat d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));\n#else\nvec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));\n#endif\noutputColor=vec4(color,inputColor.a);}";
var VignetteEffect = class extends Effect {
  constructor({
    blendFunction,
    technique = VignetteTechnique.DEFAULT,
    eskil = false,
    offset = 0.5,
    darkness = 0.5
  } = {}) {
    super("VignetteEffect", vignette_default, {
      blendFunction,
      defines: /* @__PURE__ */ new Map([
        ["VIGNETTE_TECHNIQUE", technique.toFixed(0)]
      ]),
      uniforms: /* @__PURE__ */ new Map([
        ["offset", new Uniform(offset)],
        ["darkness", new Uniform(darkness)]
      ])
    });
  }
  get technique() {
    return Number(this.defines.get("VIGNETTE_TECHNIQUE"));
  }
  set technique(value) {
    if (this.technique !== value) {
      this.defines.set("VIGNETTE_TECHNIQUE", value.toFixed(0));
      this.setChanged();
    }
  }
  get eskil() {
    return this.technique === VignetteTechnique.ESKIL;
  }
  set eskil(value) {
    this.technique = value ? VignetteTechnique.ESKIL : VignetteTechnique.DEFAULT;
  }
  getTechnique() {
    return this.technique;
  }
  setTechnique(value) {
    this.technique = value;
  }
  get offset() {
    return this.uniforms.get("offset").value;
  }
  set offset(value) {
    this.uniforms.get("offset").value = value;
  }
  getOffset() {
    return this.offset;
  }
  setOffset(value) {
    this.offset = value;
  }
  get darkness() {
    return this.uniforms.get("darkness").value;
  }
  set darkness(value) {
    this.uniforms.get("darkness").value = value;
  }
  getDarkness() {
    return this.darkness;
  }
  setDarkness(value) {
    this.darkness = value;
  }
};
var SMAAImageLoader = class extends Loader {
  load(onLoad = () => {
  }, onError = null) {
    if (arguments.length === 4) {
      onLoad = arguments[1];
      onError = arguments[3];
    } else if (arguments.length === 3 || typeof arguments[0] !== "function") {
      onLoad = arguments[1];
      onError = null;
    }
    const externalManager = this.manager;
    const internalManager = new LoadingManager();
    return new Promise((resolve, reject) => {
      const searchImage = new Image();
      const areaImage = new Image();
      internalManager.onError = (url) => {
        externalManager.itemError(url);
        if (onError !== null) {
          onError(`Failed to load ${url}`);
          resolve();
        } else {
          reject(`Failed to load ${url}`);
        }
      };
      internalManager.onLoad = () => {
        const result = [searchImage, areaImage];
        onLoad(result);
        resolve(result);
      };
      searchImage.addEventListener("error", (e) => {
        internalManager.itemError("smaa-search");
      });
      areaImage.addEventListener("error", (e) => {
        internalManager.itemError("smaa-area");
      });
      searchImage.addEventListener("load", () => {
        externalManager.itemEnd("smaa-search");
        internalManager.itemEnd("smaa-search");
      });
      areaImage.addEventListener("load", () => {
        externalManager.itemEnd("smaa-area");
        internalManager.itemEnd("smaa-area");
      });
      externalManager.itemStart("smaa-search");
      externalManager.itemStart("smaa-area");
      internalManager.itemStart("smaa-search");
      internalManager.itemStart("smaa-area");
      searchImage.src = searchImageDataURL_default;
      areaImage.src = areaImageDataURL_default;
    });
  }
};

// node_modules/@react-three/postprocessing/dist/index.js
var import_react = __toESM(require_react());

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/misc/MorphBlendMesh.js
var MorphBlendMesh = function(geometry2, material) {
  Mesh.call(this, geometry2, material);
  this.animationsMap = {};
  this.animationsList = [];
  var numFrames = Object.keys(this.morphTargetDictionary).length;
  var name = "__default";
  var startFrame = 0;
  var endFrame = numFrames - 1;
  var fps = numFrames / 1;
  this.createAnimation(name, startFrame, endFrame, fps);
  this.setAnimationWeight(name, 1);
};
MorphBlendMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: MorphBlendMesh,
  createAnimation: function(name, start, end, fps) {
    var animation = {
      start,
      end,
      length: end - start + 1,
      fps,
      duration: (end - start) / fps,
      lastFrame: 0,
      currentFrame: 0,
      active: false,
      time: 0,
      direction: 1,
      weight: 1,
      directionBackwards: false,
      mirroredLoop: false
    };
    this.animationsMap[name] = animation;
    this.animationsList.push(animation);
  },
  autoCreateAnimations: function(fps) {
    var pattern = /([a-z]+)_?(\d+)/i;
    var firstAnimation, frameRanges = {};
    var i2 = 0;
    for (let key in this.morphTargetDictionary) {
      var chunks = key.match(pattern);
      if (chunks && chunks.length > 1) {
        var name = chunks[1];
        if (!frameRanges[name])
          frameRanges[name] = {
            start: Infinity,
            end: -Infinity
          };
        var range = frameRanges[name];
        if (i2 < range.start)
          range.start = i2;
        if (i2 > range.end)
          range.end = i2;
        if (!firstAnimation)
          firstAnimation = name;
      }
      i2++;
    }
    for (let name2 in frameRanges) {
      var range = frameRanges[name2];
      this.createAnimation(name2, range.start, range.end, fps);
    }
    this.firstAnimation = firstAnimation;
  },
  setAnimationDirectionForward: function(name) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.direction = 1;
      animation.directionBackwards = false;
    }
  },
  setAnimationDirectionBackward: function(name) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.direction = -1;
      animation.directionBackwards = true;
    }
  },
  setAnimationFPS: function(name, fps) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.fps = fps;
      animation.duration = (animation.end - animation.start) / animation.fps;
    }
  },
  setAnimationDuration: function(name, duration) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.duration = duration;
      animation.fps = (animation.end - animation.start) / animation.duration;
    }
  },
  setAnimationWeight: function(name, weight) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.weight = weight;
    }
  },
  setAnimationTime: function(name, time) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.time = time;
    }
  },
  getAnimationTime: function(name) {
    var time = 0;
    var animation = this.animationsMap[name];
    if (animation) {
      time = animation.time;
    }
    return time;
  },
  getAnimationDuration: function(name) {
    var duration = -1;
    var animation = this.animationsMap[name];
    if (animation) {
      duration = animation.duration;
    }
    return duration;
  },
  playAnimation: function(name) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.time = 0;
      animation.active = true;
    } else {
      console.warn("THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()");
    }
  },
  stopAnimation: function(name) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.active = false;
    }
  },
  update: function(delta) {
    for (let i2 = 0, il = this.animationsList.length; i2 < il; i2++) {
      var animation = this.animationsList[i2];
      if (!animation.active)
        continue;
      var frameTime = animation.duration / animation.length;
      animation.time += animation.direction * delta;
      if (animation.mirroredLoop) {
        if (animation.time > animation.duration || animation.time < 0) {
          animation.direction *= -1;
          if (animation.time > animation.duration) {
            animation.time = animation.duration;
            animation.directionBackwards = true;
          }
          if (animation.time < 0) {
            animation.time = 0;
            animation.directionBackwards = false;
          }
        }
      } else {
        animation.time = animation.time % animation.duration;
        if (animation.time < 0)
          animation.time += animation.duration;
      }
      var keyframe = animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);
      var weight = animation.weight;
      if (keyframe !== animation.currentFrame) {
        this.morphTargetInfluences[animation.lastFrame] = 0;
        this.morphTargetInfluences[animation.currentFrame] = 1 * weight;
        this.morphTargetInfluences[keyframe] = 0;
        animation.lastFrame = animation.currentFrame;
        animation.currentFrame = keyframe;
      }
      var mix2 = animation.time % frameTime / frameTime;
      if (animation.directionBackwards)
        mix2 = 1 - mix2;
      if (animation.currentFrame !== animation.lastFrame) {
        this.morphTargetInfluences[animation.currentFrame] = mix2 * weight;
        this.morphTargetInfluences[animation.lastFrame] = (1 - mix2) * weight;
      } else {
        this.morphTargetInfluences[animation.currentFrame] = weight;
      }
    }
  }
});

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/math/ConvexHull.js
var Visible = 0;
var Deleted = 1;
var _v1 = new Vector3();
var _line3 = new Line3();
var _plane = new Plane();
var _closestPoint = new Vector3();
var _triangle = new Triangle();
var ConvexHull = class {
  constructor() {
    this.tolerance = -1;
    this.faces = [];
    this.newFaces = [];
    this.assigned = new VertexList();
    this.unassigned = new VertexList();
    this.vertices = [];
  }
  setFromPoints(points) {
    if (points.length >= 4) {
      this.makeEmpty();
      for (let i2 = 0, l = points.length; i2 < l; i2++) {
        this.vertices.push(new VertexNode(points[i2]));
      }
      this.compute();
    }
    return this;
  }
  setFromObject(object) {
    const points = [];
    object.updateMatrixWorld(true);
    object.traverse(function(node) {
      const geometry2 = node.geometry;
      if (geometry2 !== void 0) {
        if (geometry2.isGeometry) {
          console.error("THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.");
          return;
        } else if (geometry2.isBufferGeometry) {
          const attribute2 = geometry2.attributes.position;
          if (attribute2 !== void 0) {
            for (let i2 = 0, l = attribute2.count; i2 < l; i2++) {
              const point = new Vector3();
              point.fromBufferAttribute(attribute2, i2).applyMatrix4(node.matrixWorld);
              points.push(point);
            }
          }
        }
      }
    });
    return this.setFromPoints(points);
  }
  containsPoint(point) {
    const faces = this.faces;
    for (let i2 = 0, l = faces.length; i2 < l; i2++) {
      const face = faces[i2];
      if (face.distanceToPoint(point) > this.tolerance)
        return false;
    }
    return true;
  }
  intersectRay(ray, target) {
    const faces = this.faces;
    let tNear = -Infinity;
    let tFar = Infinity;
    for (let i2 = 0, l = faces.length; i2 < l; i2++) {
      const face = faces[i2];
      const vN = face.distanceToPoint(ray.origin);
      const vD = face.normal.dot(ray.direction);
      if (vN > 0 && vD >= 0)
        return null;
      const t2 = vD !== 0 ? -vN / vD : 0;
      if (t2 <= 0)
        continue;
      if (vD > 0) {
        tFar = Math.min(t2, tFar);
      } else {
        tNear = Math.max(t2, tNear);
      }
      if (tNear > tFar) {
        return null;
      }
    }
    if (tNear !== -Infinity) {
      ray.at(tNear, target);
    } else {
      ray.at(tFar, target);
    }
    return target;
  }
  intersectsRay(ray) {
    return this.intersectRay(ray, _v1) !== null;
  }
  makeEmpty() {
    this.faces = [];
    this.vertices = [];
    return this;
  }
  addVertexToFace(vertex, face) {
    vertex.face = face;
    if (face.outside === null) {
      this.assigned.append(vertex);
    } else {
      this.assigned.insertBefore(face.outside, vertex);
    }
    face.outside = vertex;
    return this;
  }
  removeVertexFromFace(vertex, face) {
    if (vertex === face.outside) {
      if (vertex.next !== null && vertex.next.face === face) {
        face.outside = vertex.next;
      } else {
        face.outside = null;
      }
    }
    this.assigned.remove(vertex);
    return this;
  }
  removeAllVerticesFromFace(face) {
    if (face.outside !== null) {
      const start = face.outside;
      let end = face.outside;
      while (end.next !== null && end.next.face === face) {
        end = end.next;
      }
      this.assigned.removeSubList(start, end);
      start.prev = end.next = null;
      face.outside = null;
      return start;
    }
  }
  deleteFaceVertices(face, absorbingFace) {
    const faceVertices = this.removeAllVerticesFromFace(face);
    if (faceVertices !== void 0) {
      if (absorbingFace === void 0) {
        this.unassigned.appendChain(faceVertices);
      } else {
        let vertex = faceVertices;
        do {
          const nextVertex = vertex.next;
          const distance2 = absorbingFace.distanceToPoint(vertex.point);
          if (distance2 > this.tolerance) {
            this.addVertexToFace(vertex, absorbingFace);
          } else {
            this.unassigned.append(vertex);
          }
          vertex = nextVertex;
        } while (vertex !== null);
      }
    }
    return this;
  }
  resolveUnassignedPoints(newFaces) {
    if (this.unassigned.isEmpty() === false) {
      let vertex = this.unassigned.first();
      do {
        const nextVertex = vertex.next;
        let maxDistance = this.tolerance;
        let maxFace = null;
        for (let i2 = 0; i2 < newFaces.length; i2++) {
          const face = newFaces[i2];
          if (face.mark === Visible) {
            const distance2 = face.distanceToPoint(vertex.point);
            if (distance2 > maxDistance) {
              maxDistance = distance2;
              maxFace = face;
            }
            if (maxDistance > 1e3 * this.tolerance)
              break;
          }
        }
        if (maxFace !== null) {
          this.addVertexToFace(vertex, maxFace);
        }
        vertex = nextVertex;
      } while (vertex !== null);
    }
    return this;
  }
  computeExtremes() {
    const min2 = new Vector3();
    const max2 = new Vector3();
    const minVertices = [];
    const maxVertices = [];
    for (let i2 = 0; i2 < 3; i2++) {
      minVertices[i2] = maxVertices[i2] = this.vertices[0];
    }
    min2.copy(this.vertices[0].point);
    max2.copy(this.vertices[0].point);
    for (let i2 = 0, l = this.vertices.length; i2 < l; i2++) {
      const vertex = this.vertices[i2];
      const point = vertex.point;
      for (let j2 = 0; j2 < 3; j2++) {
        if (point.getComponent(j2) < min2.getComponent(j2)) {
          min2.setComponent(j2, point.getComponent(j2));
          minVertices[j2] = vertex;
        }
      }
      for (let j2 = 0; j2 < 3; j2++) {
        if (point.getComponent(j2) > max2.getComponent(j2)) {
          max2.setComponent(j2, point.getComponent(j2));
          maxVertices[j2] = vertex;
        }
      }
    }
    this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min2.x), Math.abs(max2.x)) + Math.max(Math.abs(min2.y), Math.abs(max2.y)) + Math.max(Math.abs(min2.z), Math.abs(max2.z)));
    return {
      min: minVertices,
      max: maxVertices
    };
  }
  computeInitialHull() {
    const vertices = this.vertices;
    const extremes = this.computeExtremes();
    const min2 = extremes.min;
    const max2 = extremes.max;
    let maxDistance = 0;
    let index = 0;
    for (let i2 = 0; i2 < 3; i2++) {
      const distance2 = max2[i2].point.getComponent(i2) - min2[i2].point.getComponent(i2);
      if (distance2 > maxDistance) {
        maxDistance = distance2;
        index = i2;
      }
    }
    const v0 = min2[index];
    const v12 = max2[index];
    let v22;
    let v3;
    maxDistance = 0;
    _line3.set(v0.point, v12.point);
    for (let i2 = 0, l = this.vertices.length; i2 < l; i2++) {
      const vertex = vertices[i2];
      if (vertex !== v0 && vertex !== v12) {
        _line3.closestPointToPoint(vertex.point, true, _closestPoint);
        const distance2 = _closestPoint.distanceToSquared(vertex.point);
        if (distance2 > maxDistance) {
          maxDistance = distance2;
          v22 = vertex;
        }
      }
    }
    maxDistance = -1;
    _plane.setFromCoplanarPoints(v0.point, v12.point, v22.point);
    for (let i2 = 0, l = this.vertices.length; i2 < l; i2++) {
      const vertex = vertices[i2];
      if (vertex !== v0 && vertex !== v12 && vertex !== v22) {
        const distance2 = Math.abs(_plane.distanceToPoint(vertex.point));
        if (distance2 > maxDistance) {
          maxDistance = distance2;
          v3 = vertex;
        }
      }
    }
    const faces = [];
    if (_plane.distanceToPoint(v3.point) < 0) {
      faces.push(Face.create(v0, v12, v22), Face.create(v3, v12, v0), Face.create(v3, v22, v12), Face.create(v3, v0, v22));
      for (let i2 = 0; i2 < 3; i2++) {
        const j2 = (i2 + 1) % 3;
        faces[i2 + 1].getEdge(2).setTwin(faces[0].getEdge(j2));
        faces[i2 + 1].getEdge(1).setTwin(faces[j2 + 1].getEdge(0));
      }
    } else {
      faces.push(Face.create(v0, v22, v12), Face.create(v3, v0, v12), Face.create(v3, v12, v22), Face.create(v3, v22, v0));
      for (let i2 = 0; i2 < 3; i2++) {
        const j2 = (i2 + 1) % 3;
        faces[i2 + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i2) % 3));
        faces[i2 + 1].getEdge(0).setTwin(faces[j2 + 1].getEdge(1));
      }
    }
    for (let i2 = 0; i2 < 4; i2++) {
      this.faces.push(faces[i2]);
    }
    for (let i2 = 0, l = vertices.length; i2 < l; i2++) {
      const vertex = vertices[i2];
      if (vertex !== v0 && vertex !== v12 && vertex !== v22 && vertex !== v3) {
        maxDistance = this.tolerance;
        let maxFace = null;
        for (let j2 = 0; j2 < 4; j2++) {
          const distance2 = this.faces[j2].distanceToPoint(vertex.point);
          if (distance2 > maxDistance) {
            maxDistance = distance2;
            maxFace = this.faces[j2];
          }
        }
        if (maxFace !== null) {
          this.addVertexToFace(vertex, maxFace);
        }
      }
    }
    return this;
  }
  reindexFaces() {
    const activeFaces = [];
    for (let i2 = 0; i2 < this.faces.length; i2++) {
      const face = this.faces[i2];
      if (face.mark === Visible) {
        activeFaces.push(face);
      }
    }
    this.faces = activeFaces;
    return this;
  }
  nextVertexToAdd() {
    if (this.assigned.isEmpty() === false) {
      let eyeVertex, maxDistance = 0;
      const eyeFace = this.assigned.first().face;
      let vertex = eyeFace.outside;
      do {
        const distance2 = eyeFace.distanceToPoint(vertex.point);
        if (distance2 > maxDistance) {
          maxDistance = distance2;
          eyeVertex = vertex;
        }
        vertex = vertex.next;
      } while (vertex !== null && vertex.face === eyeFace);
      return eyeVertex;
    }
  }
  computeHorizon(eyePoint, crossEdge, face, horizon) {
    this.deleteFaceVertices(face);
    face.mark = Deleted;
    let edge;
    if (crossEdge === null) {
      edge = crossEdge = face.getEdge(0);
    } else {
      edge = crossEdge.next;
    }
    do {
      const twinEdge = edge.twin;
      const oppositeFace = twinEdge.face;
      if (oppositeFace.mark === Visible) {
        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {
          this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);
        } else {
          horizon.push(edge);
        }
      }
      edge = edge.next;
    } while (edge !== crossEdge);
    return this;
  }
  addAdjoiningFace(eyeVertex, horizonEdge) {
    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());
    this.faces.push(face);
    face.getEdge(-1).setTwin(horizonEdge.twin);
    return face.getEdge(0);
  }
  addNewFaces(eyeVertex, horizon) {
    this.newFaces = [];
    let firstSideEdge = null;
    let previousSideEdge = null;
    for (let i2 = 0; i2 < horizon.length; i2++) {
      const horizonEdge = horizon[i2];
      const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);
      if (firstSideEdge === null) {
        firstSideEdge = sideEdge;
      } else {
        sideEdge.next.setTwin(previousSideEdge);
      }
      this.newFaces.push(sideEdge.face);
      previousSideEdge = sideEdge;
    }
    firstSideEdge.next.setTwin(previousSideEdge);
    return this;
  }
  addVertexToHull(eyeVertex) {
    const horizon = [];
    this.unassigned.clear();
    this.removeVertexFromFace(eyeVertex, eyeVertex.face);
    this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);
    this.addNewFaces(eyeVertex, horizon);
    this.resolveUnassignedPoints(this.newFaces);
    return this;
  }
  cleanup() {
    this.assigned.clear();
    this.unassigned.clear();
    this.newFaces = [];
    return this;
  }
  compute() {
    let vertex;
    this.computeInitialHull();
    while ((vertex = this.nextVertexToAdd()) !== void 0) {
      this.addVertexToHull(vertex);
    }
    this.reindexFaces();
    this.cleanup();
    return this;
  }
};
var Face = class {
  constructor() {
    this.normal = new Vector3();
    this.midpoint = new Vector3();
    this.area = 0;
    this.constant = 0;
    this.outside = null;
    this.mark = Visible;
    this.edge = null;
  }
  static create(a2, b2, c2) {
    const face = new Face();
    const e0 = new HalfEdge(a2, face);
    const e1 = new HalfEdge(b2, face);
    const e2 = new HalfEdge(c2, face);
    e0.next = e2.prev = e1;
    e1.next = e0.prev = e2;
    e2.next = e1.prev = e0;
    face.edge = e0;
    return face.compute();
  }
  getEdge(i2) {
    let edge = this.edge;
    while (i2 > 0) {
      edge = edge.next;
      i2--;
    }
    while (i2 < 0) {
      edge = edge.prev;
      i2++;
    }
    return edge;
  }
  compute() {
    const a2 = this.edge.tail();
    const b2 = this.edge.head();
    const c2 = this.edge.next.head();
    _triangle.set(a2.point, b2.point, c2.point);
    _triangle.getNormal(this.normal);
    _triangle.getMidpoint(this.midpoint);
    this.area = _triangle.getArea();
    this.constant = this.normal.dot(this.midpoint);
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) - this.constant;
  }
};
var HalfEdge = class {
  constructor(vertex, face) {
    this.vertex = vertex;
    this.prev = null;
    this.next = null;
    this.twin = null;
    this.face = face;
  }
  head() {
    return this.vertex;
  }
  tail() {
    return this.prev ? this.prev.vertex : null;
  }
  length() {
    const head = this.head();
    const tail = this.tail();
    if (tail !== null) {
      return tail.point.distanceTo(head.point);
    }
    return -1;
  }
  lengthSquared() {
    const head = this.head();
    const tail = this.tail();
    if (tail !== null) {
      return tail.point.distanceToSquared(head.point);
    }
    return -1;
  }
  setTwin(edge) {
    this.twin = edge;
    edge.twin = this;
    return this;
  }
};
var VertexNode = class {
  constructor(point) {
    this.point = point;
    this.prev = null;
    this.next = null;
    this.face = null;
  }
};
var VertexList = class {
  constructor() {
    this.head = null;
    this.tail = null;
  }
  first() {
    return this.head;
  }
  last() {
    return this.tail;
  }
  clear() {
    this.head = this.tail = null;
    return this;
  }
  insertBefore(target, vertex) {
    vertex.prev = target.prev;
    vertex.next = target;
    if (vertex.prev === null) {
      this.head = vertex;
    } else {
      vertex.prev.next = vertex;
    }
    target.prev = vertex;
    return this;
  }
  insertAfter(target, vertex) {
    vertex.prev = target;
    vertex.next = target.next;
    if (vertex.next === null) {
      this.tail = vertex;
    } else {
      vertex.next.prev = vertex;
    }
    target.next = vertex;
    return this;
  }
  append(vertex) {
    if (this.head === null) {
      this.head = vertex;
    } else {
      this.tail.next = vertex;
    }
    vertex.prev = this.tail;
    vertex.next = null;
    this.tail = vertex;
    return this;
  }
  appendChain(vertex) {
    if (this.head === null) {
      this.head = vertex;
    } else {
      this.tail.next = vertex;
    }
    vertex.prev = this.tail;
    while (vertex.next !== null) {
      vertex = vertex.next;
    }
    this.tail = vertex;
    return this;
  }
  remove(vertex) {
    if (vertex.prev === null) {
      this.head = vertex.next;
    } else {
      vertex.prev.next = vertex.next;
    }
    if (vertex.next === null) {
      this.tail = vertex.prev;
    } else {
      vertex.next.prev = vertex.prev;
    }
    return this;
  }
  removeSubList(a2, b2) {
    if (a2.prev === null) {
      this.head = b2.next;
    } else {
      a2.prev.next = b2.next;
    }
    if (b2.next === null) {
      this.tail = a2.prev;
    } else {
      b2.next.prev = a2.prev;
    }
    return this;
  }
  isEmpty() {
    return this.head === null;
  }
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/geometries/ConvexGeometry.js
var ConvexGeometry = class extends BufferGeometry {
  constructor(points = []) {
    super();
    const vertices = [];
    const normals = [];
    if (ConvexHull === void 0) {
      console.error("THREE.ConvexGeometry: ConvexGeometry relies on ConvexHull");
    }
    const convexHull = new ConvexHull().setFromPoints(points);
    const faces = convexHull.faces;
    for (let i2 = 0; i2 < faces.length; i2++) {
      const face = faces[i2];
      let edge = face.edge;
      do {
        const point = edge.head().point;
        vertices.push(point.x, point.y, point.z);
        normals.push(face.normal.x, face.normal.y, face.normal.z);
        edge = edge.next;
      } while (edge !== face.edge);
    }
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  }
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/misc/ConvexObjectBreaker.js
var ConvexObjectBreaker = function(minSizeForBreak, smallDelta) {
  this.minSizeForBreak = minSizeForBreak || 1.4;
  this.smallDelta = smallDelta || 1e-4;
  this.tempLine1 = new Line3();
  this.tempPlane1 = new Plane();
  this.tempPlane2 = new Plane();
  this.tempPlane_Cut = new Plane();
  this.tempCM1 = new Vector3();
  this.tempCM2 = new Vector3();
  this.tempVector3 = new Vector3();
  this.tempVector3_2 = new Vector3();
  this.tempVector3_3 = new Vector3();
  this.tempVector3_P0 = new Vector3();
  this.tempVector3_P1 = new Vector3();
  this.tempVector3_P2 = new Vector3();
  this.tempVector3_N0 = new Vector3();
  this.tempVector3_N1 = new Vector3();
  this.tempVector3_AB = new Vector3();
  this.tempVector3_CB = new Vector3();
  this.tempResultObjects = {
    object1: null,
    object2: null
  };
  this.segments = [];
  var n = 30 * 30;
  for (let i2 = 0; i2 < n; i2++)
    this.segments[i2] = false;
};
ConvexObjectBreaker.prototype = {
  constructor: ConvexObjectBreaker,
  prepareBreakableObject: function(object, mass, velocity, angularVelocity, breakable) {
    if (!object.geometry.isBufferGeometry) {
      console.error("THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry.");
    }
    var userData = object.userData;
    userData.mass = mass;
    userData.velocity = velocity.clone();
    userData.angularVelocity = angularVelocity.clone();
    userData.breakable = breakable;
  },
  subdivideByImpact: function(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {
    var debris = [];
    var tempPlane1 = this.tempPlane1;
    var tempPlane2 = this.tempPlane2;
    this.tempVector3.addVectors(pointOfImpact, normal);
    tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3);
    var maxTotalIterations = maxRandomIterations + maxRadialIterations;
    var scope = this;
    function subdivideRadial(subObject, startAngle, endAngle, numIterations) {
      if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {
        debris.push(subObject);
        return;
      }
      var angle = Math.PI;
      if (numIterations === 0) {
        tempPlane2.normal.copy(tempPlane1.normal);
        tempPlane2.constant = tempPlane1.constant;
      } else {
        if (numIterations <= maxRadialIterations) {
          angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle;
          scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact);
          tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2);
        } else {
          angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI;
          scope.tempVector3_2.copy(pointOfImpact).sub(subObject.position).applyAxisAngle(normal, angle).add(subObject.position);
          scope.tempVector3_3.copy(normal).add(subObject.position);
          tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2);
        }
      }
      scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects);
      var obj1 = scope.tempResultObjects.object1;
      var obj2 = scope.tempResultObjects.object2;
      if (obj1) {
        subdivideRadial(obj1, startAngle, angle, numIterations + 1);
      }
      if (obj2) {
        subdivideRadial(obj2, angle, endAngle, numIterations + 1);
      }
    }
    subdivideRadial(object, 0, 2 * Math.PI, 0);
    return debris;
  },
  cutByPlane: function(object, plane, output) {
    var geometry2 = object.geometry;
    var coords = geometry2.attributes.position.array;
    var normals = geometry2.attributes.normal.array;
    var numPoints = coords.length / 3;
    var numFaces = numPoints / 3;
    var indices = geometry2.getIndex();
    if (indices) {
      indices = indices.array;
      numFaces = indices.length / 3;
    }
    function getVertexIndex(faceIdx, vert) {
      var idx = faceIdx * 3 + vert;
      return indices ? indices[idx] : idx;
    }
    var points1 = [];
    var points2 = [];
    var delta = this.smallDelta;
    var numPointPairs = numPoints * numPoints;
    for (let i2 = 0; i2 < numPointPairs; i2++)
      this.segments[i2] = false;
    var p0 = this.tempVector3_P0;
    var p1 = this.tempVector3_P1;
    var n0 = this.tempVector3_N0;
    var n1 = this.tempVector3_N1;
    for (let i2 = 0; i2 < numFaces - 1; i2++) {
      var a1 = getVertexIndex(i2, 0);
      var b1 = getVertexIndex(i2, 1);
      var c1 = getVertexIndex(i2, 2);
      n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2);
      for (let j2 = i2 + 1; j2 < numFaces; j2++) {
        var a2 = getVertexIndex(j2, 0);
        var b2 = getVertexIndex(j2, 1);
        var c2 = getVertexIndex(j2, 2);
        n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2);
        var coplanar = 1 - n0.dot(n1) < delta;
        if (coplanar) {
          if (a1 === a2 || a1 === b2 || a1 === c2) {
            if (b1 === a2 || b1 === b2 || b1 === c2) {
              this.segments[a1 * numPoints + b1] = true;
              this.segments[b1 * numPoints + a1] = true;
            } else {
              this.segments[c1 * numPoints + a1] = true;
              this.segments[a1 * numPoints + c1] = true;
            }
          } else if (b1 === a2 || b1 === b2 || b1 === c2) {
            this.segments[c1 * numPoints + b1] = true;
            this.segments[b1 * numPoints + c1] = true;
          }
        }
      }
    }
    var localPlane = this.tempPlane_Cut;
    object.updateMatrix();
    ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane);
    for (let i2 = 0; i2 < numFaces; i2++) {
      var va = getVertexIndex(i2, 0);
      var vb = getVertexIndex(i2, 1);
      var vc = getVertexIndex(i2, 2);
      for (let segment = 0; segment < 3; segment++) {
        var i0 = segment === 0 ? va : segment === 1 ? vb : vc;
        var i1 = segment === 0 ? vb : segment === 1 ? vc : va;
        var segmentState = this.segments[i0 * numPoints + i1];
        if (segmentState)
          continue;
        this.segments[i0 * numPoints + i1] = true;
        this.segments[i1 * numPoints + i0] = true;
        p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2]);
        p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2]);
        var mark0 = 0;
        var d = localPlane.distanceToPoint(p0);
        if (d > delta) {
          mark0 = 2;
          points2.push(p0.clone());
        } else if (d < -delta) {
          mark0 = 1;
          points1.push(p0.clone());
        } else {
          mark0 = 3;
          points1.push(p0.clone());
          points2.push(p0.clone());
        }
        var mark1 = 0;
        var d = localPlane.distanceToPoint(p1);
        if (d > delta) {
          mark1 = 2;
          points2.push(p1.clone());
        } else if (d < -delta) {
          mark1 = 1;
          points1.push(p1.clone());
        } else {
          mark1 = 3;
          points1.push(p1.clone());
          points2.push(p1.clone());
        }
        if (mark0 === 1 && mark1 === 2 || mark0 === 2 && mark1 === 1) {
          this.tempLine1.start.copy(p0);
          this.tempLine1.end.copy(p1);
          var intersection = new Vector3();
          intersection = localPlane.intersectLine(this.tempLine1, intersection);
          if (intersection === void 0) {
            console.error("Internal error: segment does not intersect plane.");
            output.segmentedObject1 = null;
            output.segmentedObject2 = null;
            return 0;
          }
          points1.push(intersection);
          points2.push(intersection.clone());
        }
      }
    }
    var newMass = object.userData.mass * 0.5;
    this.tempCM1.set(0, 0, 0);
    var radius1 = 0;
    var numPoints1 = points1.length;
    if (numPoints1 > 0) {
      for (let i2 = 0; i2 < numPoints1; i2++)
        this.tempCM1.add(points1[i2]);
      this.tempCM1.divideScalar(numPoints1);
      for (let i2 = 0; i2 < numPoints1; i2++) {
        var p = points1[i2];
        p.sub(this.tempCM1);
        radius1 = Math.max(radius1, p.x, p.y, p.z);
      }
      this.tempCM1.add(object.position);
    }
    this.tempCM2.set(0, 0, 0);
    var radius2 = 0;
    var numPoints2 = points2.length;
    if (numPoints2 > 0) {
      for (let i2 = 0; i2 < numPoints2; i2++)
        this.tempCM2.add(points2[i2]);
      this.tempCM2.divideScalar(numPoints2);
      for (let i2 = 0; i2 < numPoints2; i2++) {
        var p = points2[i2];
        p.sub(this.tempCM2);
        radius2 = Math.max(radius2, p.x, p.y, p.z);
      }
      this.tempCM2.add(object.position);
    }
    var object1 = null;
    var object2 = null;
    var numObjects = 0;
    if (numPoints1 > 4) {
      object1 = new Mesh(new ConvexGeometry(points1), object.material);
      object1.position.copy(this.tempCM1);
      object1.quaternion.copy(object.quaternion);
      this.prepareBreakableObject(object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak);
      numObjects++;
    }
    if (numPoints2 > 4) {
      object2 = new Mesh(new ConvexGeometry(points2), object.material);
      object2.position.copy(this.tempCM2);
      object2.quaternion.copy(object.quaternion);
      this.prepareBreakableObject(object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak);
      numObjects++;
    }
    output.object1 = object1;
    output.object2 = object2;
    return numObjects;
  }
};
ConvexObjectBreaker.transformFreeVector = function(v3, m2) {
  var x = v3.x, y = v3.y, z = v3.z;
  var e = m2.elements;
  v3.x = e[0] * x + e[4] * y + e[8] * z;
  v3.y = e[1] * x + e[5] * y + e[9] * z;
  v3.z = e[2] * x + e[6] * y + e[10] * z;
  return v3;
};
ConvexObjectBreaker.transformFreeVectorInverse = function(v3, m2) {
  var x = v3.x, y = v3.y, z = v3.z;
  var e = m2.elements;
  v3.x = e[0] * x + e[1] * y + e[2] * z;
  v3.y = e[4] * x + e[5] * y + e[6] * z;
  v3.z = e[8] * x + e[9] * y + e[10] * z;
  return v3;
};
ConvexObjectBreaker.transformTiedVectorInverse = function(v3, m2) {
  var x = v3.x, y = v3.y, z = v3.z;
  var e = m2.elements;
  v3.x = e[0] * x + e[1] * y + e[2] * z - e[12];
  v3.y = e[4] * x + e[5] * y + e[6] * z - e[13];
  v3.z = e[8] * x + e[9] * y + e[10] * z - e[14];
  return v3;
};
ConvexObjectBreaker.transformPlaneToLocalSpace = function() {
  var v12 = new Vector3();
  return function transformPlaneToLocalSpace(plane, m2, resultPlane) {
    resultPlane.normal.copy(plane.normal);
    resultPlane.constant = plane.constant;
    var referencePoint = ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(v12), m2);
    ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m2);
    resultPlane.constant = -referencePoint.dot(resultPlane.normal);
  };
}();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/misc/Gyroscope.js
var Gyroscope = function() {
  Object3D.call(this);
};
Gyroscope.prototype = Object.create(Object3D.prototype);
Gyroscope.prototype.constructor = Gyroscope;
Gyroscope.prototype.updateMatrixWorld = function() {
  var translationObject = new Vector3();
  var quaternionObject = new Quaternion();
  var scaleObject = new Vector3();
  var translationWorld = new Vector3();
  var quaternionWorld = new Quaternion();
  var scaleWorld = new Vector3();
  return function updateMatrixWorld(force) {
    this.matrixAutoUpdate && this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent !== null) {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        this.matrixWorld.decompose(translationWorld, quaternionWorld, scaleWorld);
        this.matrix.decompose(translationObject, quaternionObject, scaleObject);
        this.matrixWorld.compose(translationWorld, quaternionObject, scaleWorld);
      } else {
        this.matrixWorld.copy(this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    for (let i2 = 0, l = this.children.length; i2 < l; i2++) {
      this.children[i2].updateMatrixWorld(force);
    }
  };
}();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/misc/MorphAnimMesh.js
var MorphAnimMesh = function(geometry2, material) {
  Mesh.call(this, geometry2, material);
  this.type = "MorphAnimMesh";
  this.mixer = new AnimationMixer(this);
  this.activeAction = null;
};
MorphAnimMesh.prototype = Object.create(Mesh.prototype);
MorphAnimMesh.prototype.constructor = MorphAnimMesh;
MorphAnimMesh.prototype.setDirectionForward = function() {
  this.mixer.timeScale = 1;
};
MorphAnimMesh.prototype.setDirectionBackward = function() {
  this.mixer.timeScale = -1;
};
MorphAnimMesh.prototype.playAnimation = function(label2, fps) {
  if (this.activeAction) {
    this.activeAction.stop();
    this.activeAction = null;
  }
  var clip = AnimationClip.findByName(this, label2);
  if (clip) {
    var action = this.mixer.clipAction(clip);
    action.timeScale = clip.tracks.length * fps / clip.duration;
    this.activeAction = action.play();
  } else {
    throw new Error("THREE.MorphAnimMesh: animations[" + label2 + "] undefined in .playAnimation()");
  }
};
MorphAnimMesh.prototype.updateAnimation = function(delta) {
  this.mixer.update(delta);
};
MorphAnimMesh.prototype.copy = function(source) {
  Mesh.prototype.copy.call(this, source);
  this.mixer = new AnimationMixer(this);
  return this;
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/misc/RollerCoaster.js
var RollerCoasterGeometry = function(curve, divisions) {
  BufferGeometry.call(this);
  var vertices = [];
  var normals = [];
  var colors = [];
  var color1 = [1, 1, 1];
  var color22 = [1, 1, 0];
  var up = new Vector3(0, 1, 0);
  var forward = new Vector3();
  var right = new Vector3();
  var quaternion = new Quaternion();
  var prevQuaternion = new Quaternion();
  prevQuaternion.setFromAxisAngle(up, Math.PI / 2);
  var point = new Vector3();
  var prevPoint = new Vector3();
  prevPoint.copy(curve.getPointAt(0));
  var step2 = [new Vector3(-0.225, 0, 0), new Vector3(0, -0.05, 0), new Vector3(0, -0.175, 0), new Vector3(0, -0.05, 0), new Vector3(0.225, 0, 0), new Vector3(0, -0.175, 0)];
  var PI2 = Math.PI * 2;
  var sides = 5;
  var tube1 = [];
  for (let i2 = 0; i2 < sides; i2++) {
    var angle = i2 / sides * PI2;
    tube1.push(new Vector3(Math.sin(angle) * 0.06, Math.cos(angle) * 0.06, 0));
  }
  var sides = 6;
  var tube2 = [];
  for (let i2 = 0; i2 < sides; i2++) {
    var angle = i2 / sides * PI2;
    tube2.push(new Vector3(Math.sin(angle) * 0.025, Math.cos(angle) * 0.025, 0));
  }
  var vector2 = new Vector3();
  var normal = new Vector3();
  function drawShape(shape, color3) {
    normal.set(0, 0, -1).applyQuaternion(quaternion);
    for (let j2 = 0; j2 < shape.length; j2++) {
      vector2.copy(shape[j2]);
      vector2.applyQuaternion(quaternion);
      vector2.add(point);
      vertices.push(vector2.x, vector2.y, vector2.z);
      normals.push(normal.x, normal.y, normal.z);
      colors.push(color3[0], color3[1], color3[2]);
    }
    normal.set(0, 0, 1).applyQuaternion(quaternion);
    for (let j2 = shape.length - 1; j2 >= 0; j2--) {
      vector2.copy(shape[j2]);
      vector2.applyQuaternion(quaternion);
      vector2.add(point);
      vertices.push(vector2.x, vector2.y, vector2.z);
      normals.push(normal.x, normal.y, normal.z);
      colors.push(color3[0], color3[1], color3[2]);
    }
  }
  var vector1 = new Vector3();
  var vector22 = new Vector3();
  var vector3 = new Vector3();
  var vector4 = new Vector3();
  var normal1 = new Vector3();
  var normal2 = new Vector3();
  var normal3 = new Vector3();
  var normal4 = new Vector3();
  function extrudeShape(shape, offset2, color3) {
    for (let j2 = 0, jl2 = shape.length; j2 < jl2; j2++) {
      var point1 = shape[j2];
      var point2 = shape[(j2 + 1) % jl2];
      vector1.copy(point1).add(offset2);
      vector1.applyQuaternion(quaternion);
      vector1.add(point);
      vector22.copy(point2).add(offset2);
      vector22.applyQuaternion(quaternion);
      vector22.add(point);
      vector3.copy(point2).add(offset2);
      vector3.applyQuaternion(prevQuaternion);
      vector3.add(prevPoint);
      vector4.copy(point1).add(offset2);
      vector4.applyQuaternion(prevQuaternion);
      vector4.add(prevPoint);
      vertices.push(vector1.x, vector1.y, vector1.z);
      vertices.push(vector22.x, vector22.y, vector22.z);
      vertices.push(vector4.x, vector4.y, vector4.z);
      vertices.push(vector22.x, vector22.y, vector22.z);
      vertices.push(vector3.x, vector3.y, vector3.z);
      vertices.push(vector4.x, vector4.y, vector4.z);
      normal1.copy(point1);
      normal1.applyQuaternion(quaternion);
      normal1.normalize();
      normal2.copy(point2);
      normal2.applyQuaternion(quaternion);
      normal2.normalize();
      normal3.copy(point2);
      normal3.applyQuaternion(prevQuaternion);
      normal3.normalize();
      normal4.copy(point1);
      normal4.applyQuaternion(prevQuaternion);
      normal4.normalize();
      normals.push(normal1.x, normal1.y, normal1.z);
      normals.push(normal2.x, normal2.y, normal2.z);
      normals.push(normal4.x, normal4.y, normal4.z);
      normals.push(normal2.x, normal2.y, normal2.z);
      normals.push(normal3.x, normal3.y, normal3.z);
      normals.push(normal4.x, normal4.y, normal4.z);
      colors.push(color3[0], color3[1], color3[2]);
      colors.push(color3[0], color3[1], color3[2]);
      colors.push(color3[0], color3[1], color3[2]);
      colors.push(color3[0], color3[1], color3[2]);
      colors.push(color3[0], color3[1], color3[2]);
      colors.push(color3[0], color3[1], color3[2]);
    }
  }
  var offset = new Vector3();
  for (let i2 = 1; i2 <= divisions; i2++) {
    point.copy(curve.getPointAt(i2 / divisions));
    up.set(0, 1, 0);
    forward.subVectors(point, prevPoint).normalize();
    right.crossVectors(up, forward).normalize();
    up.crossVectors(forward, right);
    var angle = Math.atan2(forward.x, forward.z);
    quaternion.setFromAxisAngle(up, angle);
    if (i2 % 2 === 0) {
      drawShape(step2, color22);
    }
    extrudeShape(tube1, offset.set(0, -0.125, 0), color22);
    extrudeShape(tube2, offset.set(0.2, 0, 0), color1);
    extrudeShape(tube2, offset.set(-0.2, 0, 0), color1);
    prevPoint.copy(point);
    prevQuaternion.copy(quaternion);
  }
  this.setAttribute("position", new BufferAttribute(new Float32Array(vertices), 3));
  this.setAttribute("normal", new BufferAttribute(new Float32Array(normals), 3));
  this.setAttribute("color", new BufferAttribute(new Float32Array(colors), 3));
};
RollerCoasterGeometry.prototype = Object.create(BufferGeometry.prototype);
var RollerCoasterLiftersGeometry = function(curve, divisions) {
  BufferGeometry.call(this);
  var vertices = [];
  var normals = [];
  var quaternion = new Quaternion();
  var up = new Vector3(0, 1, 0);
  var point = new Vector3();
  var tangent = new Vector3();
  var tube1 = [new Vector3(0, 0.05, -0.05), new Vector3(0, 0.05, 0.05), new Vector3(0, -0.05, 0)];
  var tube2 = [new Vector3(-0.05, 0, 0.05), new Vector3(-0.05, 0, -0.05), new Vector3(0.05, 0, 0)];
  var tube3 = [new Vector3(0.05, 0, -0.05), new Vector3(0.05, 0, 0.05), new Vector3(-0.05, 0, 0)];
  var vector1 = new Vector3();
  var vector2 = new Vector3();
  var vector3 = new Vector3();
  var vector4 = new Vector3();
  var normal1 = new Vector3();
  var normal2 = new Vector3();
  var normal3 = new Vector3();
  var normal4 = new Vector3();
  function extrudeShape(shape, fromPoint2, toPoint2) {
    for (let j2 = 0, jl2 = shape.length; j2 < jl2; j2++) {
      var point1 = shape[j2];
      var point2 = shape[(j2 + 1) % jl2];
      vector1.copy(point1);
      vector1.applyQuaternion(quaternion);
      vector1.add(fromPoint2);
      vector2.copy(point2);
      vector2.applyQuaternion(quaternion);
      vector2.add(fromPoint2);
      vector3.copy(point2);
      vector3.applyQuaternion(quaternion);
      vector3.add(toPoint2);
      vector4.copy(point1);
      vector4.applyQuaternion(quaternion);
      vector4.add(toPoint2);
      vertices.push(vector1.x, vector1.y, vector1.z);
      vertices.push(vector2.x, vector2.y, vector2.z);
      vertices.push(vector4.x, vector4.y, vector4.z);
      vertices.push(vector2.x, vector2.y, vector2.z);
      vertices.push(vector3.x, vector3.y, vector3.z);
      vertices.push(vector4.x, vector4.y, vector4.z);
      normal1.copy(point1);
      normal1.applyQuaternion(quaternion);
      normal1.normalize();
      normal2.copy(point2);
      normal2.applyQuaternion(quaternion);
      normal2.normalize();
      normal3.copy(point2);
      normal3.applyQuaternion(quaternion);
      normal3.normalize();
      normal4.copy(point1);
      normal4.applyQuaternion(quaternion);
      normal4.normalize();
      normals.push(normal1.x, normal1.y, normal1.z);
      normals.push(normal2.x, normal2.y, normal2.z);
      normals.push(normal4.x, normal4.y, normal4.z);
      normals.push(normal2.x, normal2.y, normal2.z);
      normals.push(normal3.x, normal3.y, normal3.z);
      normals.push(normal4.x, normal4.y, normal4.z);
    }
  }
  var fromPoint = new Vector3();
  var toPoint = new Vector3();
  for (let i2 = 1; i2 <= divisions; i2++) {
    point.copy(curve.getPointAt(i2 / divisions));
    tangent.copy(curve.getTangentAt(i2 / divisions));
    var angle = Math.atan2(tangent.x, tangent.z);
    quaternion.setFromAxisAngle(up, angle);
    if (point.y > 10) {
      fromPoint.set(-0.75, -0.35, 0);
      fromPoint.applyQuaternion(quaternion);
      fromPoint.add(point);
      toPoint.set(0.75, -0.35, 0);
      toPoint.applyQuaternion(quaternion);
      toPoint.add(point);
      extrudeShape(tube1, fromPoint, toPoint);
      fromPoint.set(-0.7, -0.3, 0);
      fromPoint.applyQuaternion(quaternion);
      fromPoint.add(point);
      toPoint.set(-0.7, -point.y, 0);
      toPoint.applyQuaternion(quaternion);
      toPoint.add(point);
      extrudeShape(tube2, fromPoint, toPoint);
      fromPoint.set(0.7, -0.3, 0);
      fromPoint.applyQuaternion(quaternion);
      fromPoint.add(point);
      toPoint.set(0.7, -point.y, 0);
      toPoint.applyQuaternion(quaternion);
      toPoint.add(point);
      extrudeShape(tube3, fromPoint, toPoint);
    } else {
      fromPoint.set(0, -0.2, 0);
      fromPoint.applyQuaternion(quaternion);
      fromPoint.add(point);
      toPoint.set(0, -point.y, 0);
      toPoint.applyQuaternion(quaternion);
      toPoint.add(point);
      extrudeShape(tube3, fromPoint, toPoint);
    }
  }
  this.setAttribute("position", new BufferAttribute(new Float32Array(vertices), 3));
  this.setAttribute("normal", new BufferAttribute(new Float32Array(normals), 3));
};
RollerCoasterLiftersGeometry.prototype = Object.create(BufferGeometry.prototype);
var RollerCoasterShadowGeometry = function(curve, divisions) {
  BufferGeometry.call(this);
  var vertices = [];
  var up = new Vector3(0, 1, 0);
  var forward = new Vector3();
  var quaternion = new Quaternion();
  var prevQuaternion = new Quaternion();
  prevQuaternion.setFromAxisAngle(up, Math.PI / 2);
  var point = new Vector3();
  var prevPoint = new Vector3();
  prevPoint.copy(curve.getPointAt(0));
  prevPoint.y = 0;
  var vector1 = new Vector3();
  var vector2 = new Vector3();
  var vector3 = new Vector3();
  var vector4 = new Vector3();
  for (let i2 = 1; i2 <= divisions; i2++) {
    point.copy(curve.getPointAt(i2 / divisions));
    point.y = 0;
    forward.subVectors(point, prevPoint);
    var angle = Math.atan2(forward.x, forward.z);
    quaternion.setFromAxisAngle(up, angle);
    vector1.set(-0.3, 0, 0);
    vector1.applyQuaternion(quaternion);
    vector1.add(point);
    vector2.set(0.3, 0, 0);
    vector2.applyQuaternion(quaternion);
    vector2.add(point);
    vector3.set(0.3, 0, 0);
    vector3.applyQuaternion(prevQuaternion);
    vector3.add(prevPoint);
    vector4.set(-0.3, 0, 0);
    vector4.applyQuaternion(prevQuaternion);
    vector4.add(prevPoint);
    vertices.push(vector1.x, vector1.y, vector1.z);
    vertices.push(vector2.x, vector2.y, vector2.z);
    vertices.push(vector4.x, vector4.y, vector4.z);
    vertices.push(vector2.x, vector2.y, vector2.z);
    vertices.push(vector3.x, vector3.y, vector3.z);
    vertices.push(vector4.x, vector4.y, vector4.z);
    prevPoint.copy(point);
    prevQuaternion.copy(quaternion);
  }
  this.setAttribute("position", new BufferAttribute(new Float32Array(vertices), 3));
};
RollerCoasterShadowGeometry.prototype = Object.create(BufferGeometry.prototype);
var SkyGeometry = function() {
  BufferGeometry.call(this);
  var vertices = [];
  for (let i2 = 0; i2 < 100; i2++) {
    var x = Math.random() * 800 - 400;
    var y = Math.random() * 50 + 50;
    var z = Math.random() * 800 - 400;
    var size2 = Math.random() * 40 + 20;
    vertices.push(x - size2, y, z - size2);
    vertices.push(x + size2, y, z - size2);
    vertices.push(x - size2, y, z + size2);
    vertices.push(x + size2, y, z - size2);
    vertices.push(x + size2, y, z + size2);
    vertices.push(x - size2, y, z + size2);
  }
  this.setAttribute("position", new BufferAttribute(new Float32Array(vertices), 3));
};
SkyGeometry.prototype = Object.create(BufferGeometry.prototype);
var TreesGeometry = function(landscape) {
  BufferGeometry.call(this);
  var vertices = [];
  var colors = [];
  var raycaster = new Raycaster();
  raycaster.ray.direction.set(0, -1, 0);
  for (let i2 = 0; i2 < 2e3; i2++) {
    var x = Math.random() * 500 - 250;
    var z = Math.random() * 500 - 250;
    raycaster.ray.origin.set(x, 50, z);
    var intersections = raycaster.intersectObject(landscape);
    if (intersections.length === 0)
      continue;
    var y = intersections[0].point.y;
    var height = Math.random() * 5 + 0.5;
    var angle = Math.random() * Math.PI * 2;
    vertices.push(x + Math.sin(angle), y, z + Math.cos(angle));
    vertices.push(x, y + height, z);
    vertices.push(x + Math.sin(angle + Math.PI), y, z + Math.cos(angle + Math.PI));
    angle += Math.PI / 2;
    vertices.push(x + Math.sin(angle), y, z + Math.cos(angle));
    vertices.push(x, y + height, z);
    vertices.push(x + Math.sin(angle + Math.PI), y, z + Math.cos(angle + Math.PI));
    var random = Math.random() * 0.1;
    for (let j2 = 0; j2 < 6; j2++) {
      colors.push(0.2 + random, 0.4 + random, 0);
    }
  }
  this.setAttribute("position", new BufferAttribute(new Float32Array(vertices), 3));
  this.setAttribute("color", new BufferAttribute(new Float32Array(colors), 3));
};
TreesGeometry.prototype = Object.create(BufferGeometry.prototype);

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/misc/WebGL.js
var webGL2Available;
function isWebGL2Available() {
  if (webGL2Available !== void 0)
    return webGL2Available;
  try {
    var _gl$getExtension2;
    let gl;
    const canvas = document.createElement("canvas");
    webGL2Available = !!(window.WebGL2RenderingContext && (gl = canvas.getContext("webgl2")));
    if (gl)
      (_gl$getExtension2 = gl.getExtension("WEBGL_lose_context")) === null || _gl$getExtension2 === void 0 ? void 0 : _gl$getExtension2.loseContext();
    return webGL2Available;
  } catch (e) {
    return webGL2Available = false;
  }
}

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/misc/VolumeSlice.js
var VolumeSlice = function(volume, index, axis) {
  var slice = this;
  this.volume = volume;
  index = index || 0;
  Object.defineProperty(this, "index", {
    get: function() {
      return index;
    },
    set: function(value) {
      index = value;
      slice.geometryNeedsUpdate = true;
      return index;
    }
  });
  this.axis = axis || "z";
  this.canvas = document.createElement("canvas");
  this.canvasBuffer = document.createElement("canvas");
  this.updateGeometry();
  var canvasMap = new Texture(this.canvas);
  canvasMap.minFilter = LinearFilter;
  canvasMap.wrapS = canvasMap.wrapT = ClampToEdgeWrapping;
  var material = new MeshBasicMaterial({
    map: canvasMap,
    side: DoubleSide,
    transparent: true
  });
  this.mesh = new Mesh(this.geometry, material);
  this.mesh.matrixAutoUpdate = false;
  this.geometryNeedsUpdate = true;
  this.repaint();
};
VolumeSlice.prototype = {
  constructor: VolumeSlice,
  repaint: function() {
    if (this.geometryNeedsUpdate) {
      this.updateGeometry();
    }
    var iLength = this.iLength, jLength = this.jLength, sliceAccess = this.sliceAccess, volume = this.volume, canvas = this.canvasBuffer, ctx = this.ctxBuffer;
    var imgData = ctx.getImageData(0, 0, iLength, jLength);
    var data = imgData.data;
    var volumeData = volume.data;
    var upperThreshold = volume.upperThreshold;
    var lowerThreshold = volume.lowerThreshold;
    var windowLow = volume.windowLow;
    var windowHigh = volume.windowHigh;
    var pixelCount = 0;
    if (volume.dataType === "label") {
      for (let j2 = 0; j2 < jLength; j2++) {
        for (let i2 = 0; i2 < iLength; i2++) {
          var label2 = volumeData[sliceAccess(i2, j2)];
          label2 = label2 >= this.colorMap.length ? label2 % this.colorMap.length + 1 : label2;
          var color3 = this.colorMap[label2];
          data[4 * pixelCount] = color3 >> 24 & 255;
          data[4 * pixelCount + 1] = color3 >> 16 & 255;
          data[4 * pixelCount + 2] = color3 >> 8 & 255;
          data[4 * pixelCount + 3] = color3 & 255;
          pixelCount++;
        }
      }
    } else {
      for (let j2 = 0; j2 < jLength; j2++) {
        for (let i2 = 0; i2 < iLength; i2++) {
          var value = volumeData[sliceAccess(i2, j2)];
          var alpha = 255;
          alpha = upperThreshold >= value ? lowerThreshold <= value ? alpha : 0 : 0;
          value = Math.floor(255 * (value - windowLow) / (windowHigh - windowLow));
          value = value > 255 ? 255 : value < 0 ? 0 : value | 0;
          data[4 * pixelCount] = value;
          data[4 * pixelCount + 1] = value;
          data[4 * pixelCount + 2] = value;
          data[4 * pixelCount + 3] = alpha;
          pixelCount++;
        }
      }
    }
    ctx.putImageData(imgData, 0, 0);
    this.ctx.drawImage(canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height);
    this.mesh.material.map.needsUpdate = true;
  },
  updateGeometry: function() {
    var extracted = this.volume.extractPerpendicularPlane(this.axis, this.index);
    this.sliceAccess = extracted.sliceAccess;
    this.jLength = extracted.jLength;
    this.iLength = extracted.iLength;
    this.matrix = extracted.matrix;
    this.canvas.width = extracted.planeWidth;
    this.canvas.height = extracted.planeHeight;
    this.canvasBuffer.width = this.iLength;
    this.canvasBuffer.height = this.jLength;
    this.ctx = this.canvas.getContext("2d");
    this.ctxBuffer = this.canvasBuffer.getContext("2d");
    if (this.geometry)
      this.geometry.dispose();
    this.geometry = new PlaneGeometry(extracted.planeWidth, extracted.planeHeight);
    if (this.mesh) {
      this.mesh.geometry = this.geometry;
      this.mesh.matrix.identity();
      this.mesh.applyMatrix4(this.matrix);
    }
    this.geometryNeedsUpdate = false;
  }
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/misc/Volume.js
var Volume = function(xLength, yLength, zLength, type2, arrayBuffer) {
  if (arguments.length > 0) {
    this.xLength = Number(xLength) || 1;
    this.yLength = Number(yLength) || 1;
    this.zLength = Number(zLength) || 1;
    switch (type2) {
      case "Uint8":
      case "uint8":
      case "uchar":
      case "unsigned char":
      case "uint8_t":
        this.data = new Uint8Array(arrayBuffer);
        break;
      case "Int8":
      case "int8":
      case "signed char":
      case "int8_t":
        this.data = new Int8Array(arrayBuffer);
        break;
      case "Int16":
      case "int16":
      case "short":
      case "short int":
      case "signed short":
      case "signed short int":
      case "int16_t":
        this.data = new Int16Array(arrayBuffer);
        break;
      case "Uint16":
      case "uint16":
      case "ushort":
      case "unsigned short":
      case "unsigned short int":
      case "uint16_t":
        this.data = new Uint16Array(arrayBuffer);
        break;
      case "Int32":
      case "int32":
      case "int":
      case "signed int":
      case "int32_t":
        this.data = new Int32Array(arrayBuffer);
        break;
      case "Uint32":
      case "uint32":
      case "uint":
      case "unsigned int":
      case "uint32_t":
        this.data = new Uint32Array(arrayBuffer);
        break;
      case "longlong":
      case "long long":
      case "long long int":
      case "signed long long":
      case "signed long long int":
      case "int64":
      case "int64_t":
      case "ulonglong":
      case "unsigned long long":
      case "unsigned long long int":
      case "uint64":
      case "uint64_t":
        throw "Error in Volume constructor : this type is not supported in JavaScript";
      case "Float32":
      case "float32":
      case "float":
        this.data = new Float32Array(arrayBuffer);
        break;
      case "Float64":
      case "float64":
      case "double":
        this.data = new Float64Array(arrayBuffer);
        break;
      default:
        this.data = new Uint8Array(arrayBuffer);
    }
    if (this.data.length !== this.xLength * this.yLength * this.zLength) {
      throw "Error in Volume constructor, lengths are not matching arrayBuffer size";
    }
  }
  this.spacing = [1, 1, 1];
  this.offset = [0, 0, 0];
  this.matrix = new Matrix3();
  this.matrix.identity();
  var lowerThreshold = -Infinity;
  Object.defineProperty(this, "lowerThreshold", {
    get: function() {
      return lowerThreshold;
    },
    set: function(value) {
      lowerThreshold = value;
      this.sliceList.forEach(function(slice) {
        slice.geometryNeedsUpdate = true;
      });
    }
  });
  var upperThreshold = Infinity;
  Object.defineProperty(this, "upperThreshold", {
    get: function() {
      return upperThreshold;
    },
    set: function(value) {
      upperThreshold = value;
      this.sliceList.forEach(function(slice) {
        slice.geometryNeedsUpdate = true;
      });
    }
  });
  this.sliceList = [];
};
Volume.prototype = {
  constructor: Volume,
  getData: function(i2, j2, k) {
    return this.data[k * this.xLength * this.yLength + j2 * this.xLength + i2];
  },
  access: function(i2, j2, k) {
    return k * this.xLength * this.yLength + j2 * this.xLength + i2;
  },
  reverseAccess: function(index) {
    var z = Math.floor(index / (this.yLength * this.xLength));
    var y = Math.floor((index - z * this.yLength * this.xLength) / this.xLength);
    var x = index - z * this.yLength * this.xLength - y * this.xLength;
    return [x, y, z];
  },
  map: function(functionToMap, context) {
    var length2 = this.data.length;
    context = context || this;
    for (let i2 = 0; i2 < length2; i2++) {
      this.data[i2] = functionToMap.call(context, this.data[i2], i2, this.data);
    }
    return this;
  },
  extractPerpendicularPlane: function(axis, RASIndex) {
    var iLength, jLength, sliceAccess, planeMatrix = new Matrix4().identity(), volume = this, planeWidth, planeHeight, firstSpacing, secondSpacing, positionOffset, IJKIndex;
    var axisInIJK = new Vector3(), firstDirection = new Vector3(), secondDirection = new Vector3();
    var dimensions = new Vector3(this.xLength, this.yLength, this.zLength);
    switch (axis) {
      case "x":
        axisInIJK.set(1, 0, 0);
        firstDirection.set(0, 0, -1);
        secondDirection.set(0, -1, 0);
        firstSpacing = this.spacing[2];
        secondSpacing = this.spacing[1];
        IJKIndex = new Vector3(RASIndex, 0, 0);
        planeMatrix.multiply(new Matrix4().makeRotationY(Math.PI / 2));
        positionOffset = (volume.RASDimensions[0] - 1) / 2;
        planeMatrix.setPosition(new Vector3(RASIndex - positionOffset, 0, 0));
        break;
      case "y":
        axisInIJK.set(0, 1, 0);
        firstDirection.set(1, 0, 0);
        secondDirection.set(0, 0, 1);
        firstSpacing = this.spacing[0];
        secondSpacing = this.spacing[2];
        IJKIndex = new Vector3(0, RASIndex, 0);
        planeMatrix.multiply(new Matrix4().makeRotationX(-Math.PI / 2));
        positionOffset = (volume.RASDimensions[1] - 1) / 2;
        planeMatrix.setPosition(new Vector3(0, RASIndex - positionOffset, 0));
        break;
      case "z":
      default:
        axisInIJK.set(0, 0, 1);
        firstDirection.set(1, 0, 0);
        secondDirection.set(0, -1, 0);
        firstSpacing = this.spacing[0];
        secondSpacing = this.spacing[1];
        IJKIndex = new Vector3(0, 0, RASIndex);
        positionOffset = (volume.RASDimensions[2] - 1) / 2;
        planeMatrix.setPosition(new Vector3(0, 0, RASIndex - positionOffset));
        break;
    }
    firstDirection.applyMatrix4(volume.inverseMatrix).normalize();
    firstDirection.argVar = "i";
    secondDirection.applyMatrix4(volume.inverseMatrix).normalize();
    secondDirection.argVar = "j";
    axisInIJK.applyMatrix4(volume.inverseMatrix).normalize();
    iLength = Math.floor(Math.abs(firstDirection.dot(dimensions)));
    jLength = Math.floor(Math.abs(secondDirection.dot(dimensions)));
    planeWidth = Math.abs(iLength * firstSpacing);
    planeHeight = Math.abs(jLength * secondSpacing);
    IJKIndex = Math.abs(Math.round(IJKIndex.applyMatrix4(volume.inverseMatrix).dot(axisInIJK)));
    var base = [new Vector3(1, 0, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1)];
    var iDirection = [firstDirection, secondDirection, axisInIJK].find(function(x) {
      return Math.abs(x.dot(base[0])) > 0.9;
    });
    var jDirection = [firstDirection, secondDirection, axisInIJK].find(function(x) {
      return Math.abs(x.dot(base[1])) > 0.9;
    });
    var kDirection = [firstDirection, secondDirection, axisInIJK].find(function(x) {
      return Math.abs(x.dot(base[2])) > 0.9;
    });
    sliceAccess = function(i2, j2) {
      var accessI, accessJ, accessK;
      var si = iDirection === axisInIJK ? IJKIndex : iDirection.argVar === "i" ? i2 : j2;
      var sj = jDirection === axisInIJK ? IJKIndex : jDirection.argVar === "i" ? i2 : j2;
      var sk = kDirection === axisInIJK ? IJKIndex : kDirection.argVar === "i" ? i2 : j2;
      var accessI = iDirection.dot(base[0]) > 0 ? si : volume.xLength - 1 - si;
      var accessJ = jDirection.dot(base[1]) > 0 ? sj : volume.yLength - 1 - sj;
      var accessK = kDirection.dot(base[2]) > 0 ? sk : volume.zLength - 1 - sk;
      return volume.access(accessI, accessJ, accessK);
    };
    return {
      iLength,
      jLength,
      sliceAccess,
      matrix: planeMatrix,
      planeWidth,
      planeHeight
    };
  },
  extractSlice: function(axis, index) {
    var slice = new VolumeSlice(this, index, axis);
    this.sliceList.push(slice);
    return slice;
  },
  repaintAllSlices: function() {
    this.sliceList.forEach(function(slice) {
      slice.repaint();
    });
    return this;
  },
  computeMinMax: function() {
    var min2 = Infinity;
    var max2 = -Infinity;
    var datasize = this.data.length;
    var i2 = 0;
    for (i2 = 0; i2 < datasize; i2++) {
      if (!isNaN(this.data[i2])) {
        var value = this.data[i2];
        min2 = Math.min(min2, value);
        max2 = Math.max(max2, value);
      }
    }
    this.min = min2;
    this.max = max2;
    return [min2, max2];
  }
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/renderers/CSS2DRenderer.js
var CSS2DObject = function(element2) {
  Object3D.call(this);
  this.element = element2 || document.createElement("div");
  this.element.style.position = "absolute";
  this.addEventListener("removed", function() {
    this.traverse(function(object) {
      if (object.element instanceof Element && object.element.parentNode !== null) {
        object.element.parentNode.removeChild(object.element);
      }
    });
  });
};
CSS2DObject.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: CSS2DObject,
  copy: function(source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    this.element = source.element.cloneNode(true);
    return this;
  }
});

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/renderers/CSS3DRenderer.js
var CSS3DObject = function(element2) {
  Object3D.call(this);
  this.element = element2 || document.createElement("div");
  this.element.style.position = "absolute";
  this.element.style.pointerEvents = "auto";
  this.addEventListener("removed", function() {
    this.traverse(function(object) {
      if (object.element instanceof Element && object.element.parentNode !== null) {
        object.element.parentNode.removeChild(object.element);
      }
    });
  });
};
CSS3DObject.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: CSS3DObject,
  copy: function(source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    this.element = source.element.cloneNode(true);
    return this;
  }
});
var CSS3DSprite = function(element2) {
  CSS3DObject.call(this, element2);
};
CSS3DSprite.prototype = Object.create(CSS3DObject.prototype);
CSS3DSprite.prototype.constructor = CSS3DSprite;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/renderers/Projector.js
var RenderableVertex = function() {
  this.position = new Vector3();
  this.positionWorld = new Vector3();
  this.positionScreen = new Vector4();
  this.visible = true;
};
RenderableVertex.prototype.copy = function(vertex) {
  this.positionWorld.copy(vertex.positionWorld);
  this.positionScreen.copy(vertex.positionScreen);
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/renderers/SVGRenderer.js
var SVGObject = function(node) {
  Object3D.call(this);
  this.node = node;
};
SVGObject.prototype = Object.create(Object3D.prototype);
SVGObject.prototype.constructor = SVGObject;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/modifiers/CurveModifier.js
var matrix = new Matrix4();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/modifiers/SimplifyModifier.js
var cb = new Vector3();
var ab2 = new Vector3();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/core/constants.js
var NodeShaderStage = {
  Vertex: "vertex",
  Fragment: "fragment"
};
var NodeUpdateType = {
  None: "none",
  Frame: "frame",
  Object: "object"
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/core/NodeUtils.js
var getNodesKeys = (object) => {
  const props = [];
  for (const name in object) {
    const value = object[name];
    if (value && value.isNode === true) {
      props.push(name);
    }
  }
  return props;
};
var getValueType = (value) => {
  if (typeof value === "number") {
    return "float";
  } else if (typeof value === "boolean") {
    return "bool";
  } else if ((value === null || value === void 0 ? void 0 : value.isVector2) === true) {
    return "vec2";
  } else if ((value === null || value === void 0 ? void 0 : value.isVector3) === true) {
    return "vec3";
  } else if ((value === null || value === void 0 ? void 0 : value.isVector4) === true) {
    return "vec4";
  } else if ((value === null || value === void 0 ? void 0 : value.isMatrix3) === true) {
    return "mat3";
  } else if ((value === null || value === void 0 ? void 0 : value.isMatrix4) === true) {
    return "mat4";
  } else if ((value === null || value === void 0 ? void 0 : value.isColor) === true) {
    return "color";
  }
  return null;
};
var getValueFromType = (type2, ...params) => {
  const last4 = type2 === null || type2 === void 0 ? void 0 : type2.slice(-4);
  if (type2 === "color") {
    return new Color(...params);
  } else if (last4 === "vec2") {
    return new Vector2(...params);
  } else if (last4 === "vec3") {
    return new Vector3(...params);
  } else if (last4 === "vec4") {
    return new Vector4(...params);
  } else if (last4 === "mat3") {
    return new Matrix3(...params);
  } else if (last4 === "mat4") {
    return new Matrix4(...params);
  } else if (type2 === "bool") {
    return false;
  } else if (type2 === "float" || type2 === "int" || type2 === "uint") {
    return 0;
  }
  return null;
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/core/Node.js
var _nodeId = 0;
var Node2 = class {
  constructor(nodeType = null) {
    this.nodeType = nodeType;
    this.updateType = NodeUpdateType.None;
    this.uuid = MathUtils.generateUUID();
    Object.defineProperty(this, "id", {
      value: _nodeId++
    });
  }
  get type() {
    return this.constructor.name;
  }
  getHash() {
    return this.uuid;
  }
  getUpdateType() {
    return this.updateType;
  }
  getNodeType() {
    return this.nodeType;
  }
  update() {
    console.warn("Abstract function.");
  }
  generate() {
    console.warn("Abstract function.");
  }
  analyze(builder) {
    const hash = this.getHash(builder);
    const sharedNode = builder.getNodeFromHash(hash);
    if (sharedNode !== void 0 && this !== sharedNode) {
      return sharedNode.analyze(builder);
    }
    const nodeData = builder.getDataFromNode(this);
    nodeData.dependenciesCount = nodeData.dependenciesCount === void 0 ? 1 : nodeData.dependenciesCount + 1;
    const nodeKeys = getNodesKeys(this);
    for (const property of nodeKeys) {
      this[property].analyze(builder);
    }
  }
  build(builder, output = null) {
    const hash = this.getHash(builder);
    const sharedNode = builder.getNodeFromHash(hash);
    if (sharedNode !== void 0 && this !== sharedNode) {
      return sharedNode.build(builder, output);
    }
    builder.addNode(this);
    builder.addStack(this);
    const nodeData = builder.getDataFromNode(this);
    const isGenerateOnce = this.generate.length === 1;
    let snippet = null;
    if (isGenerateOnce) {
      const type2 = this.getNodeType(builder);
      snippet = nodeData.snippet;
      if (snippet === void 0) {
        snippet = this.generate(builder) || "";
        nodeData.snippet = snippet;
      }
      snippet = builder.format(snippet, type2, output);
    } else {
      snippet = this.generate(builder, output) || "";
    }
    builder.removeStack(this);
    return snippet;
  }
  serialize(json) {
    const nodeKeys = getNodesKeys(this);
    if (nodeKeys.length > 0) {
      const inputNodes = {};
      for (const property of nodeKeys) {
        inputNodes[property] = this[property].toJSON(json.meta).uuid;
      }
      json.inputNodes = inputNodes;
    }
  }
  deserialize(json) {
    if (json.inputNodes !== void 0) {
      const nodes = json.meta.nodes;
      for (const property in json.inputNodes) {
        const uuid = json.inputNodes[property];
        this[property] = nodes[uuid];
      }
    }
  }
  toJSON(meta) {
    const {
      uuid,
      type: type2
    } = this;
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    let data = meta.nodes[uuid];
    if (data === void 0) {
      data = {
        uuid,
        type: type2,
        meta,
        metadata: {
          version: 4.5,
          type: "Node",
          generator: "Node.toJSON"
        }
      };
      meta.nodes[data.uuid] = data;
      this.serialize(data);
      delete data.meta;
    }
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
      if (nodes.length > 0)
        data.nodes = nodes;
    }
    return data;
  }
};
Node2.prototype.isNode = true;
var Node_default = Node2;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/core/InputNode.js
var InputNode = class extends Node_default {
  constructor(value, nodeType = null) {
    super(nodeType);
    this.value = value;
  }
  getNodeType() {
    if (this.nodeType === null) {
      return getValueType(this.value);
    }
    return this.nodeType;
  }
  getInputType(builder) {
    return this.getNodeType(builder);
  }
  serialize(data) {
    var _this$value, _this$value$toArray;
    super.serialize(data);
    data.value = ((_this$value = this.value) === null || _this$value === void 0 ? void 0 : (_this$value$toArray = _this$value.toArray) === null || _this$value$toArray === void 0 ? void 0 : _this$value$toArray.call(_this$value)) || this.value;
    data.valueType = getValueType(this.value);
    data.nodeType = this.nodeType;
  }
  deserialize(data) {
    var _this$value2, _this$value2$fromArra;
    super.deserialize(data);
    this.nodeType = data.nodeType;
    this.value = getValueFromType(data.valueType);
    this.value = ((_this$value2 = this.value) === null || _this$value2 === void 0 ? void 0 : (_this$value2$fromArra = _this$value2.fromArray) === null || _this$value2$fromArra === void 0 ? void 0 : _this$value2$fromArra.call(_this$value2, data.value)) || data.value;
  }
  generate() {
    console.warn("Abstract function.");
  }
};
InputNode.prototype.isInputNode = true;
var InputNode_default = InputNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/core/UniformNode.js
var UniformNode = class extends InputNode_default {
  getUniformHash(builder) {
    return this.getHash(builder);
  }
  generate(builder, output) {
    const type2 = this.getNodeType(builder);
    const hash = this.getUniformHash(builder);
    let sharedNode = builder.getNodeFromHash(hash);
    if (sharedNode === void 0) {
      builder.setHashNode(this, hash);
      sharedNode = this;
    }
    const sharedNodeType = sharedNode.getInputType(builder);
    const nodeUniform = builder.getUniformFromNode(sharedNode, builder.shaderStage, sharedNodeType);
    const propertyName = builder.getPropertyName(nodeUniform);
    return builder.format(propertyName, type2, output);
  }
};
UniformNode.prototype.isUniformNode = true;
var UniformNode_default = UniformNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/core/ArrayUniformNode.js
var ArrayUniformNode = class extends UniformNode_default {
  constructor(nodes = []) {
    super();
    this.nodes = nodes;
  }
  getNodeType(builder) {
    return this.nodes[0].getNodeType(builder);
  }
};
ArrayUniformNode.prototype.isArrayUniformNode = true;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/core/VaryNode.js
var VaryNode = class extends Node_default {
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const type2 = this.getNodeType(builder);
    const node = this.node;
    const name = this.name;
    const nodeVary = builder.getVaryFromNode(this, type2);
    if (name !== null) {
      nodeVary.name = name;
    }
    const propertyName = builder.getPropertyName(nodeVary, NodeShaderStage.Vertex);
    builder.flowNodeFromShaderStage(NodeShaderStage.Vertex, node, type2, propertyName);
    return builder.getPropertyName(nodeVary);
  }
};
var VaryNode_default = VaryNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/core/AttributeNode.js
var AttributeNode = class extends Node_default {
  constructor(attributeName, nodeType) {
    super(nodeType);
    this._attributeName = attributeName;
  }
  getHash(builder) {
    return this.getAttributeName(builder);
  }
  setAttributeName(attributeName) {
    this._attributeName = attributeName;
    return this;
  }
  getAttributeName() {
    return this._attributeName;
  }
  generate(builder) {
    const attribute2 = builder.getAttribute(this.getAttributeName(builder), this.getNodeType(builder));
    if (builder.isShaderStage("vertex")) {
      return attribute2.name;
    } else {
      const nodeVary = new VaryNode_default(this);
      return nodeVary.build(builder, attribute2.type);
    }
  }
};
var AttributeNode_default = AttributeNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/core/BypassNode.js
var BypassNode = class extends Node_default {
  constructor(returnNode, callNode) {
    super();
    this.outputNode = returnNode;
    this.callNode = callNode;
  }
  getNodeType(builder) {
    return this.outputNode.getNodeType(builder);
  }
  generate(builder, output) {
    const snippet = this.callNode.build(builder, "void");
    if (snippet !== "") {
      builder.addFlowCode(snippet);
    }
    return this.outputNode.build(builder, output);
  }
};
BypassNode.prototype.isBypassNode = true;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/core/CodeNode.js
var CodeNode = class extends Node_default {
  constructor(code = "", nodeType = "code") {
    super(nodeType);
    this.code = code;
    this._includes = [];
  }
  setIncludes(includes) {
    this._includes = includes;
    return this;
  }
  getIncludes() {
    return this._includes;
  }
  generate(builder) {
    const includes = this.getIncludes(builder);
    for (const include of includes) {
      include.build(builder);
    }
    const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));
    nodeCode.code = this.code;
    return nodeCode.code;
  }
};
CodeNode.prototype.isCodeNode = true;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/core/ConstNode.js
var ConstNode = class extends InputNode_default {
  generateConst(builder) {
    return builder.getConst(this.getNodeType(builder), this.value);
  }
  generate(builder, output) {
    const type2 = this.getNodeType(builder);
    return builder.format(this.generateConst(builder), type2, output);
  }
};
ConstNode.prototype.isConstNode = true;
var ConstNode_default = ConstNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/core/ContextNode.js
var ContextNode = class extends Node_default {
  constructor(node, context = {}) {
    super();
    this.node = node;
    this.context = context;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder, output) {
    const previousContext = builder.getContext();
    builder.setContext(Object.assign({}, builder.context, this.context));
    const snippet = this.node.build(builder, output);
    builder.setContext(previousContext);
    return snippet;
  }
};
ContextNode.prototype.isContextNode = true;
var ContextNode_default = ContextNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/core/TempNode.js
var TempNode = class extends Node_default {
  constructor(type2) {
    super(type2);
  }
  build(builder, output) {
    const type2 = builder.getVectorType(this.getNodeType(builder, output));
    const nodeData = builder.getDataFromNode(this);
    if (builder.context.temp !== false && type2 !== "void " && output !== "void" && nodeData.dependenciesCount > 1) {
      if (nodeData.snippet === void 0) {
        const snippet = super.build(builder, type2);
        const nodeVar = builder.getVarFromNode(this, type2);
        const propertyName = builder.getPropertyName(nodeVar);
        builder.addFlowCode(`${propertyName} = ${snippet}`);
        nodeData.snippet = snippet;
        nodeData.propertyName = propertyName;
      }
      return builder.format(nodeData.propertyName, type2, output);
    }
    return super.build(builder, output);
  }
};
var TempNode_default = TempNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/core/ExpressionNode.js
var ExpressionNode = class extends TempNode_default {
  constructor(snipped = "", nodeType = "void") {
    super(nodeType);
    this.snipped = snipped;
  }
  generate(builder) {
    const type2 = this.getNodeType(builder);
    const snipped = this.snipped;
    if (type2 === "void") {
      builder.addFlowCode(snipped);
    } else {
      return `( ${snipped} )`;
    }
  }
};
var ExpressionNode_default = ExpressionNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/core/NodeAttribute.js
var NodeAttribute = class {
  constructor(name, type2) {
    this.name = name;
    this.type = type2;
  }
};
NodeAttribute.prototype.isNodeAttribute = true;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/core/NodeUniform.js
var NodeUniform = class {
  constructor(name, type2, node, needsUpdate = void 0) {
    this.name = name;
    this.type = type2;
    this.node = node;
    this.needsUpdate = needsUpdate;
  }
  get value() {
    return this.node.value;
  }
  set value(val) {
    this.node.value = val;
  }
};
NodeUniform.prototype.isNodeUniform = true;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/core/NodeVary.js
var NodeVary = class {
  constructor(name, type2) {
    this.name = name;
    this.type = type2;
  }
};
NodeVary.prototype.isNodeVary = true;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/core/NodeVar.js
var NodeVar = class {
  constructor(name, type2) {
    this.name = name;
    this.type = type2;
  }
};
NodeVar.prototype.isNodeVar = true;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/core/NodeBuilder.js
var vector = ["x", "y", "z", "w"];

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/core/NodeFunctionInput.js
var NodeFunctionInput = class {
  constructor(type2, name, count = null, qualifier = "", isConst = false) {
    this.type = type2;
    this.name = name;
    this.count = count;
    this.qualifier = qualifier;
    this.isConst = isConst;
  }
};
NodeFunctionInput.isNodeFunctionInput = true;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/core/PropertyNode.js
var PropertyNode = class extends Node_default {
  constructor(name = null, nodeType = "vec4") {
    super(nodeType);
    this.name = name;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  generate(builder) {
    const nodeVary = builder.getVarFromNode(this, this.getNodeType(builder));
    const name = this.name;
    if (name !== null) {
      nodeVary.name = name;
    }
    return builder.getPropertyName(nodeVary);
  }
};
var PropertyNode_default = PropertyNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/core/VarNode.js
var VarNode = class extends Node_default {
  constructor(node, name = null, nodeType = null) {
    super(nodeType);
    this.node = node;
    this.name = name;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return super.getNodeType(builder) || this.node.getNodeType(builder);
  }
  generate(builder) {
    const type2 = builder.getVectorType(this.getNodeType(builder));
    const node = this.node;
    const name = this.name;
    const snippet = node.build(builder, type2);
    const nodeVar = builder.getVarFromNode(this, type2);
    if (name !== null) {
      nodeVar.name = name;
    }
    const propertyName = builder.getPropertyName(nodeVar);
    builder.addFlowCode(`${propertyName} = ${snippet}`);
    return propertyName;
  }
};
VarNode.prototype.isVarNode = true;
var VarNode_default = VarNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/accessors/BufferNode.js
var BufferNode = class extends UniformNode_default {
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType);
    this.bufferType = bufferType;
    this.bufferCount = bufferCount;
  }
  getInputType() {
    return "buffer";
  }
};
BufferNode.prototype.isBufferNode = true;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/accessors/Object3DNode.js
var Object3DNode = class extends Node_default {
  constructor(scope = Object3DNode.VIEW_MATRIX, object3d = null) {
    super();
    this.scope = scope;
    this.object3d = object3d;
    this.updateType = NodeUpdateType.Object;
    this._uniformNode = new UniformNode_default(null);
  }
  getNodeType() {
    const scope = this.scope;
    if (scope === Object3DNode.WORLD_MATRIX || scope === Object3DNode.VIEW_MATRIX) {
      return "mat4";
    } else if (scope === Object3DNode.NORMAL_MATRIX) {
      return "mat3";
    } else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION) {
      return "vec3";
    }
  }
  update(frame) {
    const object = this.object3d !== null ? this.object3d : frame.object;
    const uniformNode = this._uniformNode;
    const camera = frame.camera;
    const scope = this.scope;
    if (scope === Object3DNode.VIEW_MATRIX) {
      uniformNode.value = object.modelViewMatrix;
    } else if (scope === Object3DNode.NORMAL_MATRIX) {
      uniformNode.value = object.normalMatrix;
    } else if (scope === Object3DNode.WORLD_MATRIX) {
      uniformNode.value = object.matrixWorld;
    } else if (scope === Object3DNode.POSITION) {
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
    } else if (scope === Object3DNode.VIEW_POSITION) {
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
      uniformNode.value.applyMatrix4(camera.matrixWorldInverse);
    }
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === Object3DNode.WORLD_MATRIX || scope === Object3DNode.VIEW_MATRIX) {
      this._uniformNode.nodeType = "mat4";
    } else if (scope === Object3DNode.NORMAL_MATRIX) {
      this._uniformNode.nodeType = "mat3";
    } else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION) {
      this._uniformNode.nodeType = "vec3";
      this._uniformNode.value = new Vector3();
    }
    return this._uniformNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
_defineProperty(Object3DNode, "VIEW_MATRIX", "viewMatrix");
_defineProperty(Object3DNode, "NORMAL_MATRIX", "normalMatrix");
_defineProperty(Object3DNode, "WORLD_MATRIX", "worldMatrix");
_defineProperty(Object3DNode, "POSITION", "position");
_defineProperty(Object3DNode, "VIEW_POSITION", "viewPosition");
var Object3DNode_default = Object3DNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/accessors/CameraNode.js
var CameraNode = class extends Object3DNode_default {
  constructor(scope = CameraNode.POSITION) {
    super(scope);
  }
  getNodeType(builder) {
    const scope = this.scope;
    if (scope === CameraNode.PROJECTION_MATRIX) {
      return "mat4";
    }
    return super.getNodeType(builder);
  }
  update(frame) {
    const camera = frame.camera;
    const uniformNode = this._uniformNode;
    const scope = this.scope;
    if (scope === CameraNode.PROJECTION_MATRIX) {
      uniformNode.value = camera.projectionMatrix;
    } else if (scope === CameraNode.VIEW_MATRIX) {
      uniformNode.value = camera.matrixWorldInverse;
    } else {
      this.object3d = camera;
      super.update(frame);
    }
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === CameraNode.PROJECTION_MATRIX) {
      this._uniformNode.nodeType = "mat4";
    }
    return super.generate(builder);
  }
};
_defineProperty(CameraNode, "PROJECTION_MATRIX", "projectionMatrix");
var CameraNode_default = CameraNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/accessors/UVNode.js
var UVNode = class extends AttributeNode_default {
  constructor(index = 0) {
    super(null, "vec2");
    this.index = index;
  }
  getAttributeName() {
    const index = this.index;
    return "uv" + (index > 0 ? index + 1 : "");
  }
  serialize(data) {
    super.serialize(data);
    data.index = this.index;
  }
  deserialize(data) {
    super.deserialize(data);
    this.index = data.index;
  }
};
UVNode.prototype.isUVNode = true;
var UVNode_default = UVNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/accessors/TextureNode.js
var TextureNode = class extends UniformNode_default {
  constructor(value, uvNode = new UVNode_default(), biasNode = null) {
    super(value, "vec4");
    this.uvNode = uvNode;
    this.biasNode = biasNode;
  }
  getUniformHash() {
    return this.value.uuid;
  }
  getInputType() {
    return "texture";
  }
  generate(builder, output) {
    const texture2 = this.value;
    if (!texture2 || texture2.isTexture !== true) {
      throw new Error("TextureNode: Need a three.js texture.");
    }
    const textureProperty = super.generate(builder, "texture");
    if (output === "sampler") {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output)) {
      return textureProperty;
    } else {
      const nodeData = builder.getDataFromNode(this);
      let snippet = nodeData.snippet;
      if (snippet === void 0) {
        const uvSnippet = this.uvNode.build(builder, "vec2");
        const biasNode = this.biasNode;
        if (biasNode !== null) {
          const biasSnippet = biasNode.build(builder, "float");
          snippet = builder.getTextureBias(textureProperty, uvSnippet, biasSnippet);
        } else {
          snippet = builder.getTexture(textureProperty, uvSnippet);
        }
        nodeData.snippet = snippet;
      }
      return builder.format(snippet, "vec4", output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.value = this.value.toJSON(data.meta).uuid;
  }
  deserialize(data) {
    super.deserialize(data);
    this.value = data.meta.textures[data.value];
  }
};
TextureNode.prototype.isTextureNode = true;
var TextureNode_default = TextureNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/accessors/ModelNode.js
var ModelNode = class extends Object3DNode_default {
  constructor(scope = ModelNode.VIEW_MATRIX) {
    super(scope);
  }
};
var ModelNode_default = ModelNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/utils/JoinNode.js
var JoinNode = class extends Node_default {
  constructor(nodes = []) {
    super();
    this.nodes = nodes;
  }
  getNodeType(builder) {
    return builder.getTypeFromLength(this.nodes.reduce((count, cur) => count + builder.getTypeLength(cur.getNodeType(builder)), 0));
  }
  generate(builder) {
    const type2 = this.getNodeType(builder);
    const nodes = this.nodes;
    const snippetValues = [];
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const input = nodes[i2];
      const inputSnippet = input.build(builder);
      snippetValues.push(inputSnippet);
    }
    return `${builder.getType(type2)}( ${snippetValues.join(", ")} )`;
  }
};
var JoinNode_default = JoinNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/utils/SplitNode.js
var SplitNode = class extends Node_default {
  constructor(node, components = "x") {
    super();
    this.node = node;
    this.components = components;
  }
  getVectorLength() {
    let vectorLength = this.components.length;
    for (const c2 of this.components) {
      vectorLength = Math.max(vector.indexOf(c2) + 1, vectorLength);
    }
    return vectorLength;
  }
  getNodeType(builder) {
    return builder.getTypeFromLength(this.components.length);
  }
  generate(builder) {
    const node = this.node;
    const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));
    if (nodeTypeLength > 1) {
      let type2 = null;
      const componentsLength = this.getVectorLength();
      if (componentsLength >= nodeTypeLength) {
        type2 = builder.getTypeFromLength(this.getVectorLength());
      }
      const nodeSnippet = node.build(builder, type2);
      return `${nodeSnippet}.${this.components}`;
    } else {
      return node.build(builder);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.components = this.components;
  }
  deserialize(data) {
    super.deserialize(data);
    this.components = data.components;
  }
};
var SplitNode_default = SplitNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/math/OperatorNode.js
var OperatorNode = class extends TempNode_default {
  constructor(op, aNode, bNode, ...params) {
    super();
    this.op = op;
    if (params.length > 0) {
      let finalBNode = bNode;
      for (let i2 = 0; i2 < params.length; i2++) {
        finalBNode = new OperatorNode(op, finalBNode, params[i2]);
      }
      bNode = finalBNode;
    }
    this.aNode = aNode;
    this.bNode = bNode;
  }
  getNodeType(builder, output) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const typeA = aNode.getNodeType(builder);
    const typeB = bNode.getNodeType(builder);
    if (typeA === "void" || typeB === "void") {
      return "void";
    } else if (op === "=" || op === "%") {
      return typeA;
    } else if (op === "&" || op === "|" || op === "^" || op === ">>" || op === "<<") {
      return "int";
    } else if (op === "==" || op === "&&" || op === "||" || op === "^^") {
      return "bool";
    } else if (op === "<" || op === ">" || op === "<=" || op === ">=") {
      const typeLength = builder.getTypeLength(output);
      return typeLength > 1 ? `bvec${typeLength}` : "bool";
    } else {
      if (typeA === "float" && builder.isMatrix(typeB)) {
        return typeB;
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        return builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        return builder.getVectorFromMatrix(typeB);
      } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {
        return typeB;
      }
      return typeA;
    }
  }
  generate(builder, output) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const type2 = this.getNodeType(builder, output);
    let typeA = null;
    let typeB = null;
    if (type2 !== "void") {
      typeA = aNode.getNodeType(builder);
      typeB = bNode.getNodeType(builder);
      if (op === "=") {
        typeB = typeA;
      } else if (op === "<" || op === ">" || op === "<=" || op === ">=") {
        if (builder.isVector(typeA)) {
          typeB = typeA;
        } else {
          typeA = typeB = "float";
        }
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        typeB = builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        typeA = builder.getVectorFromMatrix(typeB);
      } else {
        typeA = typeB = type2;
      }
    } else {
      typeA = typeB = type2;
    }
    const a2 = aNode.build(builder, typeA);
    const b2 = bNode.build(builder, typeB);
    const outputLength = builder.getTypeLength(output);
    if (output !== "void") {
      if (op === "=") {
        builder.addFlowCode(`${a2} ${this.op} ${b2}`);
        return a2;
      } else if (op === ">" && outputLength > 1) {
        return builder.format(`${builder.getMethod("greaterThan")}( ${a2}, ${b2} )`, type2, output);
      } else if (op === "<=" && outputLength > 1) {
        return builder.format(`${builder.getMethod("lessThanEqual")}( ${a2}, ${b2} )`, type2, output);
      } else {
        return builder.format(`( ${a2} ${this.op} ${b2} )`, type2, output);
      }
    } else if (typeA !== "void") {
      return builder.format(`${a2} ${this.op} ${b2}`, type2, output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.op = this.op;
  }
  deserialize(data) {
    super.deserialize(data);
    this.op = data.op;
  }
};
var OperatorNode_default = OperatorNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/math/MathNode.js
var MathNode = class extends TempNode_default {
  constructor(method, aNode, bNode = null, cNode = null) {
    super();
    this.method = method;
    this.aNode = aNode;
    this.bNode = bNode;
    this.cNode = cNode;
  }
  getInputType(builder) {
    const aType = this.aNode.getNodeType(builder);
    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;
    const aLen = builder.getTypeLength(aType);
    const bLen = builder.getTypeLength(bType);
    const cLen = builder.getTypeLength(cType);
    if (aLen > bLen && aLen > cLen) {
      return aType;
    } else if (bLen > cLen) {
      return bType;
    } else if (cLen > aLen) {
      return cType;
    }
    return aType;
  }
  getNodeType(builder) {
    const method = this.method;
    if (method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT) {
      return "float";
    } else if (method === MathNode.CROSS) {
      return "vec3";
    } else {
      return this.getInputType(builder);
    }
  }
  generate(builder, output) {
    const method = this.method;
    const type2 = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a2 = this.aNode;
    const b2 = this.bNode;
    const c2 = this.cNode;
    const isWebGL = builder.renderer.isWebGLRenderer === true;
    if (isWebGL && (method === MathNode.DFDX || method === MathNode.DFDY) && output === "vec3") {
      return new JoinNode_default([new MathNode(method, new SplitNode_default(a2, "x")), new MathNode(method, new SplitNode_default(a2, "y")), new MathNode(method, new SplitNode_default(a2, "z"))]).build(builder);
    } else if (method === MathNode.TRANSFORM_DIRECTION) {
      let tA = a2;
      let tB = b2;
      if (builder.isMatrix(tA.getNodeType(builder))) {
        tB = new ExpressionNode_default(`${builder.getType("vec4")}( ${tB.build(builder, "vec3")}, 0.0 )`, "vec4");
      } else {
        tA = new ExpressionNode_default(`${builder.getType("vec4")}( ${tA.build(builder, "vec3")}, 0.0 )`, "vec4");
      }
      const mulNode = new SplitNode_default(new OperatorNode_default("*", tA, tB), "xyz");
      return new MathNode(MathNode.NORMALIZE, mulNode).build(builder);
    } else if (method === MathNode.SATURATE) {
      return builder.format(`clamp( ${a2.build(builder, inputType)}, 0.0, 1.0 )`, type2, output);
    } else if (method === MathNode.NEGATE) {
      return builder.format("( -" + a2.build(builder, inputType) + " )", type2, output);
    } else if (method === MathNode.INVERT) {
      return builder.format("( 1.0 - " + a2.build(builder, inputType) + " )", type2, output);
    } else {
      const params = [];
      if (method === MathNode.CROSS) {
        params.push(a2.build(builder, type2), b2.build(builder, type2));
      } else if (method === MathNode.STEP) {
        params.push(a2.build(builder, builder.getTypeLength(a2.getNodeType(builder)) === 1 ? "float" : inputType), b2.build(builder, inputType));
      } else if (isWebGL && (method === MathNode.MIN || method === MathNode.MAX) || method === MathNode.MOD) {
        params.push(a2.build(builder, inputType), b2.build(builder, builder.getTypeLength(b2.getNodeType(builder)) === 1 ? "float" : inputType));
      } else if (method === MathNode.REFRACT) {
        params.push(a2.build(builder, inputType), b2.build(builder, inputType), c2.build(builder, "float"));
      } else if (method === MathNode.MIX) {
        params.push(a2.build(builder, inputType), b2.build(builder, inputType), c2.build(builder, builder.getTypeLength(c2.getNodeType(builder)) === 1 ? "float" : inputType));
      } else {
        params.push(a2.build(builder, inputType));
        if (c2 !== null) {
          params.push(b2.build(builder, inputType), c2.build(builder, inputType));
        } else if (b2 !== null) {
          params.push(b2.build(builder, inputType));
        }
      }
      return builder.format(`${builder.getMethod(method)}( ${params.join(", ")} )`, type2, output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
_defineProperty(MathNode, "RAD", "radians");
_defineProperty(MathNode, "DEG", "degrees");
_defineProperty(MathNode, "EXP", "exp");
_defineProperty(MathNode, "EXP2", "exp2");
_defineProperty(MathNode, "LOG", "log");
_defineProperty(MathNode, "LOG2", "log2");
_defineProperty(MathNode, "SQRT", "sqrt");
_defineProperty(MathNode, "INV_SQRT", "inversesqrt");
_defineProperty(MathNode, "FLOOR", "floor");
_defineProperty(MathNode, "CEIL", "ceil");
_defineProperty(MathNode, "NORMALIZE", "normalize");
_defineProperty(MathNode, "FRACT", "fract");
_defineProperty(MathNode, "SIN", "sin");
_defineProperty(MathNode, "COS", "cos");
_defineProperty(MathNode, "TAN", "tan");
_defineProperty(MathNode, "ASIN", "asin");
_defineProperty(MathNode, "ACOS", "acos");
_defineProperty(MathNode, "ATAN", "atan");
_defineProperty(MathNode, "ABS", "abs");
_defineProperty(MathNode, "SIGN", "sign");
_defineProperty(MathNode, "LENGTH", "length");
_defineProperty(MathNode, "NEGATE", "negate");
_defineProperty(MathNode, "INVERT", "invert");
_defineProperty(MathNode, "DFDX", "dFdx");
_defineProperty(MathNode, "DFDY", "dFdy");
_defineProperty(MathNode, "SATURATE", "saturate");
_defineProperty(MathNode, "ROUND", "round");
_defineProperty(MathNode, "MIN", "min");
_defineProperty(MathNode, "MAX", "max");
_defineProperty(MathNode, "MOD", "mod");
_defineProperty(MathNode, "STEP", "step");
_defineProperty(MathNode, "REFLECT", "reflect");
_defineProperty(MathNode, "DISTANCE", "distance");
_defineProperty(MathNode, "DOT", "dot");
_defineProperty(MathNode, "CROSS", "cross");
_defineProperty(MathNode, "POW", "pow");
_defineProperty(MathNode, "TRANSFORM_DIRECTION", "transformDirection");
_defineProperty(MathNode, "MIX", "mix");
_defineProperty(MathNode, "CLAMP", "clamp");
_defineProperty(MathNode, "REFRACT", "refract");
_defineProperty(MathNode, "SMOOTHSTEP", "smoothstep");
_defineProperty(MathNode, "FACEFORWARD", "faceforward");
var MathNode_default = MathNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/accessors/PositionNode.js
var PositionNode = class extends Node_default {
  constructor(scope = PositionNode.LOCAL) {
    super("vec3");
    this.scope = scope;
  }
  getHash() {
    return `position-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    let outputNode = null;
    if (scope === PositionNode.GEOMETRY) {
      outputNode = new AttributeNode_default("position", "vec3");
    } else if (scope === PositionNode.LOCAL) {
      outputNode = new VaryNode_default(new PositionNode(PositionNode.GEOMETRY));
    } else if (scope === PositionNode.WORLD) {
      const vertexPositionNode = new MathNode_default(MathNode_default.TRANSFORM_DIRECTION, new ModelNode_default(ModelNode_default.WORLD_MATRIX), new PositionNode(PositionNode.LOCAL));
      outputNode = new VaryNode_default(vertexPositionNode);
    } else if (scope === PositionNode.VIEW) {
      const vertexPositionNode = new OperatorNode_default("*", new ModelNode_default(ModelNode_default.VIEW_MATRIX), new PositionNode(PositionNode.LOCAL));
      outputNode = new VaryNode_default(vertexPositionNode);
    } else if (scope === PositionNode.VIEW_DIRECTION) {
      const vertexPositionNode = new MathNode_default(MathNode_default.NEGATE, new PositionNode(PositionNode.VIEW));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryNode_default(vertexPositionNode));
    }
    return outputNode.build(builder, this.getNodeType(builder));
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
_defineProperty(PositionNode, "GEOMETRY", "geometry");
_defineProperty(PositionNode, "LOCAL", "local");
_defineProperty(PositionNode, "WORLD", "world");
_defineProperty(PositionNode, "VIEW", "view");
_defineProperty(PositionNode, "VIEW_DIRECTION", "viewDirection");
var PositionNode_default = PositionNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/accessors/NormalNode.js
var NormalNode = class extends Node_default {
  constructor(scope = NormalNode.LOCAL) {
    super("vec3");
    this.scope = scope;
  }
  getHash() {
    return `normal-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    let outputNode = null;
    if (scope === NormalNode.GEOMETRY) {
      outputNode = new AttributeNode_default("normal", "vec3");
    } else if (scope === NormalNode.LOCAL) {
      outputNode = new VaryNode_default(new NormalNode(NormalNode.GEOMETRY));
    } else if (scope === NormalNode.VIEW) {
      const vertexNormalNode = new OperatorNode_default("*", new ModelNode_default(ModelNode_default.NORMAL_MATRIX), new NormalNode(NormalNode.LOCAL));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryNode_default(vertexNormalNode));
    } else if (scope === NormalNode.WORLD) {
      const vertexNormalNode = new MathNode_default(MathNode_default.TRANSFORM_DIRECTION, new NormalNode(NormalNode.VIEW), new CameraNode_default(CameraNode_default.VIEW_MATRIX));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryNode_default(vertexNormalNode));
    }
    return outputNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
_defineProperty(NormalNode, "GEOMETRY", "geometry");
_defineProperty(NormalNode, "LOCAL", "local");
_defineProperty(NormalNode, "WORLD", "world");
_defineProperty(NormalNode, "VIEW", "view");
var NormalNode_default = NormalNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/math/CondNode.js
var CondNode = class extends Node_default {
  constructor(node, ifNode, elseNode) {
    super();
    this.node = node;
    this.ifNode = ifNode;
    this.elseNode = elseNode;
  }
  getNodeType(builder) {
    const ifType = this.ifNode.getNodeType(builder);
    const elseType = this.elseNode.getNodeType(builder);
    if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {
      return elseType;
    }
    return ifType;
  }
  generate(builder) {
    const type2 = this.getNodeType(builder);
    const context = {
      temp: false
    };
    const nodeProperty = new PropertyNode_default(null, type2).build(builder);
    const nodeSnippet = new ContextNode_default(
      this.node
    ).build(builder, "bool"), ifSnippet = new ContextNode_default(this.ifNode, context).build(builder, type2), elseSnippet = new ContextNode_default(this.elseNode, context).build(builder, type2);
    builder.addFlowCode(`if ( ${nodeSnippet} ) {

		${nodeProperty} = ${ifSnippet};

	} else {

		${nodeProperty} = ${elseSnippet};

	}`);
    return nodeProperty;
  }
};
var CondNode_default = CondNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/utils/ArrayElementNode.js
var ArrayElementNode = class extends Node_default {
  constructor(node, indexNode) {
    super();
    this.node = node;
    this.indexNode = indexNode;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const nodeSnippet = this.node.build(builder);
    const indexSnippet = this.indexNode.build(builder, "int");
    return `${nodeSnippet}[ ${indexSnippet} ]`;
  }
};
var ArrayElementNode_default = ArrayElementNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/utils/ConvertNode.js
var ConvertNode = class extends Node_default {
  constructor(node, convertTo) {
    super();
    this.node = node;
    this.convertTo = convertTo;
  }
  getNodeType() {
    return this.convertTo;
  }
  generate(builder) {
    const convertTo = this.convertTo;
    const node = this.node;
    if (builder.isReference(convertTo) === false) {
      const convertToSnippet = builder.getType(convertTo);
      const nodeSnippet = node.build(builder, convertTo);
      return `${builder.getVectorType(convertToSnippet)}( ${nodeSnippet} )`;
    } else {
      return node.build(builder, convertTo);
    }
  }
};
var ConvertNode_default = ConvertNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/ShaderNode.js
var NodeHandler = {
  construct(NodeClosure, params) {
    const inputs = params.shift();
    return NodeClosure(new ShaderNodeObjects(inputs), ...params);
  },
  get: function(node, prop) {
    if (typeof prop === "string" && node[prop] === void 0) {
      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {
        prop = prop.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w");
        return new ShaderNodeObject(new SplitNode_default(node, prop));
      } else if (/^\d+$/.test(prop) === true) {
        return new ShaderNodeObject(new ArrayElementNode_default(node, uint(Number(prop))));
      }
    }
    return node[prop];
  }
};
var nodeObjects = /* @__PURE__ */ new WeakMap();
var ShaderNodeObject = function(obj) {
  const type2 = typeof obj;
  if (type2 === "number" || type2 === "boolean") {
    return new ShaderNodeObject(getAutoTypedConstNode(obj));
  } else if (type2 === "object") {
    if (obj.isNode === true) {
      let nodeObject2 = nodeObjects.get(obj);
      if (nodeObject2 === void 0) {
        nodeObject2 = new Proxy(obj, NodeHandler);
        nodeObjects.set(obj, nodeObject2);
        nodeObjects.set(nodeObject2, nodeObject2);
      }
      return nodeObject2;
    }
  }
  return obj;
};
var ShaderNodeObjects = function(objects) {
  for (const name in objects) {
    objects[name] = new ShaderNodeObject(objects[name]);
  }
  return objects;
};
var getShaderNodeArray = (array) => {
  const len = array.length;
  for (let i2 = 0; i2 < len; i2++) {
    array[i2] = new ShaderNodeObject(array[i2]);
  }
  return array;
};
var ShaderNodeProxy = function(NodeClass, scope = null, factor = null) {
  if (scope === null) {
    return (...params) => {
      return new ShaderNodeObject(new NodeClass(...getShaderNodeArray(params)));
    };
  } else if (factor === null) {
    return (...params) => {
      return new ShaderNodeObject(new NodeClass(scope, ...getShaderNodeArray(params)));
    };
  } else {
    factor = new ShaderNodeObject(factor);
    return (...params) => {
      return new ShaderNodeObject(new NodeClass(scope, ...getShaderNodeArray(params), factor));
    };
  }
};
var ShaderNodeScript = function(jsFunc) {
  return (inputs, builder) => {
    new ShaderNodeObjects(inputs);
    return new ShaderNodeObject(jsFunc(inputs, builder));
  };
};
var bools = [false, true];
var uints = [0, 1, 2, 3];
var ints = [-1, -2];
var floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];
var boolsCacheMap = /* @__PURE__ */ new Map();
for (let bool2 of bools)
  boolsCacheMap.set(bool2, new ConstNode_default(bool2));
var uintsCacheMap = /* @__PURE__ */ new Map();
for (let uint2 of uints)
  uintsCacheMap.set(uint2, new ConstNode_default(uint2, "uint"));
var intsCacheMap = new Map([...uintsCacheMap].map((el) => new ConstNode_default(el.value, "int")));
for (let int2 of ints)
  intsCacheMap.set(int2, new ConstNode_default(int2, "int"));
var floatsCacheMap = new Map([...intsCacheMap].map((el) => new ConstNode_default(el.value)));
for (let float2 of floats)
  floatsCacheMap.set(float2, new ConstNode_default(float2));
for (let float2 of floats)
  floatsCacheMap.set(-float2, new ConstNode_default(-float2));
var constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);
var getAutoTypedConstNode = (value) => {
  if (constNodesCacheMap.has(value)) {
    return constNodesCacheMap.get(value);
  } else if (value.isNode === true) {
    return value;
  } else {
    return new ConstNode_default(value);
  }
};
var ConvertType = function(type2, cacheMap = null) {
  return (...params) => {
    if (params.length === 0) {
      return nodeObject(new ConstNode_default(getValueFromType(type2), type2));
    } else {
      if (type2 === "color" && params[0].isNode !== true) {
        params = [getValueFromType(type2, ...params)];
      }
      if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {
        return cacheMap.get(params[0]);
      }
      const nodes = params.map(getAutoTypedConstNode);
      return nodeObject(new ConvertNode_default(nodes.length === 1 ? nodes[0] : new JoinNode_default(nodes), type2));
    }
  };
};
var ShaderNode = new Proxy(ShaderNodeScript, NodeHandler);
var nodeObject = (val) => {
  return new ShaderNodeObject(val);
};
var color2 = new ConvertType("color");
var float = new ConvertType("float", floatsCacheMap);
var int = new ConvertType("int", intsCacheMap);
var uint = new ConvertType("uint", uintsCacheMap);
var bool = new ConvertType("bool", boolsCacheMap);
var vec2 = new ConvertType("vec2");
var ivec2 = new ConvertType("ivec2");
var uvec2 = new ConvertType("uvec2");
var bvec2 = new ConvertType("bvec2");
var vec3 = new ConvertType("vec3");
var ivec3 = new ConvertType("ivec3");
var uvec3 = new ConvertType("uvec3");
var bvec3 = new ConvertType("bvec3");
var vec4 = new ConvertType("vec4");
var ivec4 = new ConvertType("ivec4");
var uvec4 = new ConvertType("uvec4");
var bvec4 = new ConvertType("bvec4");
var mat3 = new ConvertType("mat3");
var imat3 = new ConvertType("imat3");
var umat3 = new ConvertType("umat3");
var bmat3 = new ConvertType("bmat3");
var mat4 = new ConvertType("mat4");
var imat4 = new ConvertType("imat4");
var umat4 = new ConvertType("umat4");
var bmat4 = new ConvertType("bmat4");
var join = (...params) => nodeObject(new JoinNode_default(getShaderNodeArray(params)));
var cond = (...params) => nodeObject(new CondNode_default(...getShaderNodeArray(params)));
var addTo = (varNode, ...params) => {
  varNode.node = add(varNode.node, ...getShaderNodeArray(params));
  return nodeObject(varNode);
};
var add = new ShaderNodeProxy(OperatorNode_default, "+");
var sub = new ShaderNodeProxy(OperatorNode_default, "-");
var mul = new ShaderNodeProxy(OperatorNode_default, "*");
var div = new ShaderNodeProxy(OperatorNode_default, "/");
var remainder = new ShaderNodeProxy(OperatorNode_default, "%");
var equal = new ShaderNodeProxy(OperatorNode_default, "==");
var assign = new ShaderNodeProxy(OperatorNode_default, "=");
var lessThan = new ShaderNodeProxy(OperatorNode_default, "<");
var greaterThan = new ShaderNodeProxy(OperatorNode_default, ">");
var lessThanEqual = new ShaderNodeProxy(OperatorNode_default, "<=");
var greaterThanEqual = new ShaderNodeProxy(OperatorNode_default, ">=");
var and = new ShaderNodeProxy(OperatorNode_default, "&&");
var or = new ShaderNodeProxy(OperatorNode_default, "||");
var xor = new ShaderNodeProxy(OperatorNode_default, "^^");
var bitAnd = new ShaderNodeProxy(OperatorNode_default, "&");
var bitOr = new ShaderNodeProxy(OperatorNode_default, "|");
var bitXor = new ShaderNodeProxy(OperatorNode_default, "^");
var shiftLeft = new ShaderNodeProxy(OperatorNode_default, "<<");
var shiftRight = new ShaderNodeProxy(OperatorNode_default, ">>");
var element = new ShaderNodeProxy(ArrayElementNode_default);
var normalGeometry = new ShaderNodeObject(new NormalNode_default(NormalNode_default.GEOMETRY));
var normalLocal = new ShaderNodeObject(new NormalNode_default(NormalNode_default.LOCAL));
var normalWorld = new ShaderNodeObject(new NormalNode_default(NormalNode_default.WORLD));
var normalView = new ShaderNodeObject(new NormalNode_default(NormalNode_default.VIEW));
var transformedNormalView = new ShaderNodeObject(new VarNode_default(new NormalNode_default(NormalNode_default.VIEW), "TransformedNormalView", "vec3"));
var positionLocal = new ShaderNodeObject(new PositionNode_default(PositionNode_default.LOCAL));
var positionWorld = new ShaderNodeObject(new PositionNode_default(PositionNode_default.WORLD));
var positionView = new ShaderNodeObject(new PositionNode_default(PositionNode_default.VIEW));
var positionViewDirection = new ShaderNodeObject(new PositionNode_default(PositionNode_default.VIEW_DIRECTION));
var viewMatrix = new ShaderNodeObject(new ModelNode_default(ModelNode_default.VIEW_MATRIX));
var cameraPosition = new ShaderNodeObject(new CameraNode_default(CameraNode_default.POSITION));
var diffuseColor = new ShaderNodeObject(new PropertyNode_default("DiffuseColor", "vec4"));
var roughness = new ShaderNodeObject(new PropertyNode_default("Roughness", "float"));
var metalness = new ShaderNodeObject(new PropertyNode_default("Metalness", "float"));
var alphaTest = new ShaderNodeObject(new PropertyNode_default("AlphaTest", "float"));
var specularColor = new ShaderNodeObject(new PropertyNode_default("SpecularColor", "color"));
var abs = new ShaderNodeProxy(MathNode_default, "abs");
var acos = new ShaderNodeProxy(MathNode_default, "acos");
var asin = new ShaderNodeProxy(MathNode_default, "asin");
var atan = new ShaderNodeProxy(MathNode_default, "atan");
var ceil = new ShaderNodeProxy(MathNode_default, "ceil");
var clamp = new ShaderNodeProxy(MathNode_default, "clamp");
var cos = new ShaderNodeProxy(MathNode_default, "cos");
var cross = new ShaderNodeProxy(MathNode_default, "cross");
var degrees = new ShaderNodeProxy(MathNode_default, "degrees");
var dFdx = new ShaderNodeProxy(MathNode_default, "dFdx");
var dFdy = new ShaderNodeProxy(MathNode_default, "dFdy");
var distance = new ShaderNodeProxy(MathNode_default, "distance");
var dot = new ShaderNodeProxy(MathNode_default, "dot");
var exp = new ShaderNodeProxy(MathNode_default, "exp");
var exp2 = new ShaderNodeProxy(MathNode_default, "exp2");
var faceforward = new ShaderNodeProxy(MathNode_default, "faceforward");
var floor = new ShaderNodeProxy(MathNode_default, "floor");
var fract = new ShaderNodeProxy(MathNode_default, "fract");
var invert = new ShaderNodeProxy(MathNode_default, "invert");
var inversesqrt = new ShaderNodeProxy(MathNode_default, "inversesqrt");
var length = new ShaderNodeProxy(MathNode_default, "length");
var log = new ShaderNodeProxy(MathNode_default, "log");
var log2 = new ShaderNodeProxy(MathNode_default, "log2");
var max = new ShaderNodeProxy(MathNode_default, "max");
var min = new ShaderNodeProxy(MathNode_default, "min");
var mix = new ShaderNodeProxy(MathNode_default, "mix");
var mod = new ShaderNodeProxy(MathNode_default, "mod");
var negate = new ShaderNodeProxy(MathNode_default, "negate");
var normalize = new ShaderNodeProxy(MathNode_default, "normalize");
var pow = new ShaderNodeProxy(MathNode_default, "pow");
var pow2 = new ShaderNodeProxy(MathNode_default, "pow", 2);
var pow3 = new ShaderNodeProxy(MathNode_default, "pow", 3);
var pow4 = new ShaderNodeProxy(MathNode_default, "pow", 4);
var radians = new ShaderNodeProxy(MathNode_default, "radians");
var reflect = new ShaderNodeProxy(MathNode_default, "reflect");
var refract = new ShaderNodeProxy(MathNode_default, "refract");
var round = new ShaderNodeProxy(MathNode_default, "round");
var saturate = new ShaderNodeProxy(MathNode_default, "saturate");
var sign = new ShaderNodeProxy(MathNode_default, "sign");
var sin = new ShaderNodeProxy(MathNode_default, "sin");
var smoothstep = new ShaderNodeProxy(MathNode_default, "smoothstep");
var sqrt = new ShaderNodeProxy(MathNode_default, "sqrt");
var step = new ShaderNodeProxy(MathNode_default, "step");
var tan = new ShaderNodeProxy(MathNode_default, "tan");
var transformDirection = new ShaderNodeProxy(MathNode_default, "transformDirection");
var EPSILON = float(1e-6);
var INFINITY = float(1e6);

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/accessors/ReflectNode.js
var ReflectNode = class extends Node_default {
  constructor(scope = ReflectNode.CUBE) {
    super("vec3");
    this.scope = scope;
  }
  getHash() {
    return `reflect-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === ReflectNode.VECTOR) {
      const cameraToFrag = normalize(sub(positionWorld, cameraPosition));
      const reflectVec = reflect(cameraToFrag, normalWorld);
      return reflectVec.build(builder);
    } else if (scope === ReflectNode.CUBE) {
      const reflectVec = nodeObject(new ReflectNode(ReflectNode.VECTOR));
      const cubeUV = join(negate(reflectVec.x), reflectVec.yz);
      return cubeUV.build(builder);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
_defineProperty(ReflectNode, "VECTOR", "vector");
_defineProperty(ReflectNode, "CUBE", "cube");
var ReflectNode_default = ReflectNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/accessors/CubeTextureNode.js
var CubeTextureNode = class extends TextureNode_default {
  constructor(value, uvNode = new ReflectNode_default(), biasNode = null) {
    super(value, uvNode, biasNode);
  }
  getInputType() {
    return "cubeTexture";
  }
  generate(builder, output) {
    const texture2 = this.value;
    if (!texture2 || texture2.isCubeTexture !== true) {
      throw new Error("CubeTextureNode: Need a three.js cube texture.");
    }
    const textureProperty = UniformNode_default.prototype.generate.call(this, builder, "cubeTexture");
    if (output === "sampler") {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output)) {
      return textureProperty;
    } else {
      const nodeData = builder.getDataFromNode(this);
      let snippet = nodeData.snippet;
      if (snippet === void 0) {
        const uvSnippet = this.uvNode.build(builder, "vec3");
        const biasNode = this.biasNode;
        if (biasNode !== null) {
          const biasSnippet = biasNode.build(builder, "float");
          snippet = builder.getCubeTextureBias(textureProperty, uvSnippet, biasSnippet);
        } else {
          snippet = builder.getCubeTexture(textureProperty, uvSnippet);
        }
        nodeData.snippet = snippet;
      }
      return builder.format(snippet, "vec4", output);
    }
  }
};
CubeTextureNode.prototype.isCubeTextureNode = true;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/accessors/ReferenceNode.js
var ReferenceNode = class extends Node_default {
  constructor(property, uniformType, object = null) {
    super();
    this.property = property;
    this.uniformType = uniformType;
    this.object = object;
    this.node = null;
    this.updateType = NodeUpdateType.Object;
    this.setNodeType(uniformType);
  }
  setNodeType(uniformType) {
    this.node = new UniformNode_default(null, uniformType);
    this.nodeType = uniformType;
    if (uniformType === "color") {
      this.nodeType = "vec3";
    } else if (uniformType === "texture") {
      this.nodeType = "vec4";
    }
  }
  getNodeType() {
    return this.uniformType;
  }
  update(frame) {
    const object = this.object !== null ? this.object : frame.object;
    const value = object[this.property];
    this.node.value = value;
  }
  generate(builder) {
    return this.node.build(builder, this.getNodeType(builder));
  }
};
var ReferenceNode_default = ReferenceNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/accessors/MaterialReferenceNode.js
var MaterialReferenceNode = class extends ReferenceNode_default {
  constructor(property, inputType, material = null) {
    super(property, inputType, material);
    this.material = material;
  }
  update(frame) {
    this.object = this.material !== null ? this.material : frame.material;
    super.update(frame);
  }
};
var MaterialReferenceNode_default = MaterialReferenceNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/accessors/MaterialNode.js
var MaterialNode = class extends Node_default {
  constructor(scope = MaterialNode.COLOR) {
    super();
    this.scope = scope;
  }
  getNodeType(builder) {
    const scope = this.scope;
    const material = builder.context.material;
    if (scope === MaterialNode.COLOR) {
      return material.map !== null ? "vec4" : "vec3";
    } else if (scope === MaterialNode.OPACITY) {
      return "float";
    } else if (scope === MaterialNode.SPECULAR) {
      return "vec3";
    } else if (scope === MaterialNode.ROUGHNESS || scope === MaterialNode.METALNESS) {
      return "float";
    }
  }
  generate(builder, output) {
    const material = builder.context.material;
    const scope = this.scope;
    let node = null;
    if (scope === MaterialNode.ALPHA_TEST) {
      node = new MaterialReferenceNode_default("alphaTest", "float");
    } else if (scope === MaterialNode.COLOR) {
      const colorNode = new MaterialReferenceNode_default("color", "color");
      if (material.map !== null && material.map !== void 0 && material.map.isTexture === true) {
        node = new OperatorNode_default("*", colorNode, new MaterialReferenceNode_default("map", "texture"));
      } else {
        node = colorNode;
      }
    } else if (scope === MaterialNode.OPACITY) {
      const opacityNode = new MaterialReferenceNode_default("opacity", "float");
      if (material.alphaMap !== null && material.alphaMap !== void 0 && material.alphaMap.isTexture === true) {
        node = new OperatorNode_default("*", opacityNode, new MaterialReferenceNode_default("alphaMap", "texture"));
      } else {
        node = opacityNode;
      }
    } else if (scope === MaterialNode.SPECULAR) {
      const specularColorNode = new MaterialReferenceNode_default("specularColor", "color");
      if (material.specularColorMap !== null && material.specularColorMap !== void 0 && material.specularColorMap.isTexture === true) {
        node = new OperatorNode_default("*", specularColorNode, new MaterialReferenceNode_default("specularColorMap", "texture"));
      } else {
        node = specularColorNode;
      }
    } else {
      const outputType = this.getNodeType(builder);
      node = new MaterialReferenceNode_default(scope, outputType);
    }
    return node.build(builder, output);
  }
};
_defineProperty(MaterialNode, "ALPHA_TEST", "alphaTest");
_defineProperty(MaterialNode, "COLOR", "color");
_defineProperty(MaterialNode, "OPACITY", "opacity");
_defineProperty(MaterialNode, "SPECULAR", "specular");
_defineProperty(MaterialNode, "ROUGHNESS", "roughness");
_defineProperty(MaterialNode, "METALNESS", "metalness");

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/accessors/PointUVNode.js
var PointUVNode = class extends Node_default {
  constructor() {
    super("vec2");
  }
  generate() {
    return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
  }
};
PointUVNode.prototype.isPointUVNode = true;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/accessors/SkinningNode.js
var Skinning = new ShaderNode((inputs, builder) => {
  const {
    index,
    weight,
    bindMatrix,
    bindMatrixInverse,
    boneMatrices
  } = inputs;
  const boneMatX = element(boneMatrices, index.x);
  const boneMatY = element(boneMatrices, index.y);
  const boneMatZ = element(boneMatrices, index.z);
  const boneMatW = element(boneMatrices, index.w);
  const skinVertex = mul(bindMatrix, positionLocal);
  const skinned = add(mul(mul(boneMatX, skinVertex), weight.x), mul(mul(boneMatY, skinVertex), weight.y), mul(mul(boneMatZ, skinVertex), weight.z), mul(mul(boneMatW, skinVertex), weight.w));
  const skinPosition = mul(bindMatrixInverse, skinned).xyz;
  let skinMatrix = add(mul(weight.x, boneMatX), mul(weight.y, boneMatY), mul(weight.z, boneMatZ), mul(weight.w, boneMatW));
  skinMatrix = mul(mul(bindMatrixInverse, skinMatrix), bindMatrix);
  const skinNormal = transformDirection(skinMatrix, normalLocal).xyz;
  assign(positionLocal, skinPosition).build(builder);
  assign(normalLocal, skinNormal).build(builder);
});

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/display/ColorSpaceNode.js
var LinearToLinear = new ShaderNode((inputs) => {
  return inputs.value;
});
var LinearTosRGB = new ShaderNode((inputs) => {
  const {
    value
  } = inputs;
  const rgb = value.rgb;
  const a2 = sub(mul(pow(value.rgb, vec3(0.41666)), 1.055), vec3(0.055));
  const b2 = mul(rgb, 12.92);
  const factor = vec3(lessThanEqual(rgb, vec3(31308e-7)));
  const rgbResult = mix(a2, b2, factor);
  return join(rgbResult.r, rgbResult.g, rgbResult.b, value.a);
});
var EncodingLib = {
  LinearToLinear,
  LinearTosRGB
};
var ColorSpaceNode = class extends Node_default {
  constructor(method, node) {
    super("vec4");
    this.method = method;
    this.node = node;
  }
  fromEncoding(encoding) {
    let method = null;
    if (encoding === LinearEncoding) {
      method = "Linear";
    } else if (encoding === sRGBEncoding) {
      method = "sRGB";
    }
    this.method = "LinearTo" + method;
    return this;
  }
  generate(builder) {
    const type2 = this.getNodeType(builder);
    const method = this.method;
    const node = this.node;
    if (method !== ColorSpaceNode.LINEAR_TO_LINEAR) {
      const encodingFunctionNode = EncodingLib[method];
      return encodingFunctionNode({
        value: node
      }).build(builder, type2);
    } else {
      return node.build(builder, type2);
    }
  }
};
_defineProperty(ColorSpaceNode, "LINEAR_TO_LINEAR", "LinearToLinear");
_defineProperty(ColorSpaceNode, "LINEAR_TO_SRGB", "LinearTosRGB");

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/display/NormalMapNode.js
var perturbNormal2ArbNode = new ShaderNode((inputs) => {
  const {
    eye_pos,
    surf_norm,
    mapN,
    faceDirection,
    uv: uv2
  } = inputs;
  const q0 = dFdx(eye_pos.xyz);
  const q1 = dFdy(eye_pos.xyz);
  const st0 = dFdx(uv2.st);
  const st1 = dFdy(uv2.st);
  const N = surf_norm;
  const q1perp = cross(q1, N);
  const q0perp = cross(N, q0);
  const T2 = add(mul(q1perp, st0.x), mul(q0perp, st1.x));
  const B = add(mul(q1perp, st0.y), mul(q0perp, st1.y));
  const det = max(dot(T2, T2), dot(B, B));
  const scale = cond(equal(det, 0), 0, mul(faceDirection, inversesqrt(det)));
  return normalize(add(mul(T2, mul(mapN.x, scale)), mul(B, mul(mapN.y, scale)), mul(N, mapN.z)));
});

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/functions/BSDFs.js
var F_Schlick = new ShaderNode((inputs) => {
  const {
    f0,
    f90,
    dotVH
  } = inputs;
  const fresnel = exp2(mul(sub(mul(-5.55473, dotVH), 6.98316), dotVH));
  return add(mul(f0, sub(1, fresnel)), mul(f90, fresnel));
});
var BRDF_Lambert = new ShaderNode((inputs) => {
  return mul(1 / Math.PI, inputs.diffuseColor);
});
var getDistanceAttenuation = new ShaderNode((inputs) => {
  const {
    lightDistance,
    cutoffDistance,
    decayExponent
  } = inputs;
  return cond(and(greaterThan(cutoffDistance, 0), greaterThan(decayExponent, 0)), pow(saturate(add(div(negate(lightDistance), cutoffDistance), 1)), decayExponent), 1);
});
var V_GGX_SmithCorrelated = new ShaderNode((inputs) => {
  const {
    alpha,
    dotNL,
    dotNV
  } = inputs;
  const a2 = pow2(alpha);
  const gv = mul(dotNL, sqrt(add(a2, mul(sub(1, a2), pow2(dotNV)))));
  const gl = mul(dotNV, sqrt(add(a2, mul(sub(1, a2), pow2(dotNL)))));
  return div(0.5, max(add(gv, gl), EPSILON));
});
var D_GGX = new ShaderNode((inputs) => {
  const {
    alpha,
    dotNH
  } = inputs;
  const a2 = pow2(alpha);
  const denom = add(mul(pow2(dotNH), sub(a2, 1)), 1);
  return mul(1 / Math.PI, div(a2, pow2(denom)));
});
var BRDF_GGX = new ShaderNode((inputs) => {
  const {
    lightDirection,
    f0,
    f90,
    roughness: roughness2
  } = inputs;
  const alpha = pow2(roughness2);
  const halfDir = normalize(add(lightDirection, positionViewDirection));
  const dotNL = saturate(dot(transformedNormalView, lightDirection));
  const dotNV = saturate(dot(transformedNormalView, positionViewDirection));
  const dotNH = saturate(dot(transformedNormalView, halfDir));
  const dotVH = saturate(dot(positionViewDirection, halfDir));
  const F = F_Schlick({
    f0,
    f90,
    dotVH
  });
  const V = V_GGX_SmithCorrelated({
    alpha,
    dotNL,
    dotNV
  });
  const D = D_GGX({
    alpha,
    dotNH
  });
  return mul(F, mul(V, D));
});
var RE_Direct_Physical = new ShaderNode((inputs) => {
  const {
    lightDirection,
    lightColor,
    directDiffuse,
    directSpecular
  } = inputs;
  const dotNL = saturate(dot(transformedNormalView, lightDirection));
  let irradiance = mul(dotNL, lightColor);
  irradiance = mul(irradiance, Math.PI);
  addTo(directDiffuse, mul(irradiance, BRDF_Lambert({
    diffuseColor: diffuseColor.rgb
  })));
  addTo(directSpecular, mul(irradiance, BRDF_GGX({
    lightDirection,
    f0: specularColor,
    f90: 1,
    roughness
  })));
});
var PhysicalLightingModel = new ShaderNode((inputs) => {
  RE_Direct_Physical(inputs);
});

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/utils/TimerNode.js
var TimerNode = class extends UniformNode_default {
  constructor(scope = TimerNode.LOCAL) {
    super(0);
    this.scope = scope;
    this.scale = 1;
    this.updateType = NodeUpdateType.Frame;
  }
  update(frame) {
    const scope = this.scope;
    const scale = this.scale;
    if (scope === TimerNode.LOCAL) {
      this.value += frame.deltaTime * scale;
    } else if (scope === TimerNode.DELTA) {
      this.value = frame.deltaTime * scale;
    } else {
      this.value = frame.time * scale;
    }
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
    data.scale = this.scale;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
    this.scale = data.scale;
  }
};
_defineProperty(TimerNode, "LOCAL", "local");
_defineProperty(TimerNode, "GLOBAL", "global");
_defineProperty(TimerNode, "DELTA", "delta");
var TimerNode_default = TimerNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/utils/OscNode.js
var OscNode = class extends Node_default {
  constructor(method = OscNode.SINE, timeNode = new TimerNode_default()) {
    super();
    this.method = method;
    this.timeNode = timeNode;
  }
  getNodeType(builder) {
    return this.timeNode.getNodeType(builder);
  }
  generate(builder) {
    const method = this.method;
    const timeNode = this.timeNode;
    let outputNode = null;
    if (method === OscNode.SINE) {
      outputNode = add(mul(sin(mul(add(timeNode, 0.75), Math.PI * 2)), 0.5), 0.5);
    } else if (method === OscNode.SQUARE) {
      outputNode = round(fract(timeNode));
    } else if (method === OscNode.TRIANGLE) {
      outputNode = abs(sub(1, mul(fract(add(timeNode, 0.5)), 2)));
    } else if (method === OscNode.SAWTOOTH) {
      outputNode = fract(timeNode);
    }
    return outputNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
_defineProperty(OscNode, "SINE", "sine");
_defineProperty(OscNode, "SQUARE", "square");
_defineProperty(OscNode, "TRIANGLE", "triangle");
_defineProperty(OscNode, "SAWTOOTH", "sawtooth");

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/procedural/CheckerNode.js
var checkerShaderNode = new ShaderNode((inputs) => {
  const uv2 = mul(inputs.uv, 2);
  const cx = floor(uv2.x);
  const cy = floor(uv2.y);
  const result = mod(add(cx, cy), 2);
  return sign(result);
});

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/fog/FogNode.js
var FogNode = class extends Node_default {
  constructor(colorNode, factorNode) {
    super("float");
    this.colorNode = colorNode;
    this.factorNode = factorNode;
  }
  generate(builder) {
    return this.factorNode.build(builder, "float");
  }
};
FogNode.prototype.isFogNode = true;
var FogNode_default = FogNode;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/fog/FogRangeNode.js
var FogRangeNode = class extends FogNode_default {
  constructor(colorNode, nearNode, farNode) {
    super(colorNode);
    this.nearNode = nearNode;
    this.farNode = farNode;
  }
  generate(builder) {
    this.factorNode = smoothstep(this.nearNode, this.farNode, negate(positionView.z));
    return super.generate(builder);
  }
};
FogRangeNode.prototype.isFogRangeNode = true;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/exporters/GLTFExporter.js
var GLTFExporter = class {
  constructor() {
    _defineProperty(this, "pluginCallbacks", void 0);
    this.pluginCallbacks = [];
    this.register(function(writer) {
      return new GLTFLightExtension(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsUnlitExtension(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsPBRSpecularGlossiness(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsTransmissionExtension(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsVolumeExtension(writer);
    });
  }
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback);
    }
    return this;
  }
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
    }
    return this;
  }
  parse(input, onDone, options) {
    const writer = new GLTFWriter();
    const plugins = [];
    for (let i2 = 0, il = this.pluginCallbacks.length; i2 < il; i2++) {
      plugins.push(this.pluginCallbacks[i2](writer));
    }
    writer.setPlugins(plugins);
    writer.write(input, onDone, options);
  }
};
_defineProperty(GLTFExporter, "Utils", {
  insertKeyframe: function(track, time) {
    const tolerance = 1e-3;
    const valueSize = track.getValueSize();
    const times = new track.TimeBufferType(track.times.length + 1);
    const values = new track.ValueBufferType(track.values.length + valueSize);
    const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));
    let index;
    if (track.times.length === 0) {
      times[0] = time;
      for (let i2 = 0; i2 < valueSize; i2++) {
        values[i2] = 0;
      }
      index = 0;
    } else if (time < track.times[0]) {
      if (Math.abs(track.times[0] - time) < tolerance)
        return 0;
      times[0] = time;
      times.set(track.times, 1);
      values.set(interpolant.evaluate(time), 0);
      values.set(track.values, valueSize);
      index = 0;
    } else if (time > track.times[track.times.length - 1]) {
      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {
        return track.times.length - 1;
      }
      times[times.length - 1] = time;
      times.set(track.times, 0);
      values.set(track.values, 0);
      values.set(interpolant.evaluate(time), track.values.length);
      index = times.length - 1;
    } else {
      for (let i2 = 0; i2 < track.times.length; i2++) {
        if (Math.abs(track.times[i2] - time) < tolerance)
          return i2;
        if (track.times[i2] < time && track.times[i2 + 1] > time) {
          times.set(track.times.slice(0, i2 + 1), 0);
          times[i2 + 1] = time;
          times.set(track.times.slice(i2 + 1), i2 + 2);
          values.set(track.values.slice(0, (i2 + 1) * valueSize), 0);
          values.set(interpolant.evaluate(time), (i2 + 1) * valueSize);
          values.set(track.values.slice((i2 + 1) * valueSize), (i2 + 2) * valueSize);
          index = i2 + 1;
          break;
        }
      }
    }
    track.times = times;
    track.values = values;
    return index;
  },
  mergeMorphTargetTracks: function(clip, root) {
    const tracks = [];
    const mergedTracks = {};
    const sourceTracks = clip.tracks;
    for (let i2 = 0; i2 < sourceTracks.length; ++i2) {
      let sourceTrack = sourceTracks[i2];
      const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);
      const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);
      if (sourceTrackBinding.propertyName !== "morphTargetInfluences" || sourceTrackBinding.propertyIndex === void 0) {
        tracks.push(sourceTrack);
        continue;
      }
      if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {
        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
          throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
        }
        console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.");
        sourceTrack = sourceTrack.clone();
        sourceTrack.setInterpolation(InterpolateLinear);
      }
      const targetCount = sourceTrackNode.morphTargetInfluences.length;
      const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];
      if (targetIndex === void 0) {
        throw new Error("THREE.GLTFExporter: Morph target name not found: " + sourceTrackBinding.propertyIndex);
      }
      let mergedTrack;
      if (mergedTracks[sourceTrackNode.uuid] === void 0) {
        mergedTrack = sourceTrack.clone();
        const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);
        for (let j2 = 0; j2 < mergedTrack.times.length; j2++) {
          values[j2 * targetCount + targetIndex] = mergedTrack.values[j2];
        }
        mergedTrack.name = (sourceTrackBinding.nodeName || "") + ".morphTargetInfluences";
        mergedTrack.values = values;
        mergedTracks[sourceTrackNode.uuid] = mergedTrack;
        tracks.push(mergedTrack);
        continue;
      }
      const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));
      mergedTrack = mergedTracks[sourceTrackNode.uuid];
      for (let j2 = 0; j2 < mergedTrack.times.length; j2++) {
        mergedTrack.values[j2 * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j2]);
      }
      for (let j2 = 0; j2 < sourceTrack.times.length; j2++) {
        const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j2]);
        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j2];
      }
    }
    clip.tracks = tracks;
    return clip;
  }
});
var WEBGL_CONSTANTS = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123,
  FLOAT: 5126,
  UNSIGNED_INT: 5125,
  ARRAY_BUFFER: 34962,
  ELEMENT_ARRAY_BUFFER: 34963,
  NEAREST: 9728,
  LINEAR: 9729,
  NEAREST_MIPMAP_NEAREST: 9984,
  LINEAR_MIPMAP_NEAREST: 9985,
  NEAREST_MIPMAP_LINEAR: 9986,
  LINEAR_MIPMAP_LINEAR: 9987,
  CLAMP_TO_EDGE: 33071,
  MIRRORED_REPEAT: 33648,
  REPEAT: 10497
};
var THREE_TO_WEBGL = {};
THREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;
THREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;
THREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;
THREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;
THREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;
THREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;
THREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;
THREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;
THREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;
var PATH_PROPERTIES = {
  scale: "scale",
  position: "translation",
  quaternion: "rotation",
  morphTargetInfluences: "weights"
};
var GLB_HEADER_BYTES = 12;
var GLB_HEADER_MAGIC = 1179937895;
var GLB_VERSION = 2;
var GLB_CHUNK_PREFIX_BYTES = 8;
var GLB_CHUNK_TYPE_JSON = 1313821514;
var GLB_CHUNK_TYPE_BIN = 5130562;
var GLTFWriter = class {
  constructor() {
    _defineProperty(this, "plugins", void 0);
    _defineProperty(this, "options", void 0);
    _defineProperty(this, "pending", void 0);
    _defineProperty(this, "buffers", void 0);
    _defineProperty(this, "byteOffset", void 0);
    _defineProperty(this, "nodeMap", void 0);
    _defineProperty(this, "skins", void 0);
    _defineProperty(this, "extensionsUsed", void 0);
    _defineProperty(this, "uids", void 0);
    _defineProperty(this, "uid", void 0);
    _defineProperty(this, "json", void 0);
    _defineProperty(this, "cache", void 0);
    _defineProperty(this, "cachedCanvas", void 0);
    this.plugins = [];
    this.options = {};
    this.pending = [];
    this.buffers = [];
    this.byteOffset = 0;
    this.nodeMap = /* @__PURE__ */ new Map();
    this.skins = [];
    this.extensionsUsed = {};
    this.uids = /* @__PURE__ */ new Map();
    this.uid = 0;
    this.json = {
      asset: {
        version: "2.0",
        generator: "THREE.GLTFExporter"
      }
    };
    this.cache = {
      meshes: /* @__PURE__ */ new Map(),
      attributes: /* @__PURE__ */ new Map(),
      attributesNormalized: /* @__PURE__ */ new Map(),
      materials: /* @__PURE__ */ new Map(),
      textures: /* @__PURE__ */ new Map(),
      images: /* @__PURE__ */ new Map()
    };
    this.cachedCanvas = null;
  }
  setPlugins(plugins) {
    this.plugins = plugins;
  }
  write(input, onDone, options) {
    this.options = Object.assign({}, {
      binary: false,
      trs: false,
      onlyVisible: true,
      truncateDrawRange: true,
      embedImages: true,
      maxTextureSize: Infinity,
      animations: [],
      includeCustomExtensions: false
    }, options);
    if (this.options.animations !== void 0 && this.options.animations.length > 0) {
      this.options.trs = true;
    }
    this.processInput(input);
    const writer = this;
    Promise.all(this.pending).then(() => {
      const buffers = writer.buffers;
      const json = writer.json;
      const options2 = writer.options;
      const extensionsUsed = writer.extensionsUsed;
      const blob = new Blob(buffers, {
        type: "application/octet-stream"
      });
      const extensionsUsedList = Object.keys(extensionsUsed);
      if (extensionsUsedList.length > 0)
        json.extensionsUsed = extensionsUsedList;
      if (json.buffers && json.buffers.length > 0)
        json.buffers[0].byteLength = blob.size;
      if (options2.binary) {
        const reader = new window.FileReader();
        reader.readAsArrayBuffer(blob);
        reader.onloadend = () => {
          if (reader.result !== null && typeof reader.result !== "string") {
            const binaryChunk = this.getPaddedArrayBuffer(reader.result);
            const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
            binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);
            binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);
            const jsonChunk = this.getPaddedArrayBuffer(this.stringToArrayBuffer(JSON.stringify(json)), 32);
            const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
            jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);
            jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);
            const header = new ArrayBuffer(GLB_HEADER_BYTES);
            const headerView = new DataView(header);
            headerView.setUint32(0, GLB_HEADER_MAGIC, true);
            headerView.setUint32(4, GLB_VERSION, true);
            const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;
            headerView.setUint32(8, totalByteLength, true);
            const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {
              type: "application/octet-stream"
            });
            const glbReader = new window.FileReader();
            glbReader.readAsArrayBuffer(glbBlob);
            glbReader.onloadend = function() {
              if (glbReader.result !== null && typeof glbReader.result !== "string") {
                onDone(glbReader.result);
              }
            };
          }
        };
      } else {
        if (json.buffers && json.buffers.length > 0) {
          const reader = new window.FileReader();
          reader.readAsDataURL(blob);
          reader.onloadend = function() {
            const base64data = reader.result;
            if (json.buffers !== void 0 && base64data !== null) {
              json.buffers[0].uri = base64data;
              onDone(json);
            }
          };
        } else {
          onDone(json);
        }
      }
    });
  }
  serializeUserData(object, objectDef) {
    if (Object.keys(object.userData).length === 0)
      return;
    const options = this.options;
    const extensionsUsed = this.extensionsUsed;
    try {
      const json = JSON.parse(JSON.stringify(object.userData));
      if (options.includeCustomExtensions && json.gltfExtensions) {
        if (objectDef.extensions === void 0)
          objectDef.extensions = {};
        for (const extensionName in json.gltfExtensions) {
          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];
          extensionsUsed[extensionName] = true;
        }
        delete json.gltfExtensions;
      }
      if (Object.keys(json).length > 0)
        objectDef.extras = json;
    } catch (error) {
      if (error instanceof Error) {
        console.warn("THREE.GLTFExporter: userData of '" + object.name + "' won't be serialized because of JSON.stringify error - " + error.message);
      }
    }
  }
  getUID(object) {
    if (!this.uids.has(object))
      this.uids.set(object, this.uid++);
    return this.uids.get(object);
  }
  isNormalizedNormalAttribute(normal) {
    const cache = this.cache;
    if (cache.attributesNormalized.has(normal))
      return false;
    const v3 = new Vector3();
    for (let i2 = 0, il = normal.count; i2 < il; i2++) {
      if (Math.abs(v3.fromBufferAttribute(normal, i2).length() - 1) > 5e-4)
        return false;
    }
    return true;
  }
  createNormalizedNormalAttribute(normal) {
    const cache = this.cache;
    if (cache.attributesNormalized.has(normal))
      return cache.attributesNormalized.get(normal);
    const attribute2 = normal.clone();
    const v3 = new Vector3();
    for (let i2 = 0, il = attribute2.count; i2 < il; i2++) {
      v3.fromBufferAttribute(attribute2, i2);
      if (v3.x === 0 && v3.y === 0 && v3.z === 0) {
        v3.setX(1);
      } else {
        v3.normalize();
      }
      attribute2.setXYZ(i2, v3.x, v3.y, v3.z);
    }
    cache.attributesNormalized.set(normal, attribute2);
    return attribute2;
  }
  applyTextureTransform(mapDef, texture2) {
    let didTransform = false;
    const transformDef = {};
    if (texture2.offset.x !== 0 || texture2.offset.y !== 0) {
      transformDef.offset = texture2.offset.toArray();
      didTransform = true;
    }
    if (texture2.rotation !== 0) {
      transformDef.rotation = texture2.rotation;
      didTransform = true;
    }
    if (texture2.repeat.x !== 1 || texture2.repeat.y !== 1) {
      transformDef.scale = texture2.repeat.toArray();
      didTransform = true;
    }
    if (didTransform) {
      mapDef.extensions = mapDef.extensions || {};
      mapDef.extensions["KHR_texture_transform"] = transformDef;
      this.extensionsUsed["KHR_texture_transform"] = true;
    }
  }
  processBuffer(buffer2) {
    const json = this.json;
    const buffers = this.buffers;
    if (!json.buffers)
      json.buffers = [{
        byteLength: 0
      }];
    buffers.push(buffer2);
    return 0;
  }
  processBufferView(attribute2, componentType, start, count, target) {
    const json = this.json;
    if (!json.bufferViews)
      json.bufferViews = [];
    let componentSize;
    if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {
      componentSize = 1;
    } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {
      componentSize = 2;
    } else {
      componentSize = 4;
    }
    const byteLength = this.getPaddedBufferSize(count * attribute2.itemSize * componentSize);
    const dataView = new DataView(new ArrayBuffer(byteLength));
    let offset = 0;
    for (let i2 = start; i2 < start + count; i2++) {
      for (let a2 = 0; a2 < attribute2.itemSize; a2++) {
        let value;
        if (attribute2.itemSize > 4) {
          value = attribute2.array[i2 * attribute2.itemSize + a2];
        } else {
          if (a2 === 0)
            value = attribute2.getX(i2);
          else if (a2 === 1)
            value = attribute2.getY(i2);
          else if (a2 === 2)
            value = attribute2.getZ(i2);
          else if (a2 === 3)
            value = attribute2.getW(i2);
        }
        if (value !== void 0) {
          if (componentType === WEBGL_CONSTANTS.FLOAT) {
            dataView.setFloat32(offset, value, true);
          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {
            dataView.setUint32(offset, value, true);
          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {
            dataView.setUint16(offset, value, true);
          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {
            dataView.setUint8(offset, value);
          }
        }
        offset += componentSize;
      }
    }
    const bufferViewDef = {
      buffer: this.processBuffer(dataView.buffer),
      byteOffset: this.byteOffset,
      byteLength
    };
    if (target !== void 0)
      bufferViewDef.target = target;
    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {
      bufferViewDef.byteStride = attribute2.itemSize * componentSize;
    }
    this.byteOffset += byteLength;
    json.bufferViews.push(bufferViewDef);
    const output = {
      id: json.bufferViews.length - 1,
      byteLength: 0
    };
    return output;
  }
  processBufferViewImage(blob) {
    const writer = this;
    const json = writer.json;
    if (!json.bufferViews)
      json.bufferViews = [];
    return new Promise((resolve) => {
      const reader = new window.FileReader();
      reader.readAsArrayBuffer(blob);
      reader.onloadend = () => {
        if (reader.result !== null && typeof reader.result !== "string" && json.bufferViews !== void 0) {
          const buffer2 = this.getPaddedArrayBuffer(reader.result);
          const bufferViewDef = {
            buffer: writer.processBuffer(buffer2),
            byteOffset: writer.byteOffset,
            byteLength: buffer2.byteLength
          };
          writer.byteOffset += buffer2.byteLength;
          resolve(json.bufferViews.push(bufferViewDef) - 1);
        }
      };
    });
  }
  processAccessor(attribute2, geometry2, start, count) {
    const options = this.options;
    const json = this.json;
    const types = {
      1: "SCALAR",
      2: "VEC2",
      3: "VEC3",
      4: "VEC4",
      16: "MAT4"
    };
    let componentType;
    if (attribute2.array.constructor === Float32Array) {
      componentType = WEBGL_CONSTANTS.FLOAT;
    } else if (attribute2.array.constructor === Uint32Array) {
      componentType = WEBGL_CONSTANTS.UNSIGNED_INT;
    } else if (attribute2.array.constructor === Uint16Array) {
      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;
    } else if (attribute2.array.constructor === Uint8Array) {
      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;
    } else {
      throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");
    }
    if (start === void 0)
      start = 0;
    if (count === void 0)
      count = attribute2.count;
    if (options.truncateDrawRange && geometry2 !== void 0 && geometry2.index === null) {
      const end = start + count;
      const end2 = geometry2.drawRange.count === Infinity ? attribute2.count : geometry2.drawRange.start + geometry2.drawRange.count;
      start = Math.max(start, geometry2.drawRange.start);
      count = Math.min(end, end2) - start;
      if (count < 0)
        count = 0;
    }
    if (count === 0)
      return null;
    const minMax = this.getMinMax(attribute2, start, count);
    let bufferViewTarget;
    if (geometry2 !== void 0) {
      bufferViewTarget = attribute2 === geometry2.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;
    }
    if (bufferViewTarget !== void 0) {
      const bufferView = this.processBufferView(attribute2, componentType, start, count, bufferViewTarget);
      const accessorDef = {
        bufferView: bufferView.id,
        byteOffset: bufferView.byteOffset,
        componentType,
        count,
        max: minMax.max,
        min: minMax.min,
        type: types[attribute2.itemSize]
      };
      if (attribute2.normalized)
        accessorDef.normalized = true;
      if (!json.accessors)
        json.accessors = [];
      return json.accessors.push(accessorDef) - 1;
    }
  }
  processImage(image, format, flipY) {
    const writer = this;
    const cache = writer.cache;
    const json = writer.json;
    const options = writer.options;
    const pending = writer.pending;
    if (!cache.images.has(image))
      cache.images.set(image, {});
    const cachedImages = cache.images.get(image);
    const mimeType = format === RGBAFormat ? "image/png" : "image/jpeg";
    const key = mimeType + ":flipY/" + flipY.toString();
    if (cachedImages !== void 0 && cachedImages[key] !== void 0)
      return cachedImages[key];
    if (!json.images)
      json.images = [];
    const imageDef = {
      mimeType
    };
    if (options.embedImages && options.maxTextureSize !== void 0) {
      const canvas = this.cachedCanvas = this.cachedCanvas || document.createElement("canvas");
      canvas.width = Math.min(image.width, options.maxTextureSize);
      canvas.height = Math.min(image.height, options.maxTextureSize);
      const ctx = canvas.getContext("2d");
      if (flipY) {
        ctx === null || ctx === void 0 ? void 0 : ctx.translate(0, canvas.height);
        ctx === null || ctx === void 0 ? void 0 : ctx.scale(1, -1);
      }
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== "undefined" && image instanceof OffscreenCanvas || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
      } else {
        if (format !== RGBAFormat) {
          console.error("GLTFExporter: Only RGBA format is supported.");
        }
        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {
          console.warn("GLTFExporter: Image size is bigger than maxTextureSize", image);
        }
        const data = new Uint8ClampedArray(image.height * image.width * 4);
        if (image instanceof ImageData) {
          for (let i2 = 0; i2 < data.length; i2 += 4) {
            data[i2 + 0] = image.data[i2 + 0];
            data[i2 + 1] = image.data[i2 + 1];
            data[i2 + 2] = image.data[i2 + 2];
            data[i2 + 3] = image.data[i2 + 3];
          }
        }
        ctx === null || ctx === void 0 ? void 0 : ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);
      }
      if (options.binary) {
        pending.push(new Promise(function(resolve) {
          canvas.toBlob(function(blob) {
            if (blob !== null) {
              writer.processBufferViewImage(blob).then(function(bufferViewIndex) {
                imageDef.bufferView = bufferViewIndex;
                resolve();
              });
            }
          }, mimeType);
        }));
      } else {
        imageDef.uri = canvas.toDataURL(mimeType);
      }
    } else if (image instanceof Image) {
      imageDef.uri = image.src;
    }
    const index = json.images.push(imageDef) - 1;
    if (cachedImages !== void 0)
      cachedImages[key] = index;
    return index;
  }
  processSampler(map) {
    const json = this.json;
    if (!json.samplers)
      json.samplers = [];
    const samplerDef = {
      magFilter: THREE_TO_WEBGL[map.magFilter],
      minFilter: THREE_TO_WEBGL[map.minFilter],
      wrapS: THREE_TO_WEBGL[map.wrapS],
      wrapT: THREE_TO_WEBGL[map.wrapT]
    };
    return json.samplers.push(samplerDef) - 1;
  }
  processTexture(map) {
    const cache = this.cache;
    const json = this.json;
    if (cache.textures.has(map))
      return cache.textures.get(map);
    if (!json.textures)
      json.textures = [];
    const textureDef = {
      sampler: this.processSampler(map),
      source: this.processImage(map.image, map.format, map.flipY)
    };
    if (map.name)
      textureDef.name = map.name;
    this._invokeAll(function(ext) {
      ext.writeTexture && ext.writeTexture(map, textureDef);
    });
    const index = json.textures.push(textureDef) - 1;
    cache.textures.set(map, index);
    return index;
  }
  processMaterial(material) {
    const cache = this.cache;
    const json = this.json;
    if (cache.materials.has(material))
      return cache.materials.get(material);
    if (material instanceof ShaderMaterial && material.isShaderMaterial) {
      console.warn("GLTFExporter: THREE.ShaderMaterial not supported.");
      return null;
    }
    if (!json.materials)
      json.materials = [];
    const materialDef = {
      pbrMetallicRoughness: {}
    };
    if (!(material instanceof MeshStandardMaterial && material.isMeshStandardMaterial && material instanceof MeshBasicMaterial && material.isMeshBasicMaterial)) {
      console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
    }
    if (material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) {
      const color3 = material.color.toArray().concat([material.opacity]);
      if (!this.equalArray(color3, [1, 1, 1, 1])) {
        materialDef.pbrMetallicRoughness.baseColorFactor = color3;
      }
    }
    if (material instanceof MeshStandardMaterial && material.isMeshStandardMaterial) {
      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;
      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;
    } else {
      materialDef.pbrMetallicRoughness.metallicFactor = 0.5;
      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;
    }
    if (material instanceof MeshStandardMaterial && material.metalnessMap || material instanceof MeshStandardMaterial && material.roughnessMap) {
      if (material.metalnessMap === material.roughnessMap && material.metalnessMap !== null) {
        const metalRoughMapDef = {
          index: this.processTexture(material.metalnessMap)
        };
        this.applyTextureTransform(metalRoughMapDef, material.metalnessMap);
        materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;
      } else {
        console.warn("THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.");
      }
    }
    if ((material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) && material.map) {
      const baseColorMapDef = {
        index: this.processTexture(material.map)
      };
      this.applyTextureTransform(baseColorMapDef, material.map);
      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;
    }
    if ((material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) && material.emissive) {
      const emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity);
      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);
      if (maxEmissiveComponent > 1) {
        emissive.multiplyScalar(1 / maxEmissiveComponent);
        console.warn("THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited");
      }
      if (maxEmissiveComponent > 0) {
        materialDef.emissiveFactor = emissive.toArray();
      }
      if (material.emissiveMap) {
        const emissiveMapDef = {
          index: this.processTexture(material.emissiveMap)
        };
        this.applyTextureTransform(emissiveMapDef, material.emissiveMap);
        materialDef.emissiveTexture = emissiveMapDef;
      }
    }
    if ((material instanceof MeshMatcapMaterial || material instanceof MeshNormalMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshToonMaterial) && material.normalMap) {
      const normalMapDef = {
        index: this.processTexture(material.normalMap)
      };
      if (material.normalScale && material.normalScale.x !== 1) {
        normalMapDef.scale = material.normalScale.x;
      }
      this.applyTextureTransform(normalMapDef, material.normalMap);
      materialDef.normalTexture = normalMapDef;
    }
    if ((material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshToonMaterial) && material.aoMap) {
      const occlusionMapDef = {
        index: this.processTexture(material.aoMap),
        texCoord: 1
      };
      if (material.aoMapIntensity !== 1) {
        occlusionMapDef.strength = material.aoMapIntensity;
      }
      this.applyTextureTransform(occlusionMapDef, material.aoMap);
      materialDef.occlusionTexture = occlusionMapDef;
    }
    if (material.transparent) {
      materialDef.alphaMode = "BLEND";
    } else {
      if (material.alphaTest > 0) {
        materialDef.alphaMode = "MASK";
        materialDef.alphaCutoff = material.alphaTest;
      }
    }
    if (material.side === DoubleSide)
      materialDef.doubleSided = true;
    if (material.name !== "")
      materialDef.name = material.name;
    this.serializeUserData(material, materialDef);
    this._invokeAll(function(ext) {
      ext.writeMaterial && ext.writeMaterial(material, materialDef);
    });
    const index = json.materials.push(materialDef) - 1;
    cache.materials.set(material, index);
    return index;
  }
  processMesh(mesh) {
    const cache = this.cache;
    const json = this.json;
    const meshCacheKeyParts = [mesh.geometry.uuid];
    if (Array.isArray(mesh.material)) {
      for (let i2 = 0, l = mesh.material.length; i2 < l; i2++) {
        meshCacheKeyParts.push(mesh.material[i2].uuid);
      }
    } else {
      meshCacheKeyParts.push(mesh.material.uuid);
    }
    const meshCacheKey = meshCacheKeyParts.join(":");
    if (cache.meshes.has(meshCacheKey))
      return cache.meshes.get(meshCacheKey);
    const geometry2 = mesh.geometry;
    let mode;
    if (mesh instanceof LineSegments && mesh.isLineSegments) {
      mode = WEBGL_CONSTANTS.LINES;
    } else if (mesh instanceof LineLoop && mesh.isLineLoop) {
      mode = WEBGL_CONSTANTS.LINE_LOOP;
    } else if (mesh instanceof Line && mesh.isLine) {
      mode = WEBGL_CONSTANTS.LINE_STRIP;
    } else if (mesh instanceof Points && mesh.isPoints) {
      mode = WEBGL_CONSTANTS.POINTS;
    } else {
      mode = (mesh.material instanceof MeshBasicMaterial || mesh.material instanceof MeshDepthMaterial || mesh.material instanceof MeshLambertMaterial || mesh.material instanceof MeshNormalMaterial || mesh.material instanceof MeshPhongMaterial || mesh.material instanceof MeshStandardMaterial || mesh.material instanceof MeshToonMaterial || mesh.material instanceof ShaderMaterial) && mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;
    }
    if (!geometry2.isBufferGeometry) {
      throw new Error("THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.");
    }
    const meshDef = {};
    const attributes = {};
    const primitives = [];
    const targets = [];
    const nameConversion = {
      uv: "TEXCOORD_0",
      uv2: "TEXCOORD_1",
      color: "COLOR_0",
      skinWeight: "WEIGHTS_0",
      skinIndex: "JOINTS_0"
    };
    const originalNormal = geometry2.getAttribute("normal");
    if (originalNormal !== void 0 && !(originalNormal instanceof InterleavedBufferAttribute) && !this.isNormalizedNormalAttribute(originalNormal)) {
      console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.");
      geometry2.setAttribute("normal", this.createNormalizedNormalAttribute(originalNormal));
    }
    let modifiedAttribute = null;
    for (let attributeName in geometry2.attributes) {
      if (attributeName.substr(0, 5) === "morph")
        continue;
      const attribute2 = geometry2.attributes[attributeName];
      attributeName = nameConversion[attributeName] || attributeName.toUpperCase();
      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/;
      if (!validVertexAttributes.test(attributeName))
        attributeName = "_" + attributeName;
      if (cache.attributes.has(this.getUID(attribute2))) {
        attributes[attributeName] = cache.attributes.get(this.getUID(attribute2));
        continue;
      }
      modifiedAttribute = null;
      const array = attribute2.array;
      if (attributeName === "JOINTS_0" && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {
        console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.');
        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute2.itemSize, attribute2.normalized);
      }
      const accessor = modifiedAttribute !== null && this.processAccessor(modifiedAttribute || attribute2, geometry2);
      if (accessor) {
        attributes[attributeName] = accessor;
        cache.attributes.set(this.getUID(attribute2), accessor);
      }
    }
    if (originalNormal !== void 0)
      geometry2.setAttribute("normal", originalNormal);
    if (Object.keys(attributes).length === 0)
      return null;
    if (mesh.morphTargetInfluences !== void 0 && mesh.morphTargetInfluences.length > 0) {
      const weights = [];
      const targetNames = [];
      const reverseDictionary = {};
      if (mesh.morphTargetDictionary !== void 0) {
        for (const key in mesh.morphTargetDictionary) {
          reverseDictionary[mesh.morphTargetDictionary[key]] = key;
        }
      }
      for (let i2 = 0; i2 < mesh.morphTargetInfluences.length; ++i2) {
        const target = {};
        let warned = false;
        for (const attributeName in geometry2.morphAttributes) {
          if (attributeName !== "position" && attributeName !== "normal") {
            if (!warned) {
              console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported.");
              warned = true;
            }
            continue;
          }
          const attribute2 = geometry2.morphAttributes[attributeName][i2];
          const gltfAttributeName = attributeName.toUpperCase();
          const baseAttribute = geometry2.attributes[attributeName];
          if (cache.attributes.has(this.getUID(attribute2))) {
            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute2));
            continue;
          }
          const relativeAttribute = attribute2.clone();
          if (!geometry2.morphTargetsRelative) {
            for (let j2 = 0, jl2 = attribute2.count; j2 < jl2; j2++) {
              relativeAttribute.setXYZ(j2, attribute2.getX(j2) - baseAttribute.getX(j2), attribute2.getY(j2) - baseAttribute.getY(j2), attribute2.getZ(j2) - baseAttribute.getZ(j2));
            }
          }
          const accessor = this.processAccessor(relativeAttribute, geometry2);
          if (accessor != void 0) {
            target[gltfAttributeName] = accessor;
          }
          cache.attributes.set(this.getUID(baseAttribute), target[gltfAttributeName]);
        }
        targets.push(target);
        weights.push(mesh.morphTargetInfluences[i2]);
        if (mesh.morphTargetDictionary !== void 0)
          targetNames.push(reverseDictionary[i2]);
      }
      meshDef.weights = weights;
      if (targetNames.length > 0) {
        meshDef.extras = {};
        meshDef.extras.targetNames = targetNames;
      }
    }
    const isMultiMaterial = Array.isArray(mesh.material);
    if (isMultiMaterial && geometry2.groups.length === 0)
      return null;
    const materials = isMultiMaterial ? mesh.material : [mesh.material];
    const groups = isMultiMaterial ? geometry2.groups : [{
      materialIndex: 0,
      start: void 0,
      count: void 0
    }];
    for (let i2 = 0, il = groups.length; i2 < il; i2++) {
      const primitive = {
        mode,
        attributes
      };
      if (geometry2 instanceof Object3D || geometry2 instanceof Material) {
        this.serializeUserData(geometry2, primitive);
      }
      if (targets.length > 0)
        primitive.targets = targets;
      if (geometry2.index !== null) {
        let cacheKey = this.getUID(geometry2.index);
        if (groups[i2].start !== void 0 || groups[i2].count !== void 0) {
          cacheKey += `:${groups[i2].start}:${groups[i2].count}`;
        }
        if (cache.attributes.has(cacheKey)) {
          primitive.indices = cache.attributes.get(cacheKey);
        } else {
          primitive.indices = this.processAccessor(geometry2.index, geometry2, groups[i2].start, groups[i2].count);
          cache.attributes.set(cacheKey, primitive.indices);
        }
        if (primitive.indices === null)
          delete primitive.indices;
      }
      const materialIndex = groups[i2].materialIndex;
      if (materialIndex !== void 0 && Array.isArray(materials)) {
        const targetMaterials = materials[materialIndex];
        if (!Array.isArray(targetMaterials)) {
          const material = this.processMaterial(targetMaterials);
          if (material !== null)
            primitive.material = material;
          primitives.push(primitive);
        }
      }
    }
    meshDef.primitives = primitives;
    if (!json.meshes)
      json.meshes = [];
    this._invokeAll(function(ext) {
      ext.writeMesh && ext.writeMesh(mesh, meshDef);
    });
    const index = json.meshes.push(meshDef) - 1;
    cache.meshes.set(meshCacheKey, index);
    return index;
  }
  processCamera(camera) {
    const json = this.json;
    if (!json.cameras)
      json.cameras = [];
    const isOrtho = camera instanceof OrthographicCamera && camera.isOrthographicCamera;
    const cameraDef = {
      type: isOrtho ? "orthographic" : "perspective"
    };
    if (camera instanceof OrthographicCamera && isOrtho) {
      cameraDef.orthographic = {
        xmag: camera.right * 2,
        ymag: camera.top * 2,
        zfar: camera.far <= 0 ? 1e-3 : camera.far,
        znear: camera.near < 0 ? 0 : camera.near
      };
    } else if (camera instanceof PerspectiveCamera) {
      cameraDef.perspective = {
        aspectRatio: camera.aspect,
        yfov: MathUtils.degToRad(camera.fov),
        zfar: camera.far <= 0 ? 1e-3 : camera.far,
        znear: camera.near < 0 ? 0 : camera.near
      };
    }
    if (camera.name !== "")
      cameraDef.name = camera.type;
    return json.cameras.push(cameraDef) - 1;
  }
  processAnimation(clip, root) {
    const json = this.json;
    const nodeMap = this.nodeMap;
    if (!json.animations)
      json.animations = [];
    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);
    const tracks = clip.tracks;
    const channels = [];
    const samplers = [];
    for (let i2 = 0; i2 < tracks.length; ++i2) {
      const track = tracks[i2];
      const trackBinding = PropertyBinding.parseTrackName(track.name);
      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);
      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];
      if (trackBinding.objectName === "bones") {
        if (trackNode.isSkinnedMesh) {
          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);
        } else {
          trackNode = void 0;
        }
      }
      if (!trackNode || !trackProperty) {
        console.warn('THREE.GLTFExporter: Could not export animation track "%s".', track.name);
        return null;
      }
      const inputItemSize = 1;
      let outputItemSize = track.values.length / track.times.length;
      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {
        outputItemSize /= trackNode.morphTargetInfluences.length;
      }
      let interpolation;
      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        interpolation = "CUBICSPLINE";
        outputItemSize /= 3;
      } else if (track.getInterpolation() === InterpolateDiscrete) {
        interpolation = "STEP";
      } else {
        interpolation = "LINEAR";
      }
      samplers.push({
        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),
        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),
        interpolation
      });
      channels.push({
        sampler: samplers.length - 1,
        target: {
          node: nodeMap.get(trackNode),
          path: trackProperty
        }
      });
    }
    json.animations.push({
      name: clip.name || "clip_" + json.animations.length,
      samplers,
      channels
    });
    return json.animations.length - 1;
  }
  processSkin(object) {
    const json = this.json;
    const nodeMap = this.nodeMap;
    if (json.nodes !== void 0 && object instanceof SkinnedMesh) {
      const node = json.nodes[nodeMap.get(object)];
      const skeleton = object.skeleton;
      if (skeleton === void 0)
        return null;
      const rootJoint = object.skeleton.bones[0];
      if (rootJoint === void 0)
        return null;
      const joints = [];
      const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);
      const temporaryBoneInverse = new Matrix4();
      for (let i2 = 0; i2 < skeleton.bones.length; ++i2) {
        joints.push(nodeMap.get(skeleton.bones[i2]));
        temporaryBoneInverse.copy(skeleton.boneInverses[i2]);
        temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i2 * 16);
      }
      if (json.skins === void 0)
        json.skins = [];
      json.skins.push({
        inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),
        joints,
        skeleton: nodeMap.get(rootJoint)
      });
      const skinIndex = node.skin = json.skins.length - 1;
      return skinIndex;
    } else {
      return null;
    }
  }
  processNode(object) {
    const json = this.json;
    const options = this.options;
    const nodeMap = this.nodeMap;
    if (!json.nodes)
      json.nodes = [];
    const nodeDef = {};
    if (options.trs) {
      const rotation = object.quaternion.toArray();
      const position = object.position.toArray();
      const scale = object.scale.toArray();
      if (!this.equalArray(rotation, [0, 0, 0, 1])) {
        nodeDef.rotation = rotation;
      }
      if (!this.equalArray(position, [0, 0, 0])) {
        nodeDef.translation = position;
      }
      if (!this.equalArray(scale, [1, 1, 1])) {
        nodeDef.scale = scale;
      }
    } else {
      if (object.matrixAutoUpdate) {
        object.updateMatrix();
      }
      if (!this.isIdentityMatrix(object.matrix)) {
        nodeDef.matrix = object.matrix.elements;
      }
    }
    if (object.name !== "")
      nodeDef.name = String(object.name);
    this.serializeUserData(object, nodeDef);
    if ((object instanceof Mesh && object.isMesh || object instanceof Line && object.isLine || object instanceof Points && object.isPoints) && object instanceof Mesh) {
      const meshIndex = this.processMesh(object);
      if (meshIndex !== null)
        nodeDef.mesh = meshIndex;
    } else if (object instanceof Camera && object.isCamera) {
      nodeDef.camera = this.processCamera(object);
    }
    if (object instanceof SkinnedMesh && object.isSkinnedMesh)
      this.skins.push(object);
    if (object.children.length > 0) {
      const children = [];
      for (let i2 = 0, l = object.children.length; i2 < l; i2++) {
        const child = object.children[i2];
        if (child.visible || !options.onlyVisible) {
          const nodeIndex2 = this.processNode(child);
          if (nodeIndex2 !== null)
            children.push(nodeIndex2);
        }
      }
      if (children.length > 0)
        nodeDef.children = children;
    }
    this._invokeAll(function(ext) {
      ext.writeNode && ext.writeNode(object, nodeDef);
    });
    const nodeIndex = json.nodes.push(nodeDef) - 1;
    nodeMap.set(object, nodeIndex);
    return nodeIndex;
  }
  processScene(scene) {
    const json = this.json;
    const options = this.options;
    if (!json.scenes) {
      json.scenes = [];
      json.scene = 0;
    }
    const sceneDef = {};
    if (scene.name !== "")
      sceneDef.name = scene.name;
    json.scenes.push(sceneDef);
    const nodes = [];
    for (let i2 = 0, l = scene.children.length; i2 < l; i2++) {
      const child = scene.children[i2];
      if (child.visible || !options.onlyVisible) {
        const nodeIndex = this.processNode(child);
        if (nodeIndex !== null)
          nodes.push(nodeIndex);
      }
    }
    if (nodes.length > 0)
      sceneDef.nodes = nodes;
    this.serializeUserData(scene, sceneDef);
  }
  processObjects(objects) {
    const scene = new Scene();
    scene.name = "AuxScene";
    for (let i2 = 0; i2 < objects.length; i2++) {
      scene.children.push(objects[i2]);
    }
    this.processScene(scene);
  }
  processInput(input) {
    const options = this.options;
    input = input instanceof Array ? input : [input];
    this._invokeAll(function(ext) {
      ext.beforeParse && ext.beforeParse(input);
    });
    const objectsWithoutScene = [];
    for (let i2 = 0; i2 < input.length; i2++) {
      const inputScene = input[i2];
      if (inputScene instanceof Scene) {
        this.processScene(inputScene);
      } else {
        objectsWithoutScene.push(input[i2]);
      }
    }
    if (objectsWithoutScene.length > 0)
      this.processObjects(objectsWithoutScene);
    for (let i2 = 0; i2 < this.skins.length; ++i2) {
      this.processSkin(this.skins[i2]);
    }
    for (let i2 = 0; options.animations !== void 0 && i2 < options.animations.length; ++i2) {
      this.processAnimation(options.animations[i2], input[0]);
    }
    this._invokeAll(function(ext) {
      ext.afterParse && ext.afterParse(input);
    });
  }
  _invokeAll(func) {
    for (let i2 = 0, il = this.plugins.length; i2 < il; i2++) {
      func(this.plugins[i2]);
    }
  }
  equalArray(array1, array2) {
    return array1.length === array2.length && array1.every(function(element2, index) {
      return element2 === array2[index];
    });
  }
  stringToArrayBuffer(text) {
    if (window.TextEncoder !== void 0) {
      return new TextEncoder().encode(text).buffer;
    }
    const array = new Uint8Array(new ArrayBuffer(text.length));
    for (let i2 = 0, il = text.length; i2 < il; i2++) {
      const value = text.charCodeAt(i2);
      array[i2] = value > 255 ? 32 : value;
    }
    return array.buffer;
  }
  isIdentityMatrix(matrix3) {
    return this.equalArray(matrix3.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  }
  getMinMax(attribute2, start, count) {
    const output = {
      min: new Array(attribute2.itemSize).fill(Number.POSITIVE_INFINITY),
      max: new Array(attribute2.itemSize).fill(Number.NEGATIVE_INFINITY)
    };
    for (let i2 = start; i2 < start + count; i2++) {
      for (let a2 = 0; a2 < attribute2.itemSize; a2++) {
        let value;
        if (attribute2.itemSize > 4) {
          value = attribute2.array[i2 * attribute2.itemSize + a2];
        } else {
          if (a2 === 0)
            value = attribute2.getX(i2);
          else if (a2 === 1)
            value = attribute2.getY(i2);
          else if (a2 === 2)
            value = attribute2.getZ(i2);
          else if (a2 === 3)
            value = attribute2.getW(i2);
        }
        if (value !== void 0) {
          output.min[a2] = Math.min(output.min[a2], value);
          output.max[a2] = Math.max(output.max[a2], value);
        }
      }
    }
    return output;
  }
  getPaddedBufferSize(bufferSize) {
    return Math.ceil(bufferSize / 4) * 4;
  }
  getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {
    const paddedLength = this.getPaddedBufferSize(arrayBuffer.byteLength);
    if (paddedLength !== arrayBuffer.byteLength) {
      const array = new Uint8Array(paddedLength);
      array.set(new Uint8Array(arrayBuffer));
      if (paddingByte !== 0) {
        for (let i2 = arrayBuffer.byteLength; i2 < paddedLength; i2++) {
          array[i2] = paddingByte;
        }
      }
      return array.buffer;
    }
    return arrayBuffer;
  }
};
var GLTFLightExtension = class {
  constructor(writer) {
    _defineProperty(this, "writer", void 0);
    _defineProperty(this, "name", void 0);
    this.writer = writer;
    this.name = "KHR_lights_punctual";
  }
  writeNode(light, nodeDef) {
    if (!light.isLight)
      return;
    if (!(light instanceof DirectionalLight && light.isDirectionalLight) && !(light instanceof PointLight && light.isPointLight) && !(light instanceof SpotLight && light.isSpotLight)) {
      console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", light);
      return;
    }
    const writer = this.writer;
    const json = writer.json;
    const extensionsUsed = writer.extensionsUsed;
    const lightDef = {};
    if (light.name)
      lightDef.name = light.name;
    lightDef.color = light.color.toArray();
    lightDef.intensity = light.intensity;
    if (light instanceof DirectionalLight && light.isDirectionalLight) {
      lightDef.type = "directional";
    } else if (light instanceof PointLight && light.isPointLight) {
      lightDef.type = "point";
      if (light.distance > 0)
        lightDef.range = light.distance;
    } else if (light instanceof SpotLight && light.isSpotLight) {
      lightDef.type = "spot";
      if (light.distance > 0)
        lightDef.range = light.distance;
      lightDef.spot = {};
      lightDef.spot.innerConeAngle = (light.penumbra - 1) * light.angle * -1;
      lightDef.spot.outerConeAngle = light.angle;
    }
    if (!(light instanceof DirectionalLight) && light.decay !== void 0 && light.decay !== 2) {
      console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2.");
    }
    if (!(light instanceof PointLight) && light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {
      console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1.");
    }
    if (!extensionsUsed[this.name]) {
      json.extensions = json.extensions || {};
      json.extensions[this.name] = {
        lights: []
      };
      extensionsUsed[this.name] = true;
    }
    if (json.extensions !== void 0) {
      const lights = json.extensions[this.name].lights;
      lights.push(lightDef);
      nodeDef.extensions = nodeDef.extensions || {};
      nodeDef.extensions[this.name] = {
        light: lights.length - 1
      };
    }
  }
};
var GLTFMaterialsUnlitExtension = class {
  constructor(writer) {
    _defineProperty(this, "writer", void 0);
    _defineProperty(this, "name", void 0);
    this.writer = writer;
    this.name = "KHR_materials_unlit";
  }
  writeMaterial(material, materialDef) {
    if (!(material instanceof MeshBasicMaterial && material.isMeshBasicMaterial)) {
      return;
    }
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = {};
    extensionsUsed[this.name] = true;
    materialDef.pbrMetallicRoughness.metallicFactor = 0;
    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;
  }
};
var GLTFMaterialsPBRSpecularGlossiness = class {
  constructor(writer) {
    _defineProperty(this, "writer", void 0);
    _defineProperty(this, "name", void 0);
    this.writer = writer;
    this.name = "KHR_materials_pbrSpecularGlossiness";
  }
  writeMaterial(material, materialDef) {
    if (!material.isGLTFSpecularGlossinessMaterial)
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    if (materialDef.pbrMetallicRoughness.baseColorFactor) {
      extensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;
    }
    if (material instanceof MeshPhongMaterial) {
      const specularFactor = [1, 1, 1];
      material.specular.toArray(specularFactor, 0);
      extensionDef.specularFactor = specularFactor;
      extensionDef.glossinessFactor = material.glossiness;
    }
    if (materialDef.pbrMetallicRoughness.baseColorTexture) {
      extensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;
    }
    if ((material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial) && material.specularMap) {
      const specularMapDef = {
        index: writer.processTexture(material.specularMap)
      };
      writer.applyTextureTransform(specularMapDef, material.specularMap);
      extensionDef.specularGlossinessTexture = specularMapDef;
    }
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsTransmissionExtension = class {
  constructor(writer) {
    _defineProperty(this, "writer", void 0);
    _defineProperty(this, "name", void 0);
    this.writer = writer;
    this.name = "KHR_materials_transmission";
  }
  writeMaterial(material, materialDef) {
    if (!(material instanceof MeshPhysicalMaterial && material.isMeshPhysicalMaterial) || material.transmission === 0) {
      return;
    }
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.transmissionFactor = material.transmission;
    if (material.transmissionMap) {
      const transmissionMapDef = {
        index: writer.processTexture(material.transmissionMap)
      };
      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);
      extensionDef.transmissionTexture = transmissionMapDef;
    }
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsVolumeExtension = class {
  constructor(writer) {
    _defineProperty(this, "writer", void 0);
    _defineProperty(this, "name", void 0);
    this.writer = writer;
    this.name = "KHR_materials_volume";
  }
  writeMaterial(material, materialDef) {
    if (!(material instanceof MeshPhysicalMaterial && material.isMeshPhysicalMaterial) || material.thickness === 0) {
      return;
    }
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.thickness = material.thickness;
    if (material.thicknessMap) {
      const thicknessMapDef = {
        index: writer.processTexture(material.thicknessMap)
      };
      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);
      extensionDef.thicknessTexture = thicknessMapDef;
    }
    extensionDef.attenuationDistance = material.attenuationDistance;
    extensionDef.attenuationColor = material.attenuationTint.toArray();
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/exporters/DRACOExporter.js
var DRACOExporter = class {
  parse(object, options = {
    decodeSpeed: 5,
    encodeSpeed: 5,
    encoderMethod: DRACOExporter.MESH_EDGEBREAKER_ENCODING,
    quantization: [16, 8, 8, 8, 8],
    exportUvs: true,
    exportNormals: true,
    exportColor: false
  }) {
    if (object instanceof BufferGeometry && object.isBufferGeometry) {
      throw new Error("DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.");
    }
    if (DracoEncoderModule === void 0) {
      throw new Error("THREE.DRACOExporter: required the draco_encoder to work.");
    }
    const geometry2 = object.geometry;
    const dracoEncoder = DracoEncoderModule();
    const encoder = new dracoEncoder.Encoder();
    let builder;
    let dracoObject;
    if (!geometry2.isBufferGeometry) {
      throw new Error("THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.");
    }
    if (object instanceof Mesh && object.isMesh) {
      builder = new dracoEncoder.MeshBuilder();
      dracoObject = new dracoEncoder.Mesh();
      const vertices = geometry2.getAttribute("position");
      builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);
      const faces = geometry2.getIndex();
      if (faces !== null) {
        builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array);
      } else {
        const faces2 = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);
        for (let i2 = 0; i2 < faces2.length; i2++) {
          faces2[i2] = i2;
        }
        builder.AddFacesToMesh(dracoObject, vertices.count, faces2);
      }
      if (options.exportNormals) {
        const normals = geometry2.getAttribute("normal");
        if (normals !== void 0) {
          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array);
        }
      }
      if (options.exportUvs) {
        const uvs = geometry2.getAttribute("uv");
        if (uvs !== void 0) {
          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);
        }
      }
      if (options.exportColor) {
        const colors = geometry2.getAttribute("color");
        if (colors !== void 0) {
          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);
        }
      }
    } else if (object instanceof Points && object.isPoints) {
      builder = new dracoEncoder.PointCloudBuilder();
      dracoObject = new dracoEncoder.PointCloud();
      const vertices = geometry2.getAttribute("position");
      builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);
      if (options.exportColor) {
        const colors = geometry2.getAttribute("color");
        if (colors !== void 0) {
          builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);
        }
      }
    } else {
      throw new Error("DRACOExporter: Unsupported object type.");
    }
    const encodedData = new dracoEncoder.DracoInt8Array();
    const encodeSpeed = options.encodeSpeed !== void 0 ? options.encodeSpeed : 5;
    const decodeSpeed = options.decodeSpeed !== void 0 ? options.decodeSpeed : 5;
    encoder.SetSpeedOptions(encodeSpeed, decodeSpeed);
    if (options.encoderMethod !== void 0) {
      encoder.SetEncodingMethod(options.encoderMethod);
    }
    if (options.quantization !== void 0) {
      for (let i2 = 0; i2 < 5; i2++) {
        if (options.quantization[i2] !== void 0) {
          encoder.SetAttributeQuantization(i2, options.quantization[i2]);
        }
      }
    }
    let length2;
    if (object instanceof Mesh && object.isMesh) {
      length2 = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData);
    } else {
      length2 = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData);
    }
    dracoEncoder.destroy(dracoObject);
    if (length2 === 0) {
      throw new Error("THREE.DRACOExporter: Draco encoding failed.");
    }
    const outputData = new Int8Array(new ArrayBuffer(length2));
    for (let i2 = 0; i2 < length2; i2++) {
      outputData[i2] = encodedData.GetValue(i2);
    }
    dracoEncoder.destroy(encodedData);
    dracoEncoder.destroy(encoder);
    dracoEncoder.destroy(builder);
    return outputData;
  }
};
_defineProperty(DRACOExporter, "MESH_EDGEBREAKER_ENCODING", 1);
_defineProperty(DRACOExporter, "MESH_SEQUENTIAL_ENCODING", 0);
_defineProperty(DRACOExporter, "POINT_CLOUD", 0);
_defineProperty(DRACOExporter, "TRIANGULAR_MESH", 1);
_defineProperty(DRACOExporter, "INVALID", -1);
_defineProperty(DRACOExporter, "POSITION", 0);
_defineProperty(DRACOExporter, "NORMAL", 1);
_defineProperty(DRACOExporter, "COLOR", 2);
_defineProperty(DRACOExporter, "TEX_COORD", 3);
_defineProperty(DRACOExporter, "GENERIC", 4);

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/animation/AnimationClipCreator.js
var AnimationClipCreator = () => {
};
AnimationClipCreator.CreateRotationAnimation = (period, axis) => {
  const times = [0, period], values = [0, 360];
  axis = axis || "x";
  const trackName = `.rotation[${axis}]`;
  const track = new NumberKeyframeTrack(trackName, times, values);
  return new AnimationClip(null, period, [track]);
};
AnimationClipCreator.CreateScaleAxisAnimation = (period, axis) => {
  const times = [0, period], values = [0, 1];
  axis = axis || "x";
  const trackName = `.scale[${axis}]`;
  const track = new NumberKeyframeTrack(trackName, times, values);
  return new AnimationClip(null, period, [track]);
};
AnimationClipCreator.CreateShakeAnimation = (duration, shakeScale) => {
  const times = [], values = [], tmp = new Vector3();
  for (let i2 = 0; i2 < duration * 10; i2++) {
    times.push(i2 / 10);
    tmp.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).multiply(shakeScale).toArray(values, values.length);
  }
  const trackName = ".position";
  const track = new VectorKeyframeTrack(trackName, times, values);
  return new AnimationClip(null, duration, [track]);
};
AnimationClipCreator.CreatePulsationAnimation = (duration, pulseScale) => {
  const times = [], values = [], tmp = new Vector3();
  for (let i2 = 0; i2 < duration * 10; i2++) {
    times.push(i2 / 10);
    const scaleFactor = Math.random() * pulseScale;
    tmp.set(scaleFactor, scaleFactor, scaleFactor).toArray(values, values.length);
  }
  const trackName = ".scale";
  const track = new VectorKeyframeTrack(trackName, times, values);
  return new AnimationClip(null, duration, [track]);
};
AnimationClipCreator.CreateVisibilityAnimation = (duration) => {
  const times = [0, duration / 2, duration], values = [true, false, true];
  const trackName = ".visible";
  const track = new BooleanKeyframeTrack(trackName, times, values);
  return new AnimationClip(null, duration, [track]);
};
AnimationClipCreator.CreateMaterialColorAnimation = (duration, colors) => {
  const times = [], values = [], timeStep = duration / colors.length;
  for (let i2 = 0; i2 <= colors.length; i2++) {
    times.push(i2 * timeStep);
    values.push(colors[i2 % colors.length]);
  }
  const trackName = ".material[0].color";
  const track = new ColorKeyframeTrack(trackName, times, values);
  return new AnimationClip(null, duration, [track]);
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/animation/CCDIKSolver.js
var CCDIKHelper = class extends Object3D {
  constructor(mesh, iks = [], sphereSize = 0.25) {
    super();
    _defineProperty(this, "_m", new Matrix4());
    _defineProperty(this, "_v", new Vector3());
    this.root = mesh;
    this.iks = iks;
    this.matrix.copy(mesh.matrixWorld);
    this.matrixAutoUpdate = false;
    this.sphereGeometry = new SphereGeometry(sphereSize, 16, 8);
    this.targetSphereMaterial = new MeshBasicMaterial({
      color: new Color(16746632),
      depthTest: false,
      depthWrite: false,
      transparent: true
    });
    this.effectorSphereMaterial = new MeshBasicMaterial({
      color: new Color(8978312),
      depthTest: false,
      depthWrite: false,
      transparent: true
    });
    this.linkSphereMaterial = new MeshBasicMaterial({
      color: new Color(8947967),
      depthTest: false,
      depthWrite: false,
      transparent: true
    });
    this.lineMaterial = new LineBasicMaterial({
      color: new Color(16711680),
      depthTest: false,
      depthWrite: false,
      transparent: true
    });
    function createLineGeometry(ik) {
      const geometry2 = new BufferGeometry();
      const vertices = new Float32Array((2 + ik.links.length) * 3);
      geometry2.setAttribute("position", new BufferAttribute(vertices, 3));
      return geometry2;
    }
    const scope = this;
    function createTargetMesh() {
      return new Mesh(scope.sphereGeometry, scope.targetSphereMaterial);
    }
    function createEffectorMesh() {
      return new Mesh(scope.sphereGeometry, scope.effectorSphereMaterial);
    }
    function createLinkMesh() {
      return new Mesh(scope.sphereGeometry, scope.linkSphereMaterial);
    }
    function createLine(ik) {
      return new Line(createLineGeometry(ik), scope.lineMaterial);
    }
    for (let i2 = 0, il = iks.length; i2 < il; i2++) {
      const ik = iks[i2];
      this.add(createTargetMesh());
      this.add(createEffectorMesh());
      for (let j2 = 0, jl2 = ik.links.length; j2 < jl2; j2++) {
        this.add(createLinkMesh());
      }
      this.add(createLine(ik));
    }
  }
  _getPosition(bone, matrixWorldInv) {
    return this._v.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv);
  }
  _setPositionOfBoneToAttributeArray(array, index, bone, matrixWorldInv) {
    const v3 = this._getPosition(bone, matrixWorldInv);
    array[index * 3 + 0] = v3.x;
    array[index * 3 + 1] = v3.y;
    array[index * 3 + 2] = v3.z;
  }
  updateMatrixWorld(force) {
    const mesh = this.root;
    if (this.visible) {
      let offset = 0;
      const iks = this.iks;
      const bones = mesh.skeleton.bones;
      this._m.copy(mesh.matrixWorld).invert();
      for (let i2 = 0, il = iks.length; i2 < il; i2++) {
        const ik = iks[i2];
        const targetBone = bones[ik.target];
        const effectorBone = bones[ik.effector];
        const targetMesh = this.children[offset++];
        const effectorMesh = this.children[offset++];
        targetMesh.position.copy(this._getPosition(targetBone, this._m));
        effectorMesh.position.copy(this._getPosition(effectorBone, this._m));
        for (let j2 = 0, jl2 = ik.links.length; j2 < jl2; j2++) {
          const link = ik.links[j2];
          const linkBone = bones[link.index];
          const linkMesh = this.children[offset++];
          linkMesh.position.copy(this._getPosition(linkBone, this._m));
        }
        const line = this.children[offset++];
        const array = line.geometry.attributes.position.array;
        this._setPositionOfBoneToAttributeArray(array, 0, targetBone, this._m);
        this._setPositionOfBoneToAttributeArray(array, 1, effectorBone, this._m);
        for (let j2 = 0, jl2 = ik.links.length; j2 < jl2; j2++) {
          const link = ik.links[j2];
          const linkBone = bones[link.index];
          this._setPositionOfBoneToAttributeArray(array, j2 + 2, linkBone, this._m);
        }
        line.geometry.attributes.position.needsUpdate = true;
      }
    }
    this.matrix.copy(mesh.matrixWorld);
    super.updateMatrixWorld(force);
  }
};
var CCDIKSolver = class {
  constructor(mesh, iks) {
    _defineProperty(this, "q", new Quaternion());
    _defineProperty(this, "targetPos", new Vector3());
    _defineProperty(this, "targetVec", new Vector3());
    _defineProperty(this, "effectorPos", new Vector3());
    _defineProperty(this, "effectorVec", new Vector3());
    _defineProperty(this, "linkPos", new Vector3());
    _defineProperty(this, "invLinkQ", new Quaternion());
    _defineProperty(this, "linkScale", new Vector3());
    _defineProperty(this, "axis", new Vector3());
    _defineProperty(this, "vector", new Vector3());
    this.mesh = mesh;
    this.iks = iks;
    const bones = this.mesh.skeleton.bones;
    for (let i2 = 0, il = this.iks.length; i2 < il; i2++) {
      const ik = this.iks[i2];
      const effector = bones[ik.effector];
      const links = ik.links;
      let link0, link1;
      link0 = effector;
      for (let j2 = 0, jl2 = links.length; j2 < jl2; j2++) {
        link1 = bones[links[j2].index];
        if (link0.parent !== link1) {
          console.warn(`THREE.CCDIKSolver: bone ${link0.name} is not the child of bone ${link1.name}`);
        }
        link0 = link1;
      }
    }
  }
  update() {
    const bones = this.mesh.skeleton.bones;
    const iks = this.iks;
    const math = Math;
    for (let i2 = 0, il = iks.length; i2 < il; i2++) {
      const ik = iks[i2];
      const effector = bones[ik.effector];
      const target = bones[ik.target];
      this.targetPos.setFromMatrixPosition(target.matrixWorld);
      const links = ik.links;
      const iteration = ik.iteration !== void 0 ? ik.iteration : 1;
      for (let j2 = 0; j2 < iteration; j2++) {
        let rotated = false;
        for (let k = 0, kl = links.length; k < kl; k++) {
          const link = bones[links[k].index];
          if (links[k].enabled === false)
            break;
          const limitation = links[k].limitation;
          const rotationMin = links[k].rotationMin;
          const rotationMax = links[k].rotationMax;
          link.matrixWorld.decompose(this.linkPos, this.invLinkQ, this.linkScale);
          this.invLinkQ.invert();
          this.effectorPos.setFromMatrixPosition(effector.matrixWorld);
          this.effectorVec.subVectors(this.effectorPos, this.linkPos);
          this.effectorVec.applyQuaternion(this.invLinkQ);
          this.effectorVec.normalize();
          this.targetVec.subVectors(this.targetPos, this.linkPos);
          this.targetVec.applyQuaternion(this.invLinkQ);
          this.targetVec.normalize();
          let angle = this.targetVec.dot(this.effectorVec);
          if (angle > 1) {
            angle = 1;
          } else if (angle < -1) {
            angle = -1;
          }
          angle = math.acos(angle);
          if (angle < 1e-5)
            continue;
          if (ik.minAngle !== void 0 && angle < ik.minAngle) {
            angle = ik.minAngle;
          }
          if (ik.maxAngle !== void 0 && angle > ik.maxAngle) {
            angle = ik.maxAngle;
          }
          this.axis.crossVectors(this.effectorVec, this.targetVec);
          this.axis.normalize();
          this.q.setFromAxisAngle(this.axis, angle);
          link.quaternion.multiply(this.q);
          if (limitation !== void 0) {
            let c2 = link.quaternion.w;
            if (c2 > 1)
              c2 = 1;
            const c22 = math.sqrt(1 - c2 * c2);
            link.quaternion.set(limitation.x * c22, limitation.y * c22, limitation.z * c22, c2);
          }
          if (rotationMin !== void 0) {
            link.rotation.setFromVector3(this.vector.setFromEuler(link.rotation).max(rotationMin));
          }
          if (rotationMax !== void 0) {
            link.rotation.setFromVector3(this.vector.setFromEuler(link.rotation).min(rotationMax));
          }
          link.updateMatrixWorld(true);
          rotated = true;
        }
        if (!rotated)
          break;
      }
    }
    return this;
  }
  createHelper() {
    return new CCDIKHelper(this.mesh, this.mesh.geometry.userData.MMD.iks);
  }
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/animation/MMDPhysics.js
var MMDPhysics = (() => {
  function MMDPhysics2(mesh, rigidBodyParams, constraintParams, params) {
    if (typeof Ammo === "undefined") {
      throw new Error("THREE.MMDPhysics: Import ammo.js https://github.com/kripken/ammo.js");
    }
    constraintParams = constraintParams || [];
    params = params || {};
    this.manager = new ResourceManager();
    this.mesh = mesh;
    this.unitStep = params.unitStep !== void 0 ? params.unitStep : 1 / 65;
    this.maxStepNum = params.maxStepNum !== void 0 ? params.maxStepNum : 3;
    this.gravity = new Vector3(0, -9.8 * 10, 0);
    if (params.gravity !== void 0)
      this.gravity.copy(params.gravity);
    this.world = params.world !== void 0 ? params.world : null;
    this.bodies = [];
    this.constraints = [];
    this._init(mesh, rigidBodyParams, constraintParams);
  }
  MMDPhysics2.prototype = {
    constructor: MMDPhysics2,
    update: function(delta) {
      const manager = this.manager;
      const mesh = this.mesh;
      let isNonDefaultScale = false;
      const position = manager.allocThreeVector3();
      const quaternion = manager.allocThreeQuaternion();
      const scale = manager.allocThreeVector3();
      mesh.matrixWorld.decompose(position, quaternion, scale);
      if (scale.x !== 1 || scale.y !== 1 || scale.z !== 1) {
        isNonDefaultScale = true;
      }
      let parent;
      if (isNonDefaultScale) {
        parent = mesh.parent;
        if (parent !== null)
          mesh.parent = null;
        scale.copy(this.mesh.scale);
        mesh.scale.set(1, 1, 1);
        mesh.updateMatrixWorld(true);
      }
      this._updateRigidBodies();
      this._stepSimulation(delta);
      this._updateBones();
      if (isNonDefaultScale) {
        if (parent !== null)
          mesh.parent = parent;
        mesh.scale.copy(scale);
      }
      manager.freeThreeVector3(scale);
      manager.freeThreeQuaternion(quaternion);
      manager.freeThreeVector3(position);
      return this;
    },
    reset: function() {
      for (let i2 = 0, il = this.bodies.length; i2 < il; i2++) {
        this.bodies[i2].reset();
      }
      return this;
    },
    warmup: function(cycles) {
      for (let i2 = 0; i2 < cycles; i2++) {
        this.update(1 / 60);
      }
      return this;
    },
    setGravity: function(gravity) {
      this.world.setGravity(new Ammo.btVector3(gravity.x, gravity.y, gravity.z));
      this.gravity.copy(gravity);
      return this;
    },
    createHelper: function() {
      return new MMDPhysicsHelper(this.mesh, this);
    },
    _init: function(mesh, rigidBodyParams, constraintParams) {
      const manager = this.manager;
      let parent = mesh.parent;
      if (parent !== null)
        parent = null;
      const currentPosition = manager.allocThreeVector3();
      const currentQuaternion = manager.allocThreeQuaternion();
      const currentScale = manager.allocThreeVector3();
      currentPosition.copy(mesh.position);
      currentQuaternion.copy(mesh.quaternion);
      currentScale.copy(mesh.scale);
      mesh.position.set(0, 0, 0);
      mesh.quaternion.set(0, 0, 0, 1);
      mesh.scale.set(1, 1, 1);
      mesh.updateMatrixWorld(true);
      if (this.world === null) {
        this.world = this._createWorld();
        this.setGravity(this.gravity);
      }
      this._initRigidBodies(rigidBodyParams);
      this._initConstraints(constraintParams);
      if (parent !== null)
        mesh.parent = parent;
      mesh.position.copy(currentPosition);
      mesh.quaternion.copy(currentQuaternion);
      mesh.scale.copy(currentScale);
      mesh.updateMatrixWorld(true);
      this.reset();
      manager.freeThreeVector3(currentPosition);
      manager.freeThreeQuaternion(currentQuaternion);
      manager.freeThreeVector3(currentScale);
    },
    _createWorld: function() {
      const config = new Ammo.btDefaultCollisionConfiguration();
      const dispatcher = new Ammo.btCollisionDispatcher(config);
      const cache = new Ammo.btDbvtBroadphase();
      const solver = new Ammo.btSequentialImpulseConstraintSolver();
      const world2 = new Ammo.btDiscreteDynamicsWorld(dispatcher, cache, solver, config);
      return world2;
    },
    _initRigidBodies: function(rigidBodies) {
      for (let i2 = 0, il = rigidBodies.length; i2 < il; i2++) {
        this.bodies.push(new RigidBody(this.mesh, this.world, rigidBodies[i2], this.manager));
      }
    },
    _initConstraints: function(constraints) {
      for (let i2 = 0, il = constraints.length; i2 < il; i2++) {
        const params = constraints[i2];
        const bodyA = this.bodies[params.rigidBodyIndex1];
        const bodyB = this.bodies[params.rigidBodyIndex2];
        this.constraints.push(new Constraint(this.mesh, this.world, bodyA, bodyB, params, this.manager));
      }
    },
    _stepSimulation: function(delta) {
      const unitStep = this.unitStep;
      let stepTime = delta;
      let maxStepNum = (delta / unitStep | 0) + 1;
      if (stepTime < unitStep) {
        stepTime = unitStep;
        maxStepNum = 1;
      }
      if (maxStepNum > this.maxStepNum) {
        maxStepNum = this.maxStepNum;
      }
      this.world.stepSimulation(stepTime, maxStepNum, unitStep);
    },
    _updateRigidBodies: function() {
      for (let i2 = 0, il = this.bodies.length; i2 < il; i2++) {
        this.bodies[i2].updateFromBone();
      }
    },
    _updateBones: function() {
      for (let i2 = 0, il = this.bodies.length; i2 < il; i2++) {
        this.bodies[i2].updateBone();
      }
    }
  };
  function ResourceManager() {
    this.threeVector3s = [];
    this.threeMatrix4s = [];
    this.threeQuaternions = [];
    this.threeEulers = [];
    this.transforms = [];
    this.quaternions = [];
    this.vector3s = [];
  }
  ResourceManager.prototype = {
    constructor: ResourceManager,
    allocThreeVector3: function() {
      return this.threeVector3s.length > 0 ? this.threeVector3s.pop() : new Vector3();
    },
    freeThreeVector3: function(v3) {
      this.threeVector3s.push(v3);
    },
    allocThreeMatrix4: function() {
      return this.threeMatrix4s.length > 0 ? this.threeMatrix4s.pop() : new Matrix4();
    },
    freeThreeMatrix4: function(m2) {
      this.threeMatrix4s.push(m2);
    },
    allocThreeQuaternion: function() {
      return this.threeQuaternions.length > 0 ? this.threeQuaternions.pop() : new Quaternion();
    },
    freeThreeQuaternion: function(q) {
      this.threeQuaternions.push(q);
    },
    allocThreeEuler: function() {
      return this.threeEulers.length > 0 ? this.threeEulers.pop() : new Euler();
    },
    freeThreeEuler: function(e) {
      this.threeEulers.push(e);
    },
    allocTransform: function() {
      return this.transforms.length > 0 ? this.transforms.pop() : new Ammo.btTransform();
    },
    freeTransform: function(t2) {
      this.transforms.push(t2);
    },
    allocQuaternion: function() {
      return this.quaternions.length > 0 ? this.quaternions.pop() : new Ammo.btQuaternion();
    },
    freeQuaternion: function(q) {
      this.quaternions.push(q);
    },
    allocVector3: function() {
      return this.vector3s.length > 0 ? this.vector3s.pop() : new Ammo.btVector3();
    },
    freeVector3: function(v3) {
      this.vector3s.push(v3);
    },
    setIdentity: function(t2) {
      t2.setIdentity();
    },
    getBasis: function(t2) {
      const q = this.allocQuaternion();
      t2.getBasis().getRotation(q);
      return q;
    },
    getBasisAsMatrix3: function(t2) {
      const q = this.getBasis(t2);
      const m2 = this.quaternionToMatrix3(q);
      this.freeQuaternion(q);
      return m2;
    },
    getOrigin: function(t2) {
      return t2.getOrigin();
    },
    setOrigin: function(t2, v3) {
      t2.getOrigin().setValue(v3.x(), v3.y(), v3.z());
    },
    copyOrigin: function(t1, t2) {
      const o = t2.getOrigin();
      this.setOrigin(t1, o);
    },
    setBasis: function(t2, q) {
      t2.setRotation(q);
    },
    setBasisFromMatrix3: function(t2, m2) {
      const q = this.matrix3ToQuaternion(m2);
      this.setBasis(t2, q);
      this.freeQuaternion(q);
    },
    setOriginFromArray3: function(t2, a2) {
      t2.getOrigin().setValue(a2[0], a2[1], a2[2]);
    },
    setOriginFromThreeVector3: function(t2, v3) {
      t2.getOrigin().setValue(v3.x, v3.y, v3.z);
    },
    setBasisFromArray3: function(t2, a2) {
      const thQ = this.allocThreeQuaternion();
      const thE = this.allocThreeEuler();
      thE.set(a2[0], a2[1], a2[2]);
      this.setBasisFromThreeQuaternion(t2, thQ.setFromEuler(thE));
      this.freeThreeEuler(thE);
      this.freeThreeQuaternion(thQ);
    },
    setBasisFromThreeQuaternion: function(t2, a2) {
      const q = this.allocQuaternion();
      q.setX(a2.x);
      q.setY(a2.y);
      q.setZ(a2.z);
      q.setW(a2.w);
      this.setBasis(t2, q);
      this.freeQuaternion(q);
    },
    multiplyTransforms: function(t1, t2) {
      const t3 = this.allocTransform();
      this.setIdentity(t3);
      const m1 = this.getBasisAsMatrix3(t1);
      const m2 = this.getBasisAsMatrix3(t2);
      const o1 = this.getOrigin(t1);
      const o2 = this.getOrigin(t2);
      const v12 = this.multiplyMatrix3ByVector3(m1, o2);
      const v22 = this.addVector3(v12, o1);
      this.setOrigin(t3, v22);
      const m3 = this.multiplyMatrices3(m1, m2);
      this.setBasisFromMatrix3(t3, m3);
      this.freeVector3(v12);
      this.freeVector3(v22);
      return t3;
    },
    inverseTransform: function(t2) {
      const t22 = this.allocTransform();
      const m1 = this.getBasisAsMatrix3(t2);
      const o = this.getOrigin(t2);
      const m2 = this.transposeMatrix3(m1);
      const v12 = this.negativeVector3(o);
      const v22 = this.multiplyMatrix3ByVector3(m2, v12);
      this.setOrigin(t22, v22);
      this.setBasisFromMatrix3(t22, m2);
      this.freeVector3(v12);
      this.freeVector3(v22);
      return t22;
    },
    multiplyMatrices3: function(m1, m2) {
      const m3 = [];
      const v10 = this.rowOfMatrix3(m1, 0);
      const v11 = this.rowOfMatrix3(m1, 1);
      const v12 = this.rowOfMatrix3(m1, 2);
      const v20 = this.columnOfMatrix3(m2, 0);
      const v21 = this.columnOfMatrix3(m2, 1);
      const v22 = this.columnOfMatrix3(m2, 2);
      m3[0] = this.dotVectors3(v10, v20);
      m3[1] = this.dotVectors3(v10, v21);
      m3[2] = this.dotVectors3(v10, v22);
      m3[3] = this.dotVectors3(v11, v20);
      m3[4] = this.dotVectors3(v11, v21);
      m3[5] = this.dotVectors3(v11, v22);
      m3[6] = this.dotVectors3(v12, v20);
      m3[7] = this.dotVectors3(v12, v21);
      m3[8] = this.dotVectors3(v12, v22);
      this.freeVector3(v10);
      this.freeVector3(v11);
      this.freeVector3(v12);
      this.freeVector3(v20);
      this.freeVector3(v21);
      this.freeVector3(v22);
      return m3;
    },
    addVector3: function(v12, v22) {
      const v3 = this.allocVector3();
      v3.setValue(v12.x() + v22.x(), v12.y() + v22.y(), v12.z() + v22.z());
      return v3;
    },
    dotVectors3: function(v12, v22) {
      return v12.x() * v22.x() + v12.y() * v22.y() + v12.z() * v22.z();
    },
    rowOfMatrix3: function(m2, i2) {
      const v3 = this.allocVector3();
      v3.setValue(m2[i2 * 3 + 0], m2[i2 * 3 + 1], m2[i2 * 3 + 2]);
      return v3;
    },
    columnOfMatrix3: function(m2, i2) {
      const v3 = this.allocVector3();
      v3.setValue(m2[i2 + 0], m2[i2 + 3], m2[i2 + 6]);
      return v3;
    },
    negativeVector3: function(v3) {
      const v22 = this.allocVector3();
      v22.setValue(-v3.x(), -v3.y(), -v3.z());
      return v22;
    },
    multiplyMatrix3ByVector3: function(m2, v3) {
      const v4 = this.allocVector3();
      const v0 = this.rowOfMatrix3(m2, 0);
      const v12 = this.rowOfMatrix3(m2, 1);
      const v22 = this.rowOfMatrix3(m2, 2);
      const x = this.dotVectors3(v0, v3);
      const y = this.dotVectors3(v12, v3);
      const z = this.dotVectors3(v22, v3);
      v4.setValue(x, y, z);
      this.freeVector3(v0);
      this.freeVector3(v12);
      this.freeVector3(v22);
      return v4;
    },
    transposeMatrix3: function(m2) {
      const m22 = [];
      m22[0] = m2[0];
      m22[1] = m2[3];
      m22[2] = m2[6];
      m22[3] = m2[1];
      m22[4] = m2[4];
      m22[5] = m2[7];
      m22[6] = m2[2];
      m22[7] = m2[5];
      m22[8] = m2[8];
      return m22;
    },
    quaternionToMatrix3: function(q) {
      const m2 = [];
      const x = q.x();
      const y = q.y();
      const z = q.z();
      const w = q.w();
      const xx = x * x;
      const yy = y * y;
      const zz = z * z;
      const xy = x * y;
      const yz = y * z;
      const zx = z * x;
      const xw = x * w;
      const yw = y * w;
      const zw = z * w;
      m2[0] = 1 - 2 * (yy + zz);
      m2[1] = 2 * (xy - zw);
      m2[2] = 2 * (zx + yw);
      m2[3] = 2 * (xy + zw);
      m2[4] = 1 - 2 * (zz + xx);
      m2[5] = 2 * (yz - xw);
      m2[6] = 2 * (zx - yw);
      m2[7] = 2 * (yz + xw);
      m2[8] = 1 - 2 * (xx + yy);
      return m2;
    },
    matrix3ToQuaternion: function(m2) {
      const t2 = m2[0] + m2[4] + m2[8];
      let s, x, y, z, w;
      if (t2 > 0) {
        s = Math.sqrt(t2 + 1) * 2;
        w = 0.25 * s;
        x = (m2[7] - m2[5]) / s;
        y = (m2[2] - m2[6]) / s;
        z = (m2[3] - m2[1]) / s;
      } else if (m2[0] > m2[4] && m2[0] > m2[8]) {
        s = Math.sqrt(1 + m2[0] - m2[4] - m2[8]) * 2;
        w = (m2[7] - m2[5]) / s;
        x = 0.25 * s;
        y = (m2[1] + m2[3]) / s;
        z = (m2[2] + m2[6]) / s;
      } else if (m2[4] > m2[8]) {
        s = Math.sqrt(1 + m2[4] - m2[0] - m2[8]) * 2;
        w = (m2[2] - m2[6]) / s;
        x = (m2[1] + m2[3]) / s;
        y = 0.25 * s;
        z = (m2[5] + m2[7]) / s;
      } else {
        s = Math.sqrt(1 + m2[8] - m2[0] - m2[4]) * 2;
        w = (m2[3] - m2[1]) / s;
        x = (m2[2] + m2[6]) / s;
        y = (m2[5] + m2[7]) / s;
        z = 0.25 * s;
      }
      const q = this.allocQuaternion();
      q.setX(x);
      q.setY(y);
      q.setZ(z);
      q.setW(w);
      return q;
    }
  };
  function RigidBody(mesh, world2, params, manager) {
    this.mesh = mesh;
    this.world = world2;
    this.params = params;
    this.manager = manager;
    this.body = null;
    this.bone = null;
    this.boneOffsetForm = null;
    this.boneOffsetFormInverse = null;
    this._init();
  }
  RigidBody.prototype = {
    constructor: MMDPhysics2.RigidBody,
    reset: function() {
      this._setTransformFromBone();
      return this;
    },
    updateFromBone: function() {
      if (this.params.boneIndex !== -1 && this.params.type === 0) {
        this._setTransformFromBone();
      }
      return this;
    },
    updateBone: function() {
      if (this.params.type === 0 || this.params.boneIndex === -1) {
        return this;
      }
      this._updateBoneRotation();
      if (this.params.type === 1) {
        this._updateBonePosition();
      }
      this.bone.updateMatrixWorld(true);
      if (this.params.type === 2) {
        this._setPositionFromBone();
      }
      return this;
    },
    _init: function() {
      function generateShape(p) {
        switch (p.shapeType) {
          case 0:
            return new Ammo.btSphereShape(p.width);
          case 1:
            return new Ammo.btBoxShape(new Ammo.btVector3(p.width, p.height, p.depth));
          case 2:
            return new Ammo.btCapsuleShape(p.width, p.height);
          default:
            throw `unknown shape type ${p.shapeType}`;
        }
      }
      const manager = this.manager;
      const params = this.params;
      const bones = this.mesh.skeleton.bones;
      const bone = params.boneIndex === -1 ? new Bone() : bones[params.boneIndex];
      const shape = generateShape(params);
      const weight = params.type === 0 ? 0 : params.weight;
      const localInertia = manager.allocVector3();
      localInertia.setValue(0, 0, 0);
      if (weight !== 0) {
        shape.calculateLocalInertia(weight, localInertia);
      }
      const boneOffsetForm = manager.allocTransform();
      manager.setIdentity(boneOffsetForm);
      manager.setOriginFromArray3(boneOffsetForm, params.position);
      manager.setBasisFromArray3(boneOffsetForm, params.rotation);
      const vector2 = manager.allocThreeVector3();
      const boneForm = manager.allocTransform();
      manager.setIdentity(boneForm);
      manager.setOriginFromThreeVector3(boneForm, bone.getWorldPosition(vector2));
      const form = manager.multiplyTransforms(boneForm, boneOffsetForm);
      const state = new Ammo.btDefaultMotionState(form);
      const info = new Ammo.btRigidBodyConstructionInfo(weight, state, shape, localInertia);
      info.set_m_friction(params.friction);
      info.set_m_restitution(params.restitution);
      const body = new Ammo.btRigidBody(info);
      if (params.type === 0) {
        body.setCollisionFlags(body.getCollisionFlags() | 2);
        body.setActivationState(4);
      }
      body.setDamping(params.positionDamping, params.rotationDamping);
      body.setSleepingThresholds(0, 0);
      this.world.addRigidBody(body, 1 << params.groupIndex, params.groupTarget);
      this.body = body;
      this.bone = bone;
      this.boneOffsetForm = boneOffsetForm;
      this.boneOffsetFormInverse = manager.inverseTransform(boneOffsetForm);
      manager.freeVector3(localInertia);
      manager.freeTransform(form);
      manager.freeTransform(boneForm);
      manager.freeThreeVector3(vector2);
    },
    _getBoneTransform: function() {
      const manager = this.manager;
      const p = manager.allocThreeVector3();
      const q = manager.allocThreeQuaternion();
      const s = manager.allocThreeVector3();
      this.bone.matrixWorld.decompose(p, q, s);
      const tr = manager.allocTransform();
      manager.setOriginFromThreeVector3(tr, p);
      manager.setBasisFromThreeQuaternion(tr, q);
      const form = manager.multiplyTransforms(tr, this.boneOffsetForm);
      manager.freeTransform(tr);
      manager.freeThreeVector3(s);
      manager.freeThreeQuaternion(q);
      manager.freeThreeVector3(p);
      return form;
    },
    _getWorldTransformForBone: function() {
      const manager = this.manager;
      const tr = this.body.getCenterOfMassTransform();
      return manager.multiplyTransforms(tr, this.boneOffsetFormInverse);
    },
    _setTransformFromBone: function() {
      const manager = this.manager;
      const form = this._getBoneTransform();
      this.body.setCenterOfMassTransform(form);
      this.body.getMotionState().setWorldTransform(form);
      manager.freeTransform(form);
    },
    _setPositionFromBone: function() {
      const manager = this.manager;
      const form = this._getBoneTransform();
      const tr = manager.allocTransform();
      this.body.getMotionState().getWorldTransform(tr);
      manager.copyOrigin(tr, form);
      this.body.setCenterOfMassTransform(tr);
      this.body.getMotionState().setWorldTransform(tr);
      manager.freeTransform(tr);
      manager.freeTransform(form);
    },
    _updateBoneRotation: function() {
      const manager = this.manager;
      const tr = this._getWorldTransformForBone();
      const q = manager.getBasis(tr);
      const thQ = manager.allocThreeQuaternion();
      const thQ2 = manager.allocThreeQuaternion();
      const thQ3 = manager.allocThreeQuaternion();
      thQ.set(q.x(), q.y(), q.z(), q.w());
      thQ2.setFromRotationMatrix(this.bone.matrixWorld);
      thQ2.conjugate();
      thQ2.multiply(thQ);
      thQ3.setFromRotationMatrix(this.bone.matrix);
      this.bone.quaternion.copy(thQ2.multiply(thQ3).normalize());
      manager.freeThreeQuaternion(thQ);
      manager.freeThreeQuaternion(thQ2);
      manager.freeThreeQuaternion(thQ3);
      manager.freeQuaternion(q);
      manager.freeTransform(tr);
    },
    _updateBonePosition: function() {
      const manager = this.manager;
      const tr = this._getWorldTransformForBone();
      const thV = manager.allocThreeVector3();
      const o = manager.getOrigin(tr);
      thV.set(o.x(), o.y(), o.z());
      if (this.bone.parent) {
        this.bone.parent.worldToLocal(thV);
      }
      this.bone.position.copy(thV);
      manager.freeThreeVector3(thV);
      manager.freeTransform(tr);
    }
  };
  function Constraint(mesh, world2, bodyA, bodyB, params, manager) {
    this.mesh = mesh;
    this.world = world2;
    this.bodyA = bodyA;
    this.bodyB = bodyB;
    this.params = params;
    this.manager = manager;
    this.constraint = null;
    this._init();
  }
  Constraint.prototype = {
    constructor: Constraint,
    _init: function() {
      const manager = this.manager;
      const params = this.params;
      const bodyA = this.bodyA;
      const bodyB = this.bodyB;
      const form = manager.allocTransform();
      manager.setIdentity(form);
      manager.setOriginFromArray3(form, params.position);
      manager.setBasisFromArray3(form, params.rotation);
      const formA = manager.allocTransform();
      const formB = manager.allocTransform();
      bodyA.body.getMotionState().getWorldTransform(formA);
      bodyB.body.getMotionState().getWorldTransform(formB);
      const formInverseA = manager.inverseTransform(formA);
      const formInverseB = manager.inverseTransform(formB);
      const formA2 = manager.multiplyTransforms(formInverseA, form);
      const formB2 = manager.multiplyTransforms(formInverseB, form);
      const constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA.body, bodyB.body, formA2, formB2, true);
      const lll = manager.allocVector3();
      const lul = manager.allocVector3();
      const all = manager.allocVector3();
      const aul = manager.allocVector3();
      lll.setValue(params.translationLimitation1[0], params.translationLimitation1[1], params.translationLimitation1[2]);
      lul.setValue(params.translationLimitation2[0], params.translationLimitation2[1], params.translationLimitation2[2]);
      all.setValue(params.rotationLimitation1[0], params.rotationLimitation1[1], params.rotationLimitation1[2]);
      aul.setValue(params.rotationLimitation2[0], params.rotationLimitation2[1], params.rotationLimitation2[2]);
      constraint.setLinearLowerLimit(lll);
      constraint.setLinearUpperLimit(lul);
      constraint.setAngularLowerLimit(all);
      constraint.setAngularUpperLimit(aul);
      for (let i2 = 0; i2 < 3; i2++) {
        if (params.springPosition[i2] !== 0) {
          constraint.enableSpring(i2, true);
          constraint.setStiffness(i2, params.springPosition[i2]);
        }
      }
      for (let i2 = 0; i2 < 3; i2++) {
        if (params.springRotation[i2] !== 0) {
          constraint.enableSpring(i2 + 3, true);
          constraint.setStiffness(i2 + 3, params.springRotation[i2]);
        }
      }
      if (constraint.setParam !== void 0) {
        for (let i2 = 0; i2 < 6; i2++) {
          constraint.setParam(2, 0.475, i2);
        }
      }
      this.world.addConstraint(constraint, true);
      this.constraint = constraint;
      manager.freeTransform(form);
      manager.freeTransform(formA);
      manager.freeTransform(formB);
      manager.freeTransform(formInverseA);
      manager.freeTransform(formInverseB);
      manager.freeTransform(formA2);
      manager.freeTransform(formB2);
      manager.freeVector3(lll);
      manager.freeVector3(lul);
      manager.freeVector3(all);
      manager.freeVector3(aul);
    }
  };
  function MMDPhysicsHelper(mesh, physics) {
    Object3D.call(this);
    this.root = mesh;
    this.physics = physics;
    this.matrix.copy(mesh.matrixWorld);
    this.matrixAutoUpdate = false;
    this.materials = [];
    this.materials.push(new MeshBasicMaterial({
      color: new Color(16746632),
      wireframe: true,
      depthTest: false,
      depthWrite: false,
      opacity: 0.25,
      transparent: true
    }));
    this.materials.push(new MeshBasicMaterial({
      color: new Color(8978312),
      wireframe: true,
      depthTest: false,
      depthWrite: false,
      opacity: 0.25,
      transparent: true
    }));
    this.materials.push(new MeshBasicMaterial({
      color: new Color(8947967),
      wireframe: true,
      depthTest: false,
      depthWrite: false,
      opacity: 0.25,
      transparent: true
    }));
    this._init();
  }
  MMDPhysicsHelper.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: MMDPhysicsHelper,
    updateMatrixWorld: (() => {
      const position = new Vector3();
      const quaternion = new Quaternion();
      const scale = new Vector3();
      const matrixWorldInv = new Matrix4();
      return function updateMatrixWorld(force) {
        const mesh = this.root;
        if (this.visible) {
          const bodies = this.physics.bodies;
          matrixWorldInv.copy(mesh.matrixWorld).decompose(position, quaternion, scale).compose(position, quaternion, scale.set(1, 1, 1)).invert();
          for (let i2 = 0, il = bodies.length; i2 < il; i2++) {
            const body = bodies[i2].body;
            const child = this.children[i2];
            const tr = body.getCenterOfMassTransform();
            const origin = tr.getOrigin();
            const rotation = tr.getRotation();
            child.position.set(origin.x(), origin.y(), origin.z()).applyMatrix4(matrixWorldInv);
            child.quaternion.setFromRotationMatrix(matrixWorldInv).multiply(quaternion.set(rotation.x(), rotation.y(), rotation.z(), rotation.w()));
          }
        }
        this.matrix.copy(mesh.matrixWorld).decompose(position, quaternion, scale).compose(position, quaternion, scale.set(1, 1, 1));
        Object3D.prototype.updateMatrixWorld.call(this, force);
      };
    })(),
    _init: function() {
      const bodies = this.physics.bodies;
      function createGeometry(param) {
        switch (param.shapeType) {
          case 0:
            return new SphereGeometry(param.width, 16, 8);
          case 1:
            return new BoxGeometry(param.width * 2, param.height * 2, param.depth * 2, 8, 8, 8);
          case 2:
            return new createCapsuleGeometry(param.width, param.height, 16, 8);
          default:
            return null;
        }
      }
      function createCapsuleGeometry(radius, cylinderHeight, segmentsRadius, segmentsHeight) {
        const geometry2 = new CylinderGeometry(radius, radius, cylinderHeight, segmentsRadius, segmentsHeight, true);
        const upperSphere = new Mesh(new SphereGeometry(radius, segmentsRadius, segmentsHeight, 0, Math.PI * 2, 0, Math.PI / 2));
        const lowerSphere = new Mesh(new SphereGeometry(radius, segmentsRadius, segmentsHeight, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2));
        upperSphere.position.set(0, cylinderHeight / 2, 0);
        lowerSphere.position.set(0, -cylinderHeight / 2, 0);
        upperSphere.updateMatrix();
        lowerSphere.updateMatrix();
        geometry2.merge(upperSphere.geometry, upperSphere.matrix);
        geometry2.merge(lowerSphere.geometry, lowerSphere.matrix);
        return geometry2;
      }
      for (let i2 = 0, il = bodies.length; i2 < il; i2++) {
        const param = bodies[i2].params;
        this.add(new Mesh(createGeometry(param), this.materials[param.type]));
      }
    }
  });
  return MMDPhysics2;
})();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/animation/MMDAnimationHelper.js
var MMDAnimationHelper = (() => {
  function MMDAnimationHelper2(params) {
    params = params || {};
    this.meshes = [];
    this.camera = null;
    this.cameraTarget = new Object3D();
    this.cameraTarget.name = "target";
    this.audio = null;
    this.audioManager = null;
    this.objects = /* @__PURE__ */ new WeakMap();
    this.configuration = {
      sync: params.sync !== void 0 ? params.sync : true,
      afterglow: params.afterglow !== void 0 ? params.afterglow : 0,
      resetPhysicsOnLoop: params.resetPhysicsOnLoop !== void 0 ? params.resetPhysicsOnLoop : true
    };
    this.enabled = {
      animation: true,
      ik: true,
      grant: true,
      physics: true,
      cameraAnimation: true
    };
    this.onBeforePhysics = () => {
    };
    this.sharedPhysics = false;
    this.masterPhysics = null;
  }
  MMDAnimationHelper2.prototype = {
    constructor: MMDAnimationHelper2,
    add: function(object, params) {
      params = params || {};
      if (object.isSkinnedMesh) {
        this._addMesh(object, params);
      } else if (object.isCamera) {
        this._setupCamera(object, params);
      } else if (object.type === "Audio") {
        this._setupAudio(object, params);
      } else {
        throw new Error("THREE.MMDAnimationHelper.add: accepts only THREE.SkinnedMesh or THREE.Camera or THREE.Audio instance.");
      }
      if (this.configuration.sync)
        this._syncDuration();
      return this;
    },
    remove: function(object) {
      if (object.isSkinnedMesh) {
        this._removeMesh(object);
      } else if (object.isCamera) {
        this._clearCamera(object);
      } else if (object.type === "Audio") {
        this._clearAudio(object);
      } else {
        throw new Error("THREE.MMDAnimationHelper.remove: accepts only THREE.SkinnedMesh or THREE.Camera or THREE.Audio instance.");
      }
      if (this.configuration.sync)
        this._syncDuration();
      return this;
    },
    update: function(delta) {
      if (this.audioManager !== null)
        this.audioManager.control(delta);
      for (let i2 = 0; i2 < this.meshes.length; i2++) {
        this._animateMesh(this.meshes[i2], delta);
      }
      if (this.sharedPhysics)
        this._updateSharedPhysics(delta);
      if (this.camera !== null)
        this._animateCamera(this.camera, delta);
      return this;
    },
    pose: function(mesh, vpd, params) {
      params = params || {};
      if (params.resetPose !== false)
        mesh.pose();
      const bones = mesh.skeleton.bones;
      const boneParams = vpd.bones;
      const boneNameDictionary = {};
      for (let i2 = 0, il = bones.length; i2 < il; i2++) {
        boneNameDictionary[bones[i2].name] = i2;
      }
      const vector2 = new Vector3();
      const quaternion = new Quaternion();
      for (let i2 = 0, il = boneParams.length; i2 < il; i2++) {
        const boneParam = boneParams[i2];
        const boneIndex = boneNameDictionary[boneParam.name];
        if (boneIndex === void 0)
          continue;
        const bone = bones[boneIndex];
        bone.position.add(vector2.fromArray(boneParam.translation));
        bone.quaternion.multiply(quaternion.fromArray(boneParam.quaternion));
      }
      mesh.updateMatrixWorld(true);
      if (params.ik !== false) {
        this._createCCDIKSolver(mesh).update(params.saveOriginalBonesBeforeIK);
      }
      if (params.grant !== false) {
        this.createGrantSolver(mesh).update();
      }
      return this;
    },
    enable: function(key, enabled) {
      if (this.enabled[key] === void 0) {
        throw new Error(`THREE.MMDAnimationHelper.enable: unknown key ${key}`);
      }
      this.enabled[key] = enabled;
      if (key === "physics") {
        for (let i2 = 0, il = this.meshes.length; i2 < il; i2++) {
          this._optimizeIK(this.meshes[i2], enabled);
        }
      }
      return this;
    },
    createGrantSolver: function(mesh) {
      return new GrantSolver(mesh, mesh.geometry.userData.MMD.grants);
    },
    _addMesh: function(mesh, params) {
      if (this.meshes.indexOf(mesh) >= 0) {
        throw new Error(`THREE.MMDAnimationHelper._addMesh: SkinnedMesh '${mesh.name}' has already been added.`);
      }
      this.meshes.push(mesh);
      this.objects.set(mesh, {
        looped: false
      });
      this._setupMeshAnimation(mesh, params.animation);
      if (params.physics !== false) {
        this._setupMeshPhysics(mesh, params);
      }
      return this;
    },
    _setupCamera: function(camera, params) {
      if (this.camera === camera) {
        throw new Error(`THREE.MMDAnimationHelper._setupCamera: Camera '${camera.name}' has already been set.`);
      }
      if (this.camera)
        this.clearCamera(this.camera);
      this.camera = camera;
      camera.add(this.cameraTarget);
      this.objects.set(camera, {});
      if (params.animation !== void 0) {
        this._setupCameraAnimation(camera, params.animation);
      }
      return this;
    },
    _setupAudio: function(audio, params) {
      if (this.audio === audio) {
        throw new Error(`THREE.MMDAnimationHelper._setupAudio: Audio '${audio.name}' has already been set.`);
      }
      if (this.audio)
        this.clearAudio(this.audio);
      this.audio = audio;
      this.audioManager = new AudioManager(audio, params);
      this.objects.set(this.audioManager, {
        duration: this.audioManager.duration
      });
      return this;
    },
    _removeMesh: function(mesh) {
      let found = false;
      let writeIndex = 0;
      for (let i2 = 0, il = this.meshes.length; i2 < il; i2++) {
        if (this.meshes[i2] === mesh) {
          this.objects.delete(mesh);
          found = true;
          continue;
        }
        this.meshes[writeIndex++] = this.meshes[i2];
      }
      if (!found) {
        throw new Error(`THREE.MMDAnimationHelper._removeMesh: SkinnedMesh '${mesh.name}' has not been added yet.`);
      }
      this.meshes.length = writeIndex;
      return this;
    },
    _clearCamera: function(camera) {
      if (camera !== this.camera) {
        throw new Error(`THREE.MMDAnimationHelper._clearCamera: Camera '${camera.name}' has not been set yet.`);
      }
      this.camera.remove(this.cameraTarget);
      this.objects.delete(this.camera);
      this.camera = null;
      return this;
    },
    _clearAudio: function(audio) {
      if (audio !== this.audio) {
        throw new Error(`THREE.MMDAnimationHelper._clearAudio: Audio '${audio.name}' has not been set yet.`);
      }
      this.objects.delete(this.audioManager);
      this.audio = null;
      this.audioManager = null;
      return this;
    },
    _setupMeshAnimation: function(mesh, animation) {
      const objects = this.objects.get(mesh);
      if (animation !== void 0) {
        const animations = Array.isArray(animation) ? animation : [animation];
        objects.mixer = new AnimationMixer(mesh);
        for (let i2 = 0, il = animations.length; i2 < il; i2++) {
          objects.mixer.clipAction(animations[i2]).play();
        }
        objects.mixer.addEventListener("loop", (event) => {
          const tracks = event.action._clip.tracks;
          if (tracks.length > 0 && tracks[0].name.slice(0, 6) !== ".bones")
            return;
          objects.looped = true;
        });
      }
      objects.ikSolver = this._createCCDIKSolver(mesh);
      objects.grantSolver = this.createGrantSolver(mesh);
      return this;
    },
    _setupCameraAnimation: function(camera, animation) {
      const animations = Array.isArray(animation) ? animation : [animation];
      const objects = this.objects.get(camera);
      objects.mixer = new AnimationMixer(camera);
      for (let i2 = 0, il = animations.length; i2 < il; i2++) {
        objects.mixer.clipAction(animations[i2]).play();
      }
    },
    _setupMeshPhysics: function(mesh, params) {
      const objects = this.objects.get(mesh);
      if (params.world === void 0 && this.sharedPhysics) {
        const masterPhysics = this._getMasterPhysics();
        if (masterPhysics !== null)
          world = masterPhysics.world;
      }
      objects.physics = this._createMMDPhysics(mesh, params);
      if (objects.mixer && params.animationWarmup !== false) {
        this._animateMesh(mesh, 0);
        objects.physics.reset();
      }
      objects.physics.warmup(params.warmup !== void 0 ? params.warmup : 60);
      this._optimizeIK(mesh, true);
    },
    _animateMesh: function(mesh, delta) {
      const objects = this.objects.get(mesh);
      const mixer = objects.mixer;
      const ikSolver = objects.ikSolver;
      const grantSolver = objects.grantSolver;
      const physics = objects.physics;
      const looped = objects.looped;
      if (mixer && this.enabled.animation) {
        this._restoreBones(mesh);
        mixer.update(delta);
        this._saveBones(mesh);
        if (ikSolver && this.enabled.ik) {
          mesh.updateMatrixWorld(true);
          ikSolver.update();
        }
        if (grantSolver && this.enabled.grant) {
          grantSolver.update();
        }
      }
      if (looped === true && this.enabled.physics) {
        if (physics && this.configuration.resetPhysicsOnLoop)
          physics.reset();
        objects.looped = false;
      }
      if (physics && this.enabled.physics && !this.sharedPhysics) {
        this.onBeforePhysics(mesh);
        physics.update(delta);
      }
    },
    _animateCamera: function(camera, delta) {
      const mixer = this.objects.get(camera).mixer;
      if (mixer && this.enabled.cameraAnimation) {
        mixer.update(delta);
        camera.updateProjectionMatrix();
        camera.up.set(0, 1, 0);
        camera.up.applyQuaternion(camera.quaternion);
        camera.lookAt(this.cameraTarget.position);
      }
    },
    _optimizeIK: function(mesh, physicsEnabled) {
      const iks = mesh.geometry.userData.MMD.iks;
      const bones = mesh.geometry.userData.MMD.bones;
      for (let i2 = 0, il = iks.length; i2 < il; i2++) {
        const ik = iks[i2];
        const links = ik.links;
        for (let j2 = 0, jl2 = links.length; j2 < jl2; j2++) {
          const link = links[j2];
          if (physicsEnabled === true) {
            link.enabled = bones[link.index].rigidBodyType > 0 ? false : true;
          } else {
            link.enabled = true;
          }
        }
      }
    },
    _createCCDIKSolver: function(mesh) {
      if (CCDIKSolver === void 0) {
        throw new Error("THREE.MMDAnimationHelper: Import CCDIKSolver.");
      }
      return new CCDIKSolver(mesh, mesh.geometry.userData.MMD.iks);
    },
    _createMMDPhysics: function(mesh, params) {
      if (MMDPhysics === void 0) {
        throw new Error("THREE.MMDPhysics: Import MMDPhysics.");
      }
      return new MMDPhysics(mesh, mesh.geometry.userData.MMD.rigidBodies, mesh.geometry.userData.MMD.constraints, params);
    },
    _syncDuration: function() {
      let max2 = 0;
      const objects = this.objects;
      const meshes = this.meshes;
      const camera = this.camera;
      const audioManager = this.audioManager;
      for (let i2 = 0, il = meshes.length; i2 < il; i2++) {
        var mixer = this.objects.get(meshes[i2]).mixer;
        if (mixer === void 0)
          continue;
        for (let j2 = 0; j2 < mixer._actions.length; j2++) {
          var clip = mixer._actions[j2]._clip;
          if (!objects.has(clip)) {
            objects.set(clip, {
              duration: clip.duration
            });
          }
          max2 = Math.max(max2, objects.get(clip).duration);
        }
      }
      if (camera !== null) {
        var mixer = this.objects.get(camera).mixer;
        if (mixer !== void 0) {
          for (let i2 = 0, il = mixer._actions.length; i2 < il; i2++) {
            var clip = mixer._actions[i2]._clip;
            if (!objects.has(clip)) {
              objects.set(clip, {
                duration: clip.duration
              });
            }
            max2 = Math.max(max2, objects.get(clip).duration);
          }
        }
      }
      if (audioManager !== null) {
        max2 = Math.max(max2, objects.get(audioManager).duration);
      }
      max2 += this.configuration.afterglow;
      for (let i2 = 0, il = this.meshes.length; i2 < il; i2++) {
        var mixer = this.objects.get(this.meshes[i2]).mixer;
        if (mixer === void 0)
          continue;
        for (let j2 = 0, jl2 = mixer._actions.length; j2 < jl2; j2++) {
          mixer._actions[j2]._clip.duration = max2;
        }
      }
      if (camera !== null) {
        var mixer = this.objects.get(camera).mixer;
        if (mixer !== void 0) {
          for (let i2 = 0, il = mixer._actions.length; i2 < il; i2++) {
            mixer._actions[i2]._clip.duration = max2;
          }
        }
      }
      if (audioManager !== null) {
        audioManager.duration = max2;
      }
    },
    _updatePropertyMixersBuffer: function(mesh) {
      const mixer = this.objects.get(mesh).mixer;
      const propertyMixers = mixer._bindings;
      const accuIndex = mixer._accuIndex;
      for (let i2 = 0, il = propertyMixers.length; i2 < il; i2++) {
        const propertyMixer = propertyMixers[i2];
        const buffer2 = propertyMixer.buffer;
        const stride = propertyMixer.valueSize;
        const offset = (accuIndex + 1) * stride;
        propertyMixer.binding.getValue(buffer2, offset);
      }
    },
    _saveBones: function(mesh) {
      const objects = this.objects.get(mesh);
      const bones = mesh.skeleton.bones;
      let backupBones = objects.backupBones;
      if (backupBones === void 0) {
        backupBones = new Float32Array(bones.length * 7);
        objects.backupBones = backupBones;
      }
      for (let i2 = 0, il = bones.length; i2 < il; i2++) {
        const bone = bones[i2];
        bone.position.toArray(backupBones, i2 * 7);
        bone.quaternion.toArray(backupBones, i2 * 7 + 3);
      }
    },
    _restoreBones: function(mesh) {
      const objects = this.objects.get(mesh);
      const backupBones = objects.backupBones;
      if (backupBones === void 0)
        return;
      const bones = mesh.skeleton.bones;
      for (let i2 = 0, il = bones.length; i2 < il; i2++) {
        const bone = bones[i2];
        bone.position.fromArray(backupBones, i2 * 7);
        bone.quaternion.fromArray(backupBones, i2 * 7 + 3);
      }
    },
    _getMasterPhysics: function() {
      if (this.masterPhysics !== null)
        return this.masterPhysics;
      for (let i2 = 0, il = this.meshes.length; i2 < il; i2++) {
        const physics = this.meshes[i2].physics;
        if (physics !== void 0 && physics !== null) {
          this.masterPhysics = physics;
          return this.masterPhysics;
        }
      }
      return null;
    },
    _updateSharedPhysics: function(delta) {
      if (this.meshes.length === 0 || !this.enabled.physics || !this.sharedPhysics)
        return;
      const physics = this._getMasterPhysics();
      if (physics === null)
        return;
      for (let i2 = 0, il = this.meshes.length; i2 < il; i2++) {
        var p = this.meshes[i2].physics;
        if (p !== null && p !== void 0) {
          p.updateRigidBodies();
        }
      }
      physics.stepSimulation(delta);
      for (let i2 = 0, il = this.meshes.length; i2 < il; i2++) {
        var p = this.meshes[i2].physics;
        if (p !== null && p !== void 0) {
          p.updateBones();
        }
      }
    }
  };
  function AudioManager(audio, params) {
    params = params || {};
    this.audio = audio;
    this.elapsedTime = 0;
    this.currentTime = 0;
    this.delayTime = params.delayTime !== void 0 ? params.delayTime : 0;
    this.audioDuration = this.audio.buffer.duration;
    this.duration = this.audioDuration + this.delayTime;
  }
  AudioManager.prototype = {
    constructor: AudioManager,
    control: function(delta) {
      this.elapsed += delta;
      this.currentTime += delta;
      if (this._shouldStopAudio())
        this.audio.stop();
      if (this._shouldStartAudio())
        this.audio.play();
      return this;
    },
    _shouldStartAudio: function() {
      if (this.audio.isPlaying)
        return false;
      while (this.currentTime >= this.duration) {
        this.currentTime -= this.duration;
      }
      if (this.currentTime < this.delayTime)
        return false;
      if (this.currentTime - this.delayTime > this.audioDuration)
        return false;
      return true;
    },
    _shouldStopAudio: function() {
      return this.audio.isPlaying && this.currentTime >= this.duration;
    }
  };
  function GrantSolver(mesh, grants) {
    this.mesh = mesh;
    this.grants = grants || [];
  }
  GrantSolver.prototype = {
    constructor: GrantSolver,
    update: (() => {
      const quaternion = new Quaternion();
      return function() {
        const bones = this.mesh.skeleton.bones;
        const grants = this.grants;
        for (let i2 = 0, il = grants.length; i2 < il; i2++) {
          const grant = grants[i2];
          const bone = bones[grant.index];
          const parentBone = bones[grant.parentIndex];
          if (grant.isLocal) {
            if (grant.affectPosition)
              ;
            if (grant.affectRotation)
              ;
          } else {
            if (grant.affectPosition)
              ;
            if (grant.affectRotation) {
              quaternion.set(0, 0, 0, 1);
              quaternion.slerp(parentBone.quaternion, grant.ratio);
              bone.quaternion.multiply(quaternion);
            }
          }
        }
        return this;
      };
    })()
  };
  return MMDAnimationHelper2;
})();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/objects/Reflector.js
var Reflector = class extends Mesh {
  constructor(geometry2, options = {}) {
    super(geometry2);
    this.type = "Reflector";
    const scope = this;
    const color3 = options.color !== void 0 ? new Color(options.color) : new Color(8355711);
    const textureWidth = options.textureWidth || 512;
    const textureHeight = options.textureHeight || 512;
    const clipBias = options.clipBias || 0;
    const shader = options.shader || Reflector.ReflectorShader;
    const reflectorPlane = new Plane();
    const normal = new Vector3();
    const reflectorWorldPosition = new Vector3();
    const cameraWorldPosition = new Vector3();
    const rotationMatrix2 = new Matrix4();
    const lookAtPosition = new Vector3(0, 0, -1);
    const clipPlane = new Vector4();
    const view = new Vector3();
    const target = new Vector3();
    const q = new Vector4();
    const textureMatrix = new Matrix4();
    const virtualCamera = new PerspectiveCamera();
    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);
    const material = new ShaderMaterial({
      uniforms: UniformsUtils.clone(shader.uniforms),
      fragmentShader: shader.fragmentShader,
      vertexShader: shader.vertexShader
    });
    material.uniforms["tDiffuse"].value = renderTarget.texture;
    material.uniforms["color"].value = color3;
    material.uniforms["textureMatrix"].value = textureMatrix;
    this.material = material;
    this.onBeforeRender = function(renderer, scene, camera) {
      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);
      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
      rotationMatrix2.extractRotation(scope.matrixWorld);
      normal.set(0, 0, 1);
      normal.applyMatrix4(rotationMatrix2);
      view.subVectors(reflectorWorldPosition, cameraWorldPosition);
      if (view.dot(normal) > 0)
        return;
      view.reflect(normal).negate();
      view.add(reflectorWorldPosition);
      rotationMatrix2.extractRotation(camera.matrixWorld);
      lookAtPosition.set(0, 0, -1);
      lookAtPosition.applyMatrix4(rotationMatrix2);
      lookAtPosition.add(cameraWorldPosition);
      target.subVectors(reflectorWorldPosition, lookAtPosition);
      target.reflect(normal).negate();
      target.add(reflectorWorldPosition);
      virtualCamera.position.copy(view);
      virtualCamera.up.set(0, 1, 0);
      virtualCamera.up.applyMatrix4(rotationMatrix2);
      virtualCamera.up.reflect(normal);
      virtualCamera.lookAt(target);
      virtualCamera.far = camera.far;
      virtualCamera.updateMatrixWorld();
      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      textureMatrix.multiply(virtualCamera.projectionMatrix);
      textureMatrix.multiply(virtualCamera.matrixWorldInverse);
      textureMatrix.multiply(scope.matrixWorld);
      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);
      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);
      const projectionMatrix = virtualCamera.projectionMatrix;
      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
      q.z = -1;
      q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
      clipPlane.multiplyScalar(2 / clipPlane.dot(q));
      projectionMatrix.elements[2] = clipPlane.x;
      projectionMatrix.elements[6] = clipPlane.y;
      projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;
      projectionMatrix.elements[14] = clipPlane.w;
      renderTarget.texture.encoding = renderer.outputEncoding;
      scope.visible = false;
      const currentRenderTarget = renderer.getRenderTarget();
      const currentXrEnabled = renderer.xr.enabled;
      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
      renderer.xr.enabled = false;
      renderer.shadowMap.autoUpdate = false;
      renderer.setRenderTarget(renderTarget);
      renderer.state.buffers.depth.setMask(true);
      if (renderer.autoClear === false)
        renderer.clear();
      renderer.render(scene, virtualCamera);
      renderer.xr.enabled = currentXrEnabled;
      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
      renderer.setRenderTarget(currentRenderTarget);
      const viewport = camera.viewport;
      if (viewport !== void 0) {
        renderer.state.viewport(viewport);
      }
      scope.visible = true;
    };
    this.getRenderTarget = function() {
      return renderTarget;
    };
    this.dispose = function() {
      renderTarget.dispose();
      scope.material.dispose();
    };
  }
};
Reflector.prototype.isReflector = true;
Reflector.ReflectorShader = {
  uniforms: {
    color: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`,
  fragmentShader: `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

		}`
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/objects/Refractor.js
var Refractor = class extends Mesh {
  constructor(geometry2, options = {}) {
    super(geometry2);
    this.type = "Refractor";
    const scope = this;
    const color3 = options.color !== void 0 ? new Color(options.color) : new Color(8355711);
    const textureWidth = options.textureWidth || 512;
    const textureHeight = options.textureHeight || 512;
    const clipBias = options.clipBias || 0;
    const shader = options.shader || Refractor.RefractorShader;
    const virtualCamera = new PerspectiveCamera();
    virtualCamera.matrixAutoUpdate = false;
    virtualCamera.userData.refractor = true;
    const refractorPlane = new Plane();
    const textureMatrix = new Matrix4();
    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);
    this.material = new ShaderMaterial({
      uniforms: UniformsUtils.clone(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      transparent: true
    });
    this.material.uniforms["color"].value = color3;
    this.material.uniforms["tDiffuse"].value = renderTarget.texture;
    this.material.uniforms["textureMatrix"].value = textureMatrix;
    const visible = function() {
      const refractorWorldPosition = new Vector3();
      const cameraWorldPosition = new Vector3();
      const rotationMatrix2 = new Matrix4();
      const view = new Vector3();
      const normal = new Vector3();
      return function visible2(camera) {
        refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);
        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
        view.subVectors(refractorWorldPosition, cameraWorldPosition);
        rotationMatrix2.extractRotation(scope.matrixWorld);
        normal.set(0, 0, 1);
        normal.applyMatrix4(rotationMatrix2);
        return view.dot(normal) < 0;
      };
    }();
    const updateRefractorPlane = function() {
      const normal = new Vector3();
      const position = new Vector3();
      const quaternion = new Quaternion();
      const scale = new Vector3();
      return function updateRefractorPlane2() {
        scope.matrixWorld.decompose(position, quaternion, scale);
        normal.set(0, 0, 1).applyQuaternion(quaternion).normalize();
        normal.negate();
        refractorPlane.setFromNormalAndCoplanarPoint(normal, position);
      };
    }();
    const updateVirtualCamera = function() {
      const clipPlane = new Plane();
      const clipVector = new Vector4();
      const q = new Vector4();
      return function updateVirtualCamera2(camera) {
        virtualCamera.matrixWorld.copy(camera.matrixWorld);
        virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();
        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
        virtualCamera.far = camera.far;
        clipPlane.copy(refractorPlane);
        clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
        clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant);
        const projectionMatrix = virtualCamera.projectionMatrix;
        q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
        q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
        q.z = -1;
        q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
        clipVector.multiplyScalar(2 / clipVector.dot(q));
        projectionMatrix.elements[2] = clipVector.x;
        projectionMatrix.elements[6] = clipVector.y;
        projectionMatrix.elements[10] = clipVector.z + 1 - clipBias;
        projectionMatrix.elements[14] = clipVector.w;
      };
    }();
    function updateTextureMatrix(camera) {
      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      textureMatrix.multiply(camera.projectionMatrix);
      textureMatrix.multiply(camera.matrixWorldInverse);
      textureMatrix.multiply(scope.matrixWorld);
    }
    function render(renderer, scene, camera) {
      scope.visible = false;
      const currentRenderTarget = renderer.getRenderTarget();
      const currentXrEnabled = renderer.xr.enabled;
      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
      renderer.xr.enabled = false;
      renderer.shadowMap.autoUpdate = false;
      renderer.setRenderTarget(renderTarget);
      if (renderer.autoClear === false)
        renderer.clear();
      renderer.render(scene, virtualCamera);
      renderer.xr.enabled = currentXrEnabled;
      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
      renderer.setRenderTarget(currentRenderTarget);
      const viewport = camera.viewport;
      if (viewport !== void 0) {
        renderer.state.viewport(viewport);
      }
      scope.visible = true;
    }
    this.onBeforeRender = function(renderer, scene, camera) {
      renderTarget.texture.encoding = renderer.outputEncoding;
      if (camera.userData.refractor === true)
        return;
      if (!visible(camera) === true)
        return;
      updateRefractorPlane();
      updateTextureMatrix(camera);
      updateVirtualCamera(camera);
      render(renderer, scene, camera);
    };
    this.getRenderTarget = function() {
      return renderTarget;
    };
    this.dispose = function() {
      renderTarget.dispose();
      scope.material.dispose();
    };
  }
};
Refractor.prototype.isRefractor = true;
Refractor.RefractorShader = {
  uniforms: {
    color: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: `

		uniform mat4 textureMatrix;

		varying vec4 vUv;

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform vec3 color;
		uniform sampler2D tDiffuse;

		varying vec4 vUv;

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

		}`
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/objects/ShadowMesh.js
var _shadowMatrix = new Matrix4();
var ShadowMesh = class extends Mesh {
  constructor(mesh) {
    const shadowMaterial = new MeshBasicMaterial({
      color: 0,
      transparent: true,
      opacity: 0.6,
      depthWrite: false
    });
    super(mesh.geometry, shadowMaterial);
    this.meshMatrix = mesh.matrixWorld;
    this.frustumCulled = false;
    this.matrixAutoUpdate = false;
  }
  update(plane, lightPosition4D) {
    const dot2 = plane.normal.x * lightPosition4D.x + plane.normal.y * lightPosition4D.y + plane.normal.z * lightPosition4D.z + -plane.constant * lightPosition4D.w;
    const sme = _shadowMatrix.elements;
    sme[0] = dot2 - lightPosition4D.x * plane.normal.x;
    sme[4] = -lightPosition4D.x * plane.normal.y;
    sme[8] = -lightPosition4D.x * plane.normal.z;
    sme[12] = -lightPosition4D.x * -plane.constant;
    sme[1] = -lightPosition4D.y * plane.normal.x;
    sme[5] = dot2 - lightPosition4D.y * plane.normal.y;
    sme[9] = -lightPosition4D.y * plane.normal.z;
    sme[13] = -lightPosition4D.y * -plane.constant;
    sme[2] = -lightPosition4D.z * plane.normal.x;
    sme[6] = -lightPosition4D.z * plane.normal.y;
    sme[10] = dot2 - lightPosition4D.z * plane.normal.z;
    sme[14] = -lightPosition4D.z * -plane.constant;
    sme[3] = -lightPosition4D.w * plane.normal.x;
    sme[7] = -lightPosition4D.w * plane.normal.y;
    sme[11] = -lightPosition4D.w * plane.normal.z;
    sme[15] = dot2 - lightPosition4D.w * -plane.constant;
    this.matrix.multiplyMatrices(_shadowMatrix, this.meshMatrix);
  }
};
ShadowMesh.prototype.isShadowMesh = true;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/objects/Lensflare.js
var Lensflare = class extends Mesh {
  constructor() {
    super(Lensflare.Geometry, new MeshBasicMaterial({
      opacity: 0,
      transparent: true
    }));
    this.type = "Lensflare";
    this.frustumCulled = false;
    this.renderOrder = Infinity;
    const positionScreen = new Vector3();
    const positionView2 = new Vector3();
    const tempMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat);
    tempMap.minFilter = NearestFilter;
    tempMap.magFilter = NearestFilter;
    tempMap.wrapS = ClampToEdgeWrapping;
    tempMap.wrapT = ClampToEdgeWrapping;
    const occlusionMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat);
    occlusionMap.minFilter = NearestFilter;
    occlusionMap.magFilter = NearestFilter;
    occlusionMap.wrapS = ClampToEdgeWrapping;
    occlusionMap.wrapT = ClampToEdgeWrapping;
    const geometry2 = Lensflare.Geometry;
    const material1a = new RawShaderMaterial({
      uniforms: {
        scale: {
          value: null
        },
        screenPosition: {
          value: null
        }
      },
      vertexShader: `

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;

				void main() {

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`,
      fragmentShader: `

				precision highp float;

				void main() {

					gl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );

				}`,
      depthTest: true,
      depthWrite: false,
      transparent: false
    });
    const material1b = new RawShaderMaterial({
      uniforms: {
        map: {
          value: tempMap
        },
        scale: {
          value: null
        },
        screenPosition: {
          value: null
        }
      },
      vertexShader: `

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;
				attribute vec2 uv;

				varying vec2 vUV;

				void main() {

					vUV = uv;

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`,
      fragmentShader: `

				precision highp float;

				uniform sampler2D map;

				varying vec2 vUV;

				void main() {

					gl_FragColor = texture2D( map, vUV );

				}`,
      depthTest: false,
      depthWrite: false,
      transparent: false
    });
    const mesh1 = new Mesh(geometry2, material1a);
    const elements = [];
    const shader = LensflareElement.Shader;
    const material2 = new RawShaderMaterial({
      uniforms: {
        map: {
          value: null
        },
        occlusionMap: {
          value: occlusionMap
        },
        color: {
          value: new Color(16777215)
        },
        scale: {
          value: new Vector2()
        },
        screenPosition: {
          value: new Vector3()
        }
      },
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      blending: AdditiveBlending,
      transparent: true,
      depthWrite: false
    });
    const mesh2 = new Mesh(geometry2, material2);
    this.addElement = function(element2) {
      elements.push(element2);
    };
    const scale = new Vector2();
    const screenPositionPixels = new Vector2();
    const validArea = new Box2();
    const viewport = new Vector4();
    this.onBeforeRender = function(renderer, scene, camera) {
      renderer.getCurrentViewport(viewport);
      const invAspect = viewport.w / viewport.z;
      const halfViewportWidth = viewport.z / 2;
      const halfViewportHeight = viewport.w / 2;
      let size2 = 16 / viewport.w;
      scale.set(size2 * invAspect, size2);
      validArea.min.set(viewport.x, viewport.y);
      validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16));
      positionView2.setFromMatrixPosition(this.matrixWorld);
      positionView2.applyMatrix4(camera.matrixWorldInverse);
      if (positionView2.z > 0)
        return;
      positionScreen.copy(positionView2).applyMatrix4(camera.projectionMatrix);
      screenPositionPixels.x = viewport.x + positionScreen.x * halfViewportWidth + halfViewportWidth - 8;
      screenPositionPixels.y = viewport.y + positionScreen.y * halfViewportHeight + halfViewportHeight - 8;
      if (validArea.containsPoint(screenPositionPixels)) {
        renderer.copyFramebufferToTexture(screenPositionPixels, tempMap);
        let uniforms = material1a.uniforms;
        uniforms["scale"].value = scale;
        uniforms["screenPosition"].value = positionScreen;
        renderer.renderBufferDirect(camera, null, geometry2, material1a, mesh1, null);
        renderer.copyFramebufferToTexture(screenPositionPixels, occlusionMap);
        uniforms = material1b.uniforms;
        uniforms["scale"].value = scale;
        uniforms["screenPosition"].value = positionScreen;
        renderer.renderBufferDirect(camera, null, geometry2, material1b, mesh1, null);
        const vecX = -positionScreen.x * 2;
        const vecY = -positionScreen.y * 2;
        for (let i2 = 0, l = elements.length; i2 < l; i2++) {
          const element2 = elements[i2];
          const uniforms2 = material2.uniforms;
          uniforms2["color"].value.copy(element2.color);
          uniforms2["map"].value = element2.texture;
          uniforms2["screenPosition"].value.x = positionScreen.x + vecX * element2.distance;
          uniforms2["screenPosition"].value.y = positionScreen.y + vecY * element2.distance;
          size2 = element2.size / viewport.w;
          const invAspect2 = viewport.w / viewport.z;
          uniforms2["scale"].value.set(size2 * invAspect2, size2);
          material2.uniformsNeedUpdate = true;
          renderer.renderBufferDirect(camera, null, geometry2, material2, mesh2, null);
        }
      }
    };
    this.dispose = function() {
      material1a.dispose();
      material1b.dispose();
      material2.dispose();
      tempMap.dispose();
      occlusionMap.dispose();
      for (let i2 = 0, l = elements.length; i2 < l; i2++) {
        elements[i2].texture.dispose();
      }
    };
  }
};
Lensflare.prototype.isLensflare = true;
var LensflareElement = class {
  constructor(texture2, size2 = 1, distance2 = 0, color3 = new Color(16777215)) {
    this.texture = texture2;
    this.size = size2;
    this.distance = distance2;
    this.color = color3;
  }
};
LensflareElement.Shader = {
  uniforms: {
    map: {
      value: null
    },
    occlusionMap: {
      value: null
    },
    color: {
      value: null
    },
    scale: {
      value: null
    },
    screenPosition: {
      value: null
    }
  },
  vertexShader: `

		precision highp float;

		uniform vec3 screenPosition;
		uniform vec2 scale;

		uniform sampler2D occlusionMap;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vUV = uv;

			vec2 pos = position.xy;

			vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );

			vVisibility =        visibility.r / 9.0;
			vVisibility *= 1.0 - visibility.g / 9.0;
			vVisibility *=       visibility.b / 9.0;

			gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );

		}`,
  fragmentShader: `

		precision highp float;

		uniform sampler2D map;
		uniform vec3 color;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vec4 texture = texture2D( map, vUV );
			texture.a *= vVisibility;
			gl_FragColor = texture;
			gl_FragColor.rgb *= color;

		}`
};
Lensflare.Geometry = function() {
  const geometry2 = new BufferGeometry();
  const float32Array = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]);
  const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
  geometry2.setIndex([0, 1, 2, 0, 2, 3]);
  geometry2.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
  geometry2.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
  return geometry2;
}();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/objects/Water.js
var Water = class extends Mesh {
  constructor(geometry2, options = {}) {
    super(geometry2);
    const scope = this;
    const textureWidth = options.textureWidth !== void 0 ? options.textureWidth : 512;
    const textureHeight = options.textureHeight !== void 0 ? options.textureHeight : 512;
    const clipBias = options.clipBias !== void 0 ? options.clipBias : 0;
    const alpha = options.alpha !== void 0 ? options.alpha : 1;
    const time = options.time !== void 0 ? options.time : 0;
    const normalSampler = options.waterNormals !== void 0 ? options.waterNormals : null;
    const sunDirection = options.sunDirection !== void 0 ? options.sunDirection : new Vector3(0.70707, 0.70707, 0);
    const sunColor = new Color(options.sunColor !== void 0 ? options.sunColor : 16777215);
    const waterColor = new Color(options.waterColor !== void 0 ? options.waterColor : 8355711);
    const eye = options.eye !== void 0 ? options.eye : new Vector3(0, 0, 0);
    const distortionScale = options.distortionScale !== void 0 ? options.distortionScale : 20;
    const side = options.side !== void 0 ? options.side : FrontSide;
    const fog = options.fog !== void 0 ? options.fog : false;
    const mirrorPlane = new Plane();
    const normal = new Vector3();
    const mirrorWorldPosition = new Vector3();
    const cameraWorldPosition = new Vector3();
    const rotationMatrix2 = new Matrix4();
    const lookAtPosition = new Vector3(0, 0, -1);
    const clipPlane = new Vector4();
    const view = new Vector3();
    const target = new Vector3();
    const q = new Vector4();
    const textureMatrix = new Matrix4();
    const mirrorCamera = new PerspectiveCamera();
    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);
    const mirrorShader = {
      uniforms: UniformsUtils.merge([UniformsLib["fog"], UniformsLib["lights"], {
        normalSampler: {
          value: null
        },
        mirrorSampler: {
          value: null
        },
        alpha: {
          value: 1
        },
        time: {
          value: 0
        },
        size: {
          value: 1
        },
        distortionScale: {
          value: 20
        },
        textureMatrix: {
          value: new Matrix4()
        },
        sunColor: {
          value: new Color(8355711)
        },
        sunDirection: {
          value: new Vector3(0.70707, 0.70707, 0)
        },
        eye: {
          value: new Vector3()
        },
        waterColor: {
          value: new Color(5592405)
        }
      }]),
      vertexShader: `
				uniform mat4 textureMatrix;
				uniform float time;

				varying vec4 mirrorCoord;
				varying vec4 worldPosition;

				#include <common>
				#include <fog_pars_vertex>
				#include <shadowmap_pars_vertex>
				#include <logdepthbuf_pars_vertex>

				void main() {
					mirrorCoord = modelMatrix * vec4( position, 1.0 );
					worldPosition = mirrorCoord.xyzw;
					mirrorCoord = textureMatrix * mirrorCoord;
					vec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );
					gl_Position = projectionMatrix * mvPosition;

				#include <beginnormal_vertex>
				#include <defaultnormal_vertex>
				#include <logdepthbuf_vertex>
				#include <fog_vertex>
				#include <shadowmap_vertex>
			}`,
      fragmentShader: `
				uniform sampler2D mirrorSampler;
				uniform float alpha;
				uniform float time;
				uniform float size;
				uniform float distortionScale;
				uniform sampler2D normalSampler;
				uniform vec3 sunColor;
				uniform vec3 sunDirection;
				uniform vec3 eye;
				uniform vec3 waterColor;

				varying vec4 mirrorCoord;
				varying vec4 worldPosition;

				vec4 getNoise( vec2 uv ) {
					vec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);
					vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );
					vec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );
					vec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );
					vec4 noise = texture2D( normalSampler, uv0 ) +
						texture2D( normalSampler, uv1 ) +
						texture2D( normalSampler, uv2 ) +
						texture2D( normalSampler, uv3 );
					return noise * 0.5 - 1.0;
				}

				void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {
					vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );
					float direction = max( 0.0, dot( eyeDirection, reflection ) );
					specularColor += pow( direction, shiny ) * sunColor * spec;
					diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;
				}

				#include <common>
				#include <packing>
				#include <bsdfs>
				#include <fog_pars_fragment>
				#include <logdepthbuf_pars_fragment>
				#include <lights_pars_begin>
				#include <shadowmap_pars_fragment>
				#include <shadowmask_pars_fragment>

				void main() {

					#include <logdepthbuf_fragment>
					vec4 noise = getNoise( worldPosition.xz * size );
					vec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );

					vec3 diffuseLight = vec3(0.0);
					vec3 specularLight = vec3(0.0);

					vec3 worldToEye = eye-worldPosition.xyz;
					vec3 eyeDirection = normalize( worldToEye );
					sunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );

					float distance = length(worldToEye);

					vec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;
					vec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );

					float theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );
					float rf0 = 0.3;
					float reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );
					vec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;
					vec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);
					vec3 outgoingLight = albedo;
					gl_FragColor = vec4( outgoingLight, alpha );

					#include <tonemapping_fragment>
					#include <fog_fragment>
				}`
    };
    const material = new ShaderMaterial({
      fragmentShader: mirrorShader.fragmentShader,
      vertexShader: mirrorShader.vertexShader,
      uniforms: UniformsUtils.clone(mirrorShader.uniforms),
      lights: true,
      side,
      fog
    });
    material.uniforms["mirrorSampler"].value = renderTarget.texture;
    material.uniforms["textureMatrix"].value = textureMatrix;
    material.uniforms["alpha"].value = alpha;
    material.uniforms["time"].value = time;
    material.uniforms["normalSampler"].value = normalSampler;
    material.uniforms["sunColor"].value = sunColor;
    material.uniforms["waterColor"].value = waterColor;
    material.uniforms["sunDirection"].value = sunDirection;
    material.uniforms["distortionScale"].value = distortionScale;
    material.uniforms["eye"].value = eye;
    scope.material = material;
    scope.onBeforeRender = function(renderer, scene, camera) {
      mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);
      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
      rotationMatrix2.extractRotation(scope.matrixWorld);
      normal.set(0, 0, 1);
      normal.applyMatrix4(rotationMatrix2);
      view.subVectors(mirrorWorldPosition, cameraWorldPosition);
      if (view.dot(normal) > 0)
        return;
      view.reflect(normal).negate();
      view.add(mirrorWorldPosition);
      rotationMatrix2.extractRotation(camera.matrixWorld);
      lookAtPosition.set(0, 0, -1);
      lookAtPosition.applyMatrix4(rotationMatrix2);
      lookAtPosition.add(cameraWorldPosition);
      target.subVectors(mirrorWorldPosition, lookAtPosition);
      target.reflect(normal).negate();
      target.add(mirrorWorldPosition);
      mirrorCamera.position.copy(view);
      mirrorCamera.up.set(0, 1, 0);
      mirrorCamera.up.applyMatrix4(rotationMatrix2);
      mirrorCamera.up.reflect(normal);
      mirrorCamera.lookAt(target);
      mirrorCamera.far = camera.far;
      mirrorCamera.updateMatrixWorld();
      mirrorCamera.projectionMatrix.copy(camera.projectionMatrix);
      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      textureMatrix.multiply(mirrorCamera.projectionMatrix);
      textureMatrix.multiply(mirrorCamera.matrixWorldInverse);
      mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);
      mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);
      clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);
      const projectionMatrix = mirrorCamera.projectionMatrix;
      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
      q.z = -1;
      q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
      clipPlane.multiplyScalar(2 / clipPlane.dot(q));
      projectionMatrix.elements[2] = clipPlane.x;
      projectionMatrix.elements[6] = clipPlane.y;
      projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;
      projectionMatrix.elements[14] = clipPlane.w;
      eye.setFromMatrixPosition(camera.matrixWorld);
      const currentRenderTarget = renderer.getRenderTarget();
      const currentXrEnabled = renderer.xr.enabled;
      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
      scope.visible = false;
      renderer.xr.enabled = false;
      renderer.shadowMap.autoUpdate = false;
      renderer.setRenderTarget(renderTarget);
      renderer.state.buffers.depth.setMask(true);
      if (renderer.autoClear === false)
        renderer.clear();
      renderer.render(scene, mirrorCamera);
      scope.visible = true;
      renderer.xr.enabled = currentXrEnabled;
      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
      renderer.setRenderTarget(currentRenderTarget);
      const viewport = camera.viewport;
      if (viewport !== void 0) {
        renderer.state.viewport(viewport);
      }
    };
  }
};
Water.prototype.isWater = true;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/objects/MarchingCubes.js
var MarchingCubes = class extends Mesh {
  constructor(resolution, material, enableUvs = false, enableColors = false, maxPolyCount = 1e4) {
    const geometry2 = new BufferGeometry();
    super(geometry2, material);
    const scope = this;
    const vlist = new Float32Array(12 * 3);
    const nlist = new Float32Array(12 * 3);
    const clist = new Float32Array(12 * 3);
    this.enableUvs = enableUvs;
    this.enableColors = enableColors;
    this.init = function(resolution2) {
      this.resolution = resolution2;
      this.isolation = 80;
      this.size = resolution2;
      this.size2 = this.size * this.size;
      this.size3 = this.size2 * this.size;
      this.halfsize = this.size / 2;
      this.delta = 2 / this.size;
      this.yd = this.size;
      this.zd = this.size2;
      this.field = new Float32Array(this.size3);
      this.normal_cache = new Float32Array(this.size3 * 3);
      this.palette = new Float32Array(this.size3 * 3);
      this.count = 0;
      const maxVertexCount = maxPolyCount * 3;
      this.positionArray = new Float32Array(maxVertexCount * 3);
      const positionAttribute = new BufferAttribute(this.positionArray, 3);
      positionAttribute.setUsage(DynamicDrawUsage);
      geometry2.setAttribute("position", positionAttribute);
      this.normalArray = new Float32Array(maxVertexCount * 3);
      const normalAttribute = new BufferAttribute(this.normalArray, 3);
      normalAttribute.setUsage(DynamicDrawUsage);
      geometry2.setAttribute("normal", normalAttribute);
      if (this.enableUvs) {
        this.uvArray = new Float32Array(maxVertexCount * 2);
        const uvAttribute = new BufferAttribute(this.uvArray, 2);
        uvAttribute.setUsage(DynamicDrawUsage);
        geometry2.setAttribute("uv", uvAttribute);
      }
      if (this.enableColors) {
        this.colorArray = new Float32Array(maxVertexCount * 3);
        const colorAttribute = new BufferAttribute(this.colorArray, 3);
        colorAttribute.setUsage(DynamicDrawUsage);
        geometry2.setAttribute("color", colorAttribute);
      }
    };
    function lerp(a2, b2, t2) {
      return a2 + (b2 - a2) * t2;
    }
    function VIntX(q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) {
      const mu = (isol - valp1) / (valp2 - valp1), nc = scope.normal_cache;
      vlist[offset + 0] = x + mu * scope.delta;
      vlist[offset + 1] = y;
      vlist[offset + 2] = z;
      nlist[offset + 0] = lerp(nc[q + 0], nc[q + 3], mu);
      nlist[offset + 1] = lerp(nc[q + 1], nc[q + 4], mu);
      nlist[offset + 2] = lerp(nc[q + 2], nc[q + 5], mu);
      clist[offset + 0] = lerp(scope.palette[c_offset1 * 3 + 0], scope.palette[c_offset2 * 3 + 0], mu);
      clist[offset + 1] = lerp(scope.palette[c_offset1 * 3 + 1], scope.palette[c_offset2 * 3 + 1], mu);
      clist[offset + 2] = lerp(scope.palette[c_offset1 * 3 + 2], scope.palette[c_offset2 * 3 + 2], mu);
    }
    function VIntY(q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) {
      const mu = (isol - valp1) / (valp2 - valp1), nc = scope.normal_cache;
      vlist[offset + 0] = x;
      vlist[offset + 1] = y + mu * scope.delta;
      vlist[offset + 2] = z;
      const q2 = q + scope.yd * 3;
      nlist[offset + 0] = lerp(nc[q + 0], nc[q2 + 0], mu);
      nlist[offset + 1] = lerp(nc[q + 1], nc[q2 + 1], mu);
      nlist[offset + 2] = lerp(nc[q + 2], nc[q2 + 2], mu);
      clist[offset + 0] = lerp(scope.palette[c_offset1 * 3 + 0], scope.palette[c_offset2 * 3 + 0], mu);
      clist[offset + 1] = lerp(scope.palette[c_offset1 * 3 + 1], scope.palette[c_offset2 * 3 + 1], mu);
      clist[offset + 2] = lerp(scope.palette[c_offset1 * 3 + 2], scope.palette[c_offset2 * 3 + 2], mu);
    }
    function VIntZ(q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) {
      const mu = (isol - valp1) / (valp2 - valp1), nc = scope.normal_cache;
      vlist[offset + 0] = x;
      vlist[offset + 1] = y;
      vlist[offset + 2] = z + mu * scope.delta;
      const q2 = q + scope.zd * 3;
      nlist[offset + 0] = lerp(nc[q + 0], nc[q2 + 0], mu);
      nlist[offset + 1] = lerp(nc[q + 1], nc[q2 + 1], mu);
      nlist[offset + 2] = lerp(nc[q + 2], nc[q2 + 2], mu);
      clist[offset + 0] = lerp(scope.palette[c_offset1 * 3 + 0], scope.palette[c_offset2 * 3 + 0], mu);
      clist[offset + 1] = lerp(scope.palette[c_offset1 * 3 + 1], scope.palette[c_offset2 * 3 + 1], mu);
      clist[offset + 2] = lerp(scope.palette[c_offset1 * 3 + 2], scope.palette[c_offset2 * 3 + 2], mu);
    }
    function compNorm(q) {
      const q3 = q * 3;
      if (scope.normal_cache[q3] === 0) {
        scope.normal_cache[q3 + 0] = scope.field[q - 1] - scope.field[q + 1];
        scope.normal_cache[q3 + 1] = scope.field[q - scope.yd] - scope.field[q + scope.yd];
        scope.normal_cache[q3 + 2] = scope.field[q - scope.zd] - scope.field[q + scope.zd];
      }
    }
    function polygonize(fx, fy, fz, q, isol) {
      const q1 = q + 1, qy = q + scope.yd, qz = q + scope.zd, q1y = q1 + scope.yd, q1z = q1 + scope.zd, qyz = q + scope.yd + scope.zd, q1yz = q1 + scope.yd + scope.zd;
      let cubeindex = 0;
      const field0 = scope.field[q], field1 = scope.field[q1], field2 = scope.field[qy], field3 = scope.field[q1y], field4 = scope.field[qz], field5 = scope.field[q1z], field6 = scope.field[qyz], field7 = scope.field[q1yz];
      if (field0 < isol)
        cubeindex |= 1;
      if (field1 < isol)
        cubeindex |= 2;
      if (field2 < isol)
        cubeindex |= 8;
      if (field3 < isol)
        cubeindex |= 4;
      if (field4 < isol)
        cubeindex |= 16;
      if (field5 < isol)
        cubeindex |= 32;
      if (field6 < isol)
        cubeindex |= 128;
      if (field7 < isol)
        cubeindex |= 64;
      const bits = edgeTable[cubeindex];
      if (bits === 0)
        return 0;
      const d = scope.delta, fx2 = fx + d, fy2 = fy + d, fz2 = fz + d;
      if (bits & 1) {
        compNorm(q);
        compNorm(q1);
        VIntX(q * 3, 0, isol, fx, fy, fz, field0, field1, q, q1);
      }
      if (bits & 2) {
        compNorm(q1);
        compNorm(q1y);
        VIntY(q1 * 3, 3, isol, fx2, fy, fz, field1, field3, q1, q1y);
      }
      if (bits & 4) {
        compNorm(qy);
        compNorm(q1y);
        VIntX(qy * 3, 6, isol, fx, fy2, fz, field2, field3, qy, q1y);
      }
      if (bits & 8) {
        compNorm(q);
        compNorm(qy);
        VIntY(q * 3, 9, isol, fx, fy, fz, field0, field2, q, qy);
      }
      if (bits & 16) {
        compNorm(qz);
        compNorm(q1z);
        VIntX(qz * 3, 12, isol, fx, fy, fz2, field4, field5, qz, q1z);
      }
      if (bits & 32) {
        compNorm(q1z);
        compNorm(q1yz);
        VIntY(q1z * 3, 15, isol, fx2, fy, fz2, field5, field7, q1z, q1yz);
      }
      if (bits & 64) {
        compNorm(qyz);
        compNorm(q1yz);
        VIntX(qyz * 3, 18, isol, fx, fy2, fz2, field6, field7, qyz, q1yz);
      }
      if (bits & 128) {
        compNorm(qz);
        compNorm(qyz);
        VIntY(qz * 3, 21, isol, fx, fy, fz2, field4, field6, qz, qyz);
      }
      if (bits & 256) {
        compNorm(q);
        compNorm(qz);
        VIntZ(q * 3, 24, isol, fx, fy, fz, field0, field4, q, qz);
      }
      if (bits & 512) {
        compNorm(q1);
        compNorm(q1z);
        VIntZ(q1 * 3, 27, isol, fx2, fy, fz, field1, field5, q1, q1z);
      }
      if (bits & 1024) {
        compNorm(q1y);
        compNorm(q1yz);
        VIntZ(q1y * 3, 30, isol, fx2, fy2, fz, field3, field7, q1y, q1yz);
      }
      if (bits & 2048) {
        compNorm(qy);
        compNorm(qyz);
        VIntZ(qy * 3, 33, isol, fx, fy2, fz, field2, field6, qy, qyz);
      }
      cubeindex <<= 4;
      let o1, o2, o3, numtris = 0, i2 = 0;
      while (triTable[cubeindex + i2] != -1) {
        o1 = cubeindex + i2;
        o2 = o1 + 1;
        o3 = o1 + 2;
        posnormtriv(vlist, nlist, clist, 3 * triTable[o1], 3 * triTable[o2], 3 * triTable[o3]);
        i2 += 3;
        numtris++;
      }
      return numtris;
    }
    function posnormtriv(pos, norm, colors, o1, o2, o3) {
      const c2 = scope.count * 3;
      scope.positionArray[c2 + 0] = pos[o1];
      scope.positionArray[c2 + 1] = pos[o1 + 1];
      scope.positionArray[c2 + 2] = pos[o1 + 2];
      scope.positionArray[c2 + 3] = pos[o2];
      scope.positionArray[c2 + 4] = pos[o2 + 1];
      scope.positionArray[c2 + 5] = pos[o2 + 2];
      scope.positionArray[c2 + 6] = pos[o3];
      scope.positionArray[c2 + 7] = pos[o3 + 1];
      scope.positionArray[c2 + 8] = pos[o3 + 2];
      if (scope.material.flatShading === true) {
        const nx = (norm[o1 + 0] + norm[o2 + 0] + norm[o3 + 0]) / 3;
        const ny = (norm[o1 + 1] + norm[o2 + 1] + norm[o3 + 1]) / 3;
        const nz = (norm[o1 + 2] + norm[o2 + 2] + norm[o3 + 2]) / 3;
        scope.normalArray[c2 + 0] = nx;
        scope.normalArray[c2 + 1] = ny;
        scope.normalArray[c2 + 2] = nz;
        scope.normalArray[c2 + 3] = nx;
        scope.normalArray[c2 + 4] = ny;
        scope.normalArray[c2 + 5] = nz;
        scope.normalArray[c2 + 6] = nx;
        scope.normalArray[c2 + 7] = ny;
        scope.normalArray[c2 + 8] = nz;
      } else {
        scope.normalArray[c2 + 0] = norm[o1 + 0];
        scope.normalArray[c2 + 1] = norm[o1 + 1];
        scope.normalArray[c2 + 2] = norm[o1 + 2];
        scope.normalArray[c2 + 3] = norm[o2 + 0];
        scope.normalArray[c2 + 4] = norm[o2 + 1];
        scope.normalArray[c2 + 5] = norm[o2 + 2];
        scope.normalArray[c2 + 6] = norm[o3 + 0];
        scope.normalArray[c2 + 7] = norm[o3 + 1];
        scope.normalArray[c2 + 8] = norm[o3 + 2];
      }
      if (scope.enableUvs) {
        const d = scope.count * 2;
        scope.uvArray[d + 0] = pos[o1 + 0];
        scope.uvArray[d + 1] = pos[o1 + 2];
        scope.uvArray[d + 2] = pos[o2 + 0];
        scope.uvArray[d + 3] = pos[o2 + 2];
        scope.uvArray[d + 4] = pos[o3 + 0];
        scope.uvArray[d + 5] = pos[o3 + 2];
      }
      if (scope.enableColors) {
        scope.colorArray[c2 + 0] = colors[o1 + 0];
        scope.colorArray[c2 + 1] = colors[o1 + 1];
        scope.colorArray[c2 + 2] = colors[o1 + 2];
        scope.colorArray[c2 + 3] = colors[o2 + 0];
        scope.colorArray[c2 + 4] = colors[o2 + 1];
        scope.colorArray[c2 + 5] = colors[o2 + 2];
        scope.colorArray[c2 + 6] = colors[o3 + 0];
        scope.colorArray[c2 + 7] = colors[o3 + 1];
        scope.colorArray[c2 + 8] = colors[o3 + 2];
      }
      scope.count += 3;
    }
    this.addBall = function(ballx, bally, ballz, strength, subtract, colors) {
      const sign2 = Math.sign(strength);
      strength = Math.abs(strength);
      const userDefineColor = !(colors === void 0 || colors === null);
      let ballColor = new Color(ballx, bally, ballz);
      if (userDefineColor) {
        try {
          ballColor = colors instanceof Color ? colors : Array.isArray(colors) ? new Color(Math.min(Math.abs(colors[0]), 1), Math.min(Math.abs(colors[1]), 1), Math.min(Math.abs(colors[2]), 1)) : new Color(colors);
        } catch (err) {
          ballColor = new Color(ballx, bally, ballz);
        }
      }
      const radius = this.size * Math.sqrt(strength / subtract), zs = ballz * this.size, ys = bally * this.size, xs = ballx * this.size;
      let min_z = Math.floor(zs - radius);
      if (min_z < 1)
        min_z = 1;
      let max_z = Math.floor(zs + radius);
      if (max_z > this.size - 1)
        max_z = this.size - 1;
      let min_y = Math.floor(ys - radius);
      if (min_y < 1)
        min_y = 1;
      let max_y = Math.floor(ys + radius);
      if (max_y > this.size - 1)
        max_y = this.size - 1;
      let min_x = Math.floor(xs - radius);
      if (min_x < 1)
        min_x = 1;
      let max_x = Math.floor(xs + radius);
      if (max_x > this.size - 1)
        max_x = this.size - 1;
      let x, y, z, y_offset, z_offset, fx, fy, fz, fz2, fy2, val;
      for (z = min_z; z < max_z; z++) {
        z_offset = this.size2 * z;
        fz = z / this.size - ballz;
        fz2 = fz * fz;
        for (y = min_y; y < max_y; y++) {
          y_offset = z_offset + this.size * y;
          fy = y / this.size - bally;
          fy2 = fy * fy;
          for (x = min_x; x < max_x; x++) {
            fx = x / this.size - ballx;
            val = strength / (1e-6 + fx * fx + fy2 + fz2) - subtract;
            if (val > 0) {
              this.field[y_offset + x] += val * sign2;
              const ratio = Math.sqrt((x - xs) * (x - xs) + (y - ys) * (y - ys) + (z - zs) * (z - zs)) / radius;
              const contrib = 1 - ratio * ratio * ratio * (ratio * (ratio * 6 - 15) + 10);
              this.palette[(y_offset + x) * 3 + 0] += ballColor.r * contrib;
              this.palette[(y_offset + x) * 3 + 1] += ballColor.g * contrib;
              this.palette[(y_offset + x) * 3 + 2] += ballColor.b * contrib;
            }
          }
        }
      }
    };
    this.addPlaneX = function(strength, subtract) {
      const size2 = this.size, yd = this.yd, zd = this.zd, field = this.field;
      let x, y, z, xx, val, xdiv, cxy, dist = size2 * Math.sqrt(strength / subtract);
      if (dist > size2)
        dist = size2;
      for (x = 0; x < dist; x++) {
        xdiv = x / size2;
        xx = xdiv * xdiv;
        val = strength / (1e-4 + xx) - subtract;
        if (val > 0) {
          for (y = 0; y < size2; y++) {
            cxy = x + y * yd;
            for (z = 0; z < size2; z++) {
              field[zd * z + cxy] += val;
            }
          }
        }
      }
    };
    this.addPlaneY = function(strength, subtract) {
      const size2 = this.size, yd = this.yd, zd = this.zd, field = this.field;
      let x, y, z, yy, val, ydiv, cy, cxy, dist = size2 * Math.sqrt(strength / subtract);
      if (dist > size2)
        dist = size2;
      for (y = 0; y < dist; y++) {
        ydiv = y / size2;
        yy = ydiv * ydiv;
        val = strength / (1e-4 + yy) - subtract;
        if (val > 0) {
          cy = y * yd;
          for (x = 0; x < size2; x++) {
            cxy = cy + x;
            for (z = 0; z < size2; z++)
              field[zd * z + cxy] += val;
          }
        }
      }
    };
    this.addPlaneZ = function(strength, subtract) {
      const size2 = this.size, yd = this.yd, zd = this.zd, field = this.field;
      let x, y, z, zz, val, zdiv, cz, cyz, dist = size2 * Math.sqrt(strength / subtract);
      if (dist > size2)
        dist = size2;
      for (z = 0; z < dist; z++) {
        zdiv = z / size2;
        zz = zdiv * zdiv;
        val = strength / (1e-4 + zz) - subtract;
        if (val > 0) {
          cz = zd * z;
          for (y = 0; y < size2; y++) {
            cyz = cz + y * yd;
            for (x = 0; x < size2; x++)
              field[cyz + x] += val;
          }
        }
      }
    };
    this.setCell = function(x, y, z, value) {
      const index = this.size2 * z + this.size * y + x;
      this.field[index] = value;
    };
    this.getCell = function(x, y, z) {
      const index = this.size2 * z + this.size * y + x;
      return this.field[index];
    };
    this.blur = function(intensity = 1) {
      const field = this.field;
      const fieldCopy = field.slice();
      const size2 = this.size;
      const size22 = this.size2;
      for (let x = 0; x < size2; x++) {
        for (let y = 0; y < size2; y++) {
          for (let z = 0; z < size2; z++) {
            const index = size22 * z + size2 * y + x;
            let val = fieldCopy[index];
            let count = 1;
            for (let x2 = -1; x2 <= 1; x2 += 2) {
              const x3 = x2 + x;
              if (x3 < 0 || x3 >= size2)
                continue;
              for (let y2 = -1; y2 <= 1; y2 += 2) {
                const y3 = y2 + y;
                if (y3 < 0 || y3 >= size2)
                  continue;
                for (let z2 = -1; z2 <= 1; z2 += 2) {
                  const z3 = z2 + z;
                  if (z3 < 0 || z3 >= size2)
                    continue;
                  const index2 = size22 * z3 + size2 * y3 + x3;
                  const val2 = fieldCopy[index2];
                  count++;
                  val += intensity * (val2 - val) / count;
                }
              }
            }
            field[index] = val;
          }
        }
      }
    };
    this.reset = function() {
      for (let i2 = 0; i2 < this.size3; i2++) {
        this.normal_cache[i2 * 3] = 0;
        this.field[i2] = 0;
        this.palette[i2 * 3] = this.palette[i2 * 3 + 1] = this.palette[i2 * 3 + 2] = 0;
      }
    };
    this.onBeforeRender = function() {
      this.count = 0;
      const smin2 = this.size - 2;
      for (let z = 1; z < smin2; z++) {
        const z_offset = this.size2 * z;
        const fz = (z - this.halfsize) / this.halfsize;
        for (let y = 1; y < smin2; y++) {
          const y_offset = z_offset + this.size * y;
          const fy = (y - this.halfsize) / this.halfsize;
          for (let x = 1; x < smin2; x++) {
            const fx = (x - this.halfsize) / this.halfsize;
            const q = y_offset + x;
            polygonize(fx, fy, fz, q, this.isolation);
          }
        }
      }
      for (let i2 = this.count * 3; i2 < this.positionArray.length; i2++) {
        this.positionArray[i2] = 0;
      }
      geometry2.getAttribute("position").needsUpdate = true;
      geometry2.getAttribute("normal").needsUpdate = true;
      if (this.enableUvs)
        geometry2.getAttribute("uv").needsUpdate = true;
      if (this.enableColors)
        geometry2.getAttribute("color").needsUpdate = true;
      if (this.count / 3 > maxPolyCount) {
        console.warn("MarchingCubes: Geometry buffers too small for rendering. Please create an instance with a higher poly count.");
      }
    };
    this.init(resolution);
  }
};
MarchingCubes.prototype.isMarchingCubes = true;
var edgeTable = new Int32Array([0, 265, 515, 778, 1030, 1295, 1541, 1804, 2060, 2309, 2575, 2822, 3082, 3331, 3593, 3840, 400, 153, 915, 666, 1430, 1183, 1941, 1692, 2460, 2197, 2975, 2710, 3482, 3219, 3993, 3728, 560, 825, 51, 314, 1590, 1855, 1077, 1340, 2620, 2869, 2111, 2358, 3642, 3891, 3129, 3376, 928, 681, 419, 170, 1958, 1711, 1445, 1196, 2988, 2725, 2479, 2214, 4010, 3747, 3497, 3232, 1120, 1385, 1635, 1898, 102, 367, 613, 876, 3180, 3429, 3695, 3942, 2154, 2403, 2665, 2912, 1520, 1273, 2035, 1786, 502, 255, 1013, 764, 3580, 3317, 4095, 3830, 2554, 2291, 3065, 2800, 1616, 1881, 1107, 1370, 598, 863, 85, 348, 3676, 3925, 3167, 3414, 2650, 2899, 2137, 2384, 1984, 1737, 1475, 1226, 966, 719, 453, 204, 4044, 3781, 3535, 3270, 3018, 2755, 2505, 2240, 2240, 2505, 2755, 3018, 3270, 3535, 3781, 4044, 204, 453, 719, 966, 1226, 1475, 1737, 1984, 2384, 2137, 2899, 2650, 3414, 3167, 3925, 3676, 348, 85, 863, 598, 1370, 1107, 1881, 1616, 2800, 3065, 2291, 2554, 3830, 4095, 3317, 3580, 764, 1013, 255, 502, 1786, 2035, 1273, 1520, 2912, 2665, 2403, 2154, 3942, 3695, 3429, 3180, 876, 613, 367, 102, 1898, 1635, 1385, 1120, 3232, 3497, 3747, 4010, 2214, 2479, 2725, 2988, 1196, 1445, 1711, 1958, 170, 419, 681, 928, 3376, 3129, 3891, 3642, 2358, 2111, 2869, 2620, 1340, 1077, 1855, 1590, 314, 51, 825, 560, 3728, 3993, 3219, 3482, 2710, 2975, 2197, 2460, 1692, 1941, 1183, 1430, 666, 915, 153, 400, 3840, 3593, 3331, 3082, 2822, 2575, 2309, 2060, 1804, 1541, 1295, 1030, 778, 515, 265, 0]);
var triTable = new Int32Array([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1, 3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1, 3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1, 9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1, 8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1, 3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1, 1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1, 4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1, 4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1, 2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1, 9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1, 10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1, 5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1, 5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1, 0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1, 1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1, 8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1, 2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, 7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, 9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1, 2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1, 11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1, 9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1, 5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1, 11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1, 11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1, 9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1, 5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1, 2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1, 6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1, 3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1, 6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1, 6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, 1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1, 8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1, 7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1, 3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1, 0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, 9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1, 8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1, 5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1, 0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1, 6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1, 10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, 10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1, 8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1, 1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1, 0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, 10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1, 3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1, 6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1, 9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1, 8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1, 3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1, 6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1, 10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1, 10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1, 1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1, 7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1, 7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1, 1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1, 11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1, 8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1, 0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1, 7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1, 7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1, 2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, 1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1, 10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1, 10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1, 0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1, 7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1, 6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1, 9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1, 6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1, 4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1, 10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1, 8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, 0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1, 1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1, 10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1, 4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1, 10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1, 9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1, 7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1, 3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1, 7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1, 3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1, 6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1, 9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1, 1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1, 4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1, 7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1, 6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1, 0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1, 6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1, 0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1, 11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1, 6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1, 5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1, 9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1, 1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1, 1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1, 10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1, 0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1, 5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1, 10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1, 11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1, 9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1, 7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1, 2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, 8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1, 9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1, 9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1, 1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1, 9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1, 9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, 5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1, 0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1, 10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1, 2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1, 0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1, 0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1, 9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1, 5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1, 3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1, 5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1, 1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1, 3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1, 4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1, 9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1, 11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1, 11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1, 2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1, 9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1, 3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1, 1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1, 4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1, 3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1, 0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1, 9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1, 1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]);

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/math/SimplexNoise.js
var SimplexNoise = class {
  constructor(r = Math) {
    _defineProperty(this, "grad3", [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]]);
    _defineProperty(this, "grad4", [[0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1], [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1], [1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1], [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1], [1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1], [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1], [1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, -1, 0]]);
    _defineProperty(this, "p", []);
    _defineProperty(this, "perm", []);
    _defineProperty(this, "simplex", [[0, 1, 2, 3], [0, 1, 3, 2], [0, 0, 0, 0], [0, 2, 3, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 3, 0], [0, 2, 1, 3], [0, 0, 0, 0], [0, 3, 1, 2], [0, 3, 2, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 3, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 0, 3], [0, 0, 0, 0], [1, 3, 0, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 3, 0, 1], [2, 3, 1, 0], [1, 0, 2, 3], [1, 0, 3, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 3, 1], [0, 0, 0, 0], [2, 1, 3, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 0, 1, 2], [3, 0, 2, 1], [0, 0, 0, 0], [3, 1, 2, 0], [2, 1, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 1, 0, 2], [0, 0, 0, 0], [3, 2, 0, 1], [3, 2, 1, 0]]);
    _defineProperty(this, "dot", (g, x, y) => {
      return g[0] * x + g[1] * y;
    });
    _defineProperty(this, "dot3", (g, x, y, z) => {
      return g[0] * x + g[1] * y + g[2] * z;
    });
    _defineProperty(this, "dot4", (g, x, y, z, w) => {
      return g[0] * x + g[1] * y + g[2] * z + g[3] * w;
    });
    _defineProperty(this, "noise", (xin, yin) => {
      let n0;
      let n1;
      let n2;
      const F2 = 0.5 * (Math.sqrt(3) - 1);
      const s = (xin + yin) * F2;
      const i2 = Math.floor(xin + s);
      const j2 = Math.floor(yin + s);
      const G2 = (3 - Math.sqrt(3)) / 6;
      const t2 = (i2 + j2) * G2;
      const X0 = i2 - t2;
      const Y0 = j2 - t2;
      const x0 = xin - X0;
      const y0 = yin - Y0;
      let i1 = 0;
      let j1 = 1;
      if (x0 > y0) {
        i1 = 1;
        j1 = 0;
      }
      const x1 = x0 - i1 + G2;
      const y1 = y0 - j1 + G2;
      const x2 = x0 - 1 + 2 * G2;
      const y2 = y0 - 1 + 2 * G2;
      const ii = i2 & 255;
      const jj = j2 & 255;
      const gi0 = this.perm[ii + this.perm[jj]] % 12;
      const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
      const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;
      let t0 = 0.5 - x0 * x0 - y0 * y0;
      if (t0 < 0) {
        n0 = 0;
      } else {
        t0 *= t0;
        n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);
      }
      let t1 = 0.5 - x1 * x1 - y1 * y1;
      if (t1 < 0) {
        n1 = 0;
      } else {
        t1 *= t1;
        n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
      }
      let t22 = 0.5 - x2 * x2 - y2 * y2;
      if (t22 < 0) {
        n2 = 0;
      } else {
        t22 *= t22;
        n2 = t22 * t22 * this.dot(this.grad3[gi2], x2, y2);
      }
      return 70 * (n0 + n1 + n2);
    });
    _defineProperty(this, "noise3d", (xin, yin, zin) => {
      let n0;
      let n1;
      let n2;
      let n3;
      const F3 = 1 / 3;
      const s = (xin + yin + zin) * F3;
      const i2 = Math.floor(xin + s);
      const j2 = Math.floor(yin + s);
      const k = Math.floor(zin + s);
      const G3 = 1 / 6;
      const t2 = (i2 + j2 + k) * G3;
      const X0 = i2 - t2;
      const Y0 = j2 - t2;
      const Z0 = k - t2;
      const x0 = xin - X0;
      const y0 = yin - Y0;
      const z0 = zin - Z0;
      let i1;
      let j1;
      let k1;
      let i22;
      let j22;
      let k2;
      if (x0 >= y0) {
        if (y0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i22 = 1;
          j22 = 1;
          k2 = 0;
        } else if (x0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i22 = 1;
          j22 = 0;
          k2 = 1;
        } else {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i22 = 1;
          j22 = 0;
          k2 = 1;
        }
      } else {
        if (y0 < z0) {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i22 = 0;
          j22 = 1;
          k2 = 1;
        } else if (x0 < z0) {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i22 = 0;
          j22 = 1;
          k2 = 1;
        } else {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i22 = 1;
          j22 = 1;
          k2 = 0;
        }
      }
      const x1 = x0 - i1 + G3;
      const y1 = y0 - j1 + G3;
      const z1 = z0 - k1 + G3;
      const x2 = x0 - i22 + 2 * G3;
      const y2 = y0 - j22 + 2 * G3;
      const z2 = z0 - k2 + 2 * G3;
      const x3 = x0 - 1 + 3 * G3;
      const y3 = y0 - 1 + 3 * G3;
      const z3 = z0 - 1 + 3 * G3;
      const ii = i2 & 255;
      const jj = j2 & 255;
      const kk = k & 255;
      const gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;
      const gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;
      const gi2 = this.perm[ii + i22 + this.perm[jj + j22 + this.perm[kk + k2]]] % 12;
      const gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12;
      let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
      if (t0 < 0) {
        n0 = 0;
      } else {
        t0 *= t0;
        n0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0);
      }
      let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
      if (t1 < 0) {
        n1 = 0;
      } else {
        t1 *= t1;
        n1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1);
      }
      let t22 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
      if (t22 < 0) {
        n2 = 0;
      } else {
        t22 *= t22;
        n2 = t22 * t22 * this.dot3(this.grad3[gi2], x2, y2, z2);
      }
      let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
      if (t3 < 0) {
        n3 = 0;
      } else {
        t3 *= t3;
        n3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3);
      }
      return 32 * (n0 + n1 + n2 + n3);
    });
    _defineProperty(this, "noise4d", (x, y, z, w) => {
      const grad4 = this.grad4;
      const simplex = this.simplex;
      const perm = this.perm;
      const F4 = (Math.sqrt(5) - 1) / 4;
      const G4 = (5 - Math.sqrt(5)) / 20;
      let n0;
      let n1;
      let n2;
      let n3;
      let n4;
      const s = (x + y + z + w) * F4;
      const i2 = Math.floor(x + s);
      const j2 = Math.floor(y + s);
      const k = Math.floor(z + s);
      const l = Math.floor(w + s);
      const t2 = (i2 + j2 + k + l) * G4;
      const X0 = i2 - t2;
      const Y0 = j2 - t2;
      const Z0 = k - t2;
      const W0 = l - t2;
      const x0 = x - X0;
      const y0 = y - Y0;
      const z0 = z - Z0;
      const w0 = w - W0;
      const c1 = x0 > y0 ? 32 : 0;
      const c2 = x0 > z0 ? 16 : 0;
      const c3 = y0 > z0 ? 8 : 0;
      const c4 = x0 > w0 ? 4 : 0;
      const c5 = y0 > w0 ? 2 : 0;
      const c6 = z0 > w0 ? 1 : 0;
      const c7 = c1 + c2 + c3 + c4 + c5 + c6;
      let i1;
      let j1;
      let k1;
      let l1;
      let i22;
      let j22;
      let k2;
      let l2;
      let i3;
      let j3;
      let k3;
      let l3;
      i1 = simplex[c7][0] >= 3 ? 1 : 0;
      j1 = simplex[c7][1] >= 3 ? 1 : 0;
      k1 = simplex[c7][2] >= 3 ? 1 : 0;
      l1 = simplex[c7][3] >= 3 ? 1 : 0;
      i22 = simplex[c7][0] >= 2 ? 1 : 0;
      j22 = simplex[c7][1] >= 2 ? 1 : 0;
      k2 = simplex[c7][2] >= 2 ? 1 : 0;
      l2 = simplex[c7][3] >= 2 ? 1 : 0;
      i3 = simplex[c7][0] >= 1 ? 1 : 0;
      j3 = simplex[c7][1] >= 1 ? 1 : 0;
      k3 = simplex[c7][2] >= 1 ? 1 : 0;
      l3 = simplex[c7][3] >= 1 ? 1 : 0;
      const x1 = x0 - i1 + G4;
      const y1 = y0 - j1 + G4;
      const z1 = z0 - k1 + G4;
      const w1 = w0 - l1 + G4;
      const x2 = x0 - i22 + 2 * G4;
      const y2 = y0 - j22 + 2 * G4;
      const z2 = z0 - k2 + 2 * G4;
      const w2 = w0 - l2 + 2 * G4;
      const x3 = x0 - i3 + 3 * G4;
      const y3 = y0 - j3 + 3 * G4;
      const z3 = z0 - k3 + 3 * G4;
      const w3 = w0 - l3 + 3 * G4;
      const x4 = x0 - 1 + 4 * G4;
      const y4 = y0 - 1 + 4 * G4;
      const z4 = z0 - 1 + 4 * G4;
      const w4 = w0 - 1 + 4 * G4;
      const ii = i2 & 255;
      const jj = j2 & 255;
      const kk = k & 255;
      const ll = l & 255;
      const gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32;
      const gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32;
      const gi2 = perm[ii + i22 + perm[jj + j22 + perm[kk + k2 + perm[ll + l2]]]] % 32;
      const gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32;
      const gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32;
      let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
      if (t0 < 0) {
        n0 = 0;
      } else {
        t0 *= t0;
        n0 = t0 * t0 * this.dot4(grad4[gi0], x0, y0, z0, w0);
      }
      let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
      if (t1 < 0) {
        n1 = 0;
      } else {
        t1 *= t1;
        n1 = t1 * t1 * this.dot4(grad4[gi1], x1, y1, z1, w1);
      }
      let t22 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
      if (t22 < 0) {
        n2 = 0;
      } else {
        t22 *= t22;
        n2 = t22 * t22 * this.dot4(grad4[gi2], x2, y2, z2, w2);
      }
      let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
      if (t3 < 0) {
        n3 = 0;
      } else {
        t3 *= t3;
        n3 = t3 * t3 * this.dot4(grad4[gi3], x3, y3, z3, w3);
      }
      let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
      if (t4 < 0) {
        n4 = 0;
      } else {
        t4 *= t4;
        n4 = t4 * t4 * this.dot4(grad4[gi4], x4, y4, z4, w4);
      }
      return 27 * (n0 + n1 + n2 + n3 + n4);
    });
    for (let i2 = 0; i2 < 256; i2++) {
      this.p[i2] = Math.floor(r.random() * 256);
    }
    for (let i2 = 0; i2 < 512; i2++) {
      this.perm[i2] = this.p[i2 & 255];
    }
  }
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/geometries/LightningStrike.js
var LightningStrike = class extends BufferGeometry {
  constructor(rayParameters) {
    super();
    this.type = "LightningStrike";
    rayParameters = rayParameters || {};
    this.init(LightningStrike.copyParameters(rayParameters, rayParameters));
    this.createMesh();
  }
  update(time) {
    if (this.isStatic)
      return;
    if (this.rayParameters.isEternal || this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime) {
      this.updateMesh(time);
      if (time < this.subrays[0].endPropagationTime) {
        this.state = LightningStrike.RAY_PROPAGATING;
      } else if (time > this.subrays[0].beginVanishingTime) {
        this.state = LightningStrike.RAY_VANISHING;
      } else {
        this.state = LightningStrike.RAY_STEADY;
      }
      this.visible = true;
    } else {
      this.visible = false;
      if (time < this.rayParameters.birthTime) {
        this.state = LightningStrike.RAY_UNBORN;
      } else {
        this.state = LightningStrike.RAY_EXTINGUISHED;
      }
    }
  }
  init(rayParameters) {
    this.rayParameters = rayParameters;
    this.maxIterations = rayParameters.maxIterations !== void 0 ? Math.floor(rayParameters.maxIterations) : 9;
    rayParameters.maxIterations = this.maxIterations;
    this.isStatic = rayParameters.isStatic !== void 0 ? rayParameters.isStatic : false;
    rayParameters.isStatic = this.isStatic;
    this.ramification = rayParameters.ramification !== void 0 ? Math.floor(rayParameters.ramification) : 5;
    rayParameters.ramification = this.ramification;
    this.maxSubrayRecursion = rayParameters.maxSubrayRecursion !== void 0 ? Math.floor(rayParameters.maxSubrayRecursion) : 3;
    rayParameters.maxSubrayRecursion = this.maxSubrayRecursion;
    this.recursionProbability = rayParameters.recursionProbability !== void 0 ? rayParameters.recursionProbability : 0.6;
    rayParameters.recursionProbability = this.recursionProbability;
    this.generateUVs = rayParameters.generateUVs !== void 0 ? rayParameters.generateUVs : false;
    rayParameters.generateUVs = this.generateUVs;
    if (rayParameters.randomGenerator !== void 0) {
      this.randomGenerator = rayParameters.randomGenerator;
      this.seedGenerator = rayParameters.randomGenerator;
      if (rayParameters.noiseSeed !== void 0) {
        this.seedGenerator.setSeed(rayParameters.noiseSeed);
      }
    } else {
      this.randomGenerator = LightningStrike.createRandomGenerator();
      this.seedGenerator = Math;
    }
    if (rayParameters.onDecideSubrayCreation !== void 0) {
      this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation;
    } else {
      this.createDefaultSubrayCreationCallbacks();
      if (rayParameters.onSubrayCreation !== void 0) {
        this.onSubrayCreation = rayParameters.onSubrayCreation;
      }
    }
    this.state = LightningStrike.RAY_INITIALIZED;
    this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)));
    rayParameters.maxSubrays = this.maxSubrays;
    this.maxRaySegments = 2 * (1 << this.maxIterations);
    this.subrays = [];
    for (let i2 = 0; i2 < this.maxSubrays; i2++) {
      this.subrays.push(this.createSubray());
    }
    this.raySegments = [];
    for (let i2 = 0; i2 < this.maxRaySegments; i2++) {
      this.raySegments.push(this.createSegment());
    }
    this.time = 0;
    this.timeFraction = 0;
    this.currentSegmentCallback = null;
    this.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs;
    this.numSubrays = 0;
    this.currentSubray = null;
    this.currentSegmentIndex = 0;
    this.isInitialSegment = false;
    this.subrayProbability = 0;
    this.currentVertex = 0;
    this.currentIndex = 0;
    this.currentCoordinate = 0;
    this.currentUVCoordinate = 0;
    this.vertices = null;
    this.uvs = null;
    this.indices = null;
    this.positionAttribute = null;
    this.uvsAttribute = null;
    this.simplexX = new SimplexNoise(this.seedGenerator);
    this.simplexY = new SimplexNoise(this.seedGenerator);
    this.simplexZ = new SimplexNoise(this.seedGenerator);
    this.forwards = new Vector3();
    this.forwardsFill = new Vector3();
    this.side = new Vector3();
    this.down = new Vector3();
    this.middlePos = new Vector3();
    this.middleLinPos = new Vector3();
    this.newPos = new Vector3();
    this.vPos = new Vector3();
    this.cross1 = new Vector3();
  }
  createMesh() {
    const maxDrawableSegmentsPerSubRay = 1 << this.maxIterations;
    const maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays;
    const maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays;
    this.vertices = new Float32Array(maxVerts * 3);
    this.indices = new Uint32Array(maxIndices);
    if (this.generateUVs) {
      this.uvs = new Float32Array(maxVerts * 2);
    }
    this.fillMesh(0);
    this.setIndex(new Uint32BufferAttribute(this.indices, 1));
    this.positionAttribute = new Float32BufferAttribute(this.vertices, 3);
    this.setAttribute("position", this.positionAttribute);
    if (this.generateUVs) {
      this.uvsAttribute = new Float32BufferAttribute(new Float32Array(this.uvs), 2);
      this.setAttribute("uv", this.uvsAttribute);
    }
    if (!this.isStatic) {
      this.index.usage = DynamicDrawUsage;
      this.positionAttribute.usage = DynamicDrawUsage;
      if (this.generateUVs) {
        this.uvsAttribute.usage = DynamicDrawUsage;
      }
    }
    this.vertices = this.positionAttribute.array;
    this.indices = this.index.array;
    if (this.generateUVs) {
      this.uvs = this.uvsAttribute.array;
    }
  }
  updateMesh(time) {
    this.fillMesh(time);
    this.drawRange.count = this.currentIndex;
    this.index.needsUpdate = true;
    this.positionAttribute.needsUpdate = true;
    if (this.generateUVs) {
      this.uvsAttribute.needsUpdate = true;
    }
  }
  fillMesh(time) {
    const scope = this;
    this.currentVertex = 0;
    this.currentIndex = 0;
    this.currentCoordinate = 0;
    this.currentUVCoordinate = 0;
    this.fractalRay(time, function fillVertices(segment) {
      const subray = scope.currentSubray;
      if (time < subray.birthTime) {
        return;
      } else if (this.rayParameters.isEternal && scope.currentSubray.recursion == 0) {
        scope.createPrism(segment);
        scope.onDecideSubrayCreation(segment, scope);
      } else if (time < subray.endPropagationTime) {
        if (scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {
          scope.createPrism(segment);
          scope.onDecideSubrayCreation(segment, scope);
        }
      } else if (time < subray.beginVanishingTime) {
        scope.createPrism(segment);
        scope.onDecideSubrayCreation(segment, scope);
      } else {
        if (scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {
          scope.createPrism(segment);
        }
        scope.onDecideSubrayCreation(segment, scope);
      }
    });
  }
  addNewSubray() {
    return this.subrays[this.numSubrays++];
  }
  initSubray(subray, rayParameters) {
    subray.pos0.copy(rayParameters.sourceOffset);
    subray.pos1.copy(rayParameters.destOffset);
    subray.up0.copy(rayParameters.up0);
    subray.up1.copy(rayParameters.up1);
    subray.radius0 = rayParameters.radius0;
    subray.radius1 = rayParameters.radius1;
    subray.birthTime = rayParameters.birthTime;
    subray.deathTime = rayParameters.deathTime;
    subray.timeScale = rayParameters.timeScale;
    subray.roughness = rayParameters.roughness;
    subray.straightness = rayParameters.straightness;
    subray.propagationTimeFactor = rayParameters.propagationTimeFactor;
    subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor;
    subray.maxIterations = this.maxIterations;
    subray.seed = rayParameters.noiseSeed !== void 0 ? rayParameters.noiseSeed : 0;
    subray.recursion = 0;
  }
  fractalRay(time, segmentCallback) {
    this.time = time;
    this.currentSegmentCallback = segmentCallback;
    this.numSubrays = 0;
    this.initSubray(this.addNewSubray(), this.rayParameters);
    for (let subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++) {
      const subray = this.subrays[subrayIndex];
      this.currentSubray = subray;
      this.randomGenerator.setSeed(subray.seed);
      subray.endPropagationTime = MathUtils.lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor);
      subray.beginVanishingTime = MathUtils.lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor);
      const random1 = this.randomGenerator.random;
      subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);
      subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);
      this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime);
      this.currentSegmentIndex = 0;
      this.isInitialSegment = true;
      const segment = this.getNewSegment();
      segment.iteration = 0;
      segment.pos0.copy(subray.pos0);
      segment.pos1.copy(subray.pos1);
      segment.linPos0.copy(subray.linPos0);
      segment.linPos1.copy(subray.linPos1);
      segment.up0.copy(subray.up0);
      segment.up1.copy(subray.up1);
      segment.radius0 = subray.radius0;
      segment.radius1 = subray.radius1;
      segment.fraction0 = 0;
      segment.fraction1 = 1;
      segment.positionVariationFactor = 1 - subray.straightness;
      this.subrayProbability = this.ramification * Math.pow(this.recursionProbability, subray.recursion) / (1 << subray.maxIterations);
      this.fractalRayRecursive(segment);
    }
    this.currentSegmentCallback = null;
    this.currentSubray = null;
  }
  fractalRayRecursive(segment) {
    if (segment.iteration >= this.currentSubray.maxIterations) {
      this.currentSegmentCallback(segment);
      return;
    }
    this.forwards.subVectors(segment.pos1, segment.pos0);
    let lForwards = this.forwards.length();
    if (lForwards < 1e-6) {
      this.forwards.set(0, 0, 0.01);
      lForwards = this.forwards.length();
    }
    const middleRadius = (segment.radius0 + segment.radius1) * 0.5;
    const middleFraction = (segment.fraction0 + segment.fraction1) * 0.5;
    const timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration);
    this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5);
    this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5);
    const p = this.middleLinPos;
    this.newPos.set(this.simplexX.noise4d(p.x, p.y, p.z, timeDimension), this.simplexY.noise4d(p.x, p.y, p.z, timeDimension), this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension));
    this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards);
    this.newPos.add(this.middlePos);
    const newSegment1 = this.getNewSegment();
    newSegment1.pos0.copy(segment.pos0);
    newSegment1.pos1.copy(this.newPos);
    newSegment1.linPos0.copy(segment.linPos0);
    newSegment1.linPos1.copy(this.middleLinPos);
    newSegment1.up0.copy(segment.up0);
    newSegment1.up1.copy(segment.up1);
    newSegment1.radius0 = segment.radius0;
    newSegment1.radius1 = middleRadius;
    newSegment1.fraction0 = segment.fraction0;
    newSegment1.fraction1 = middleFraction;
    newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;
    newSegment1.iteration = segment.iteration + 1;
    const newSegment2 = this.getNewSegment();
    newSegment2.pos0.copy(this.newPos);
    newSegment2.pos1.copy(segment.pos1);
    newSegment2.linPos0.copy(this.middleLinPos);
    newSegment2.linPos1.copy(segment.linPos1);
    this.cross1.crossVectors(segment.up0, this.forwards.normalize());
    newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize();
    newSegment2.up1.copy(segment.up1);
    newSegment2.radius0 = middleRadius;
    newSegment2.radius1 = segment.radius1;
    newSegment2.fraction0 = middleFraction;
    newSegment2.fraction1 = segment.fraction1;
    newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;
    newSegment2.iteration = segment.iteration + 1;
    this.fractalRayRecursive(newSegment1);
    this.fractalRayRecursive(newSegment2);
  }
  createPrism(segment) {
    this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize();
    if (this.isInitialSegment) {
      this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0);
      this.isInitialSegment = false;
    }
    this.currentCreateTriangleVertices(segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1);
    this.createPrismFaces();
  }
  createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {
    this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG);
    this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG);
    const p = this.vPos;
    const v3 = this.vertices;
    p.copy(pos).sub(this.side).add(this.down);
    v3[this.currentCoordinate++] = p.x;
    v3[this.currentCoordinate++] = p.y;
    v3[this.currentCoordinate++] = p.z;
    p.copy(pos).add(this.side).add(this.down);
    v3[this.currentCoordinate++] = p.x;
    v3[this.currentCoordinate++] = p.y;
    v3[this.currentCoordinate++] = p.z;
    p.copy(up).multiplyScalar(radius).add(pos);
    v3[this.currentCoordinate++] = p.x;
    v3[this.currentCoordinate++] = p.y;
    v3[this.currentCoordinate++] = p.z;
    this.currentVertex += 3;
  }
  createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {
    this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG);
    this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG);
    const p = this.vPos;
    const v3 = this.vertices;
    const uv2 = this.uvs;
    p.copy(pos).sub(this.side).add(this.down);
    v3[this.currentCoordinate++] = p.x;
    v3[this.currentCoordinate++] = p.y;
    v3[this.currentCoordinate++] = p.z;
    uv2[this.currentUVCoordinate++] = u;
    uv2[this.currentUVCoordinate++] = 0;
    p.copy(pos).add(this.side).add(this.down);
    v3[this.currentCoordinate++] = p.x;
    v3[this.currentCoordinate++] = p.y;
    v3[this.currentCoordinate++] = p.z;
    uv2[this.currentUVCoordinate++] = u;
    uv2[this.currentUVCoordinate++] = 0.5;
    p.copy(up).multiplyScalar(radius).add(pos);
    v3[this.currentCoordinate++] = p.x;
    v3[this.currentCoordinate++] = p.y;
    v3[this.currentCoordinate++] = p.z;
    uv2[this.currentUVCoordinate++] = u;
    uv2[this.currentUVCoordinate++] = 1;
    this.currentVertex += 3;
  }
  createPrismFaces(vertex) {
    const indices = this.indices;
    var vertex = this.currentVertex - 6;
    indices[this.currentIndex++] = vertex + 1;
    indices[this.currentIndex++] = vertex + 2;
    indices[this.currentIndex++] = vertex + 5;
    indices[this.currentIndex++] = vertex + 1;
    indices[this.currentIndex++] = vertex + 5;
    indices[this.currentIndex++] = vertex + 4;
    indices[this.currentIndex++] = vertex + 0;
    indices[this.currentIndex++] = vertex + 1;
    indices[this.currentIndex++] = vertex + 4;
    indices[this.currentIndex++] = vertex + 0;
    indices[this.currentIndex++] = vertex + 4;
    indices[this.currentIndex++] = vertex + 3;
    indices[this.currentIndex++] = vertex + 2;
    indices[this.currentIndex++] = vertex + 0;
    indices[this.currentIndex++] = vertex + 3;
    indices[this.currentIndex++] = vertex + 2;
    indices[this.currentIndex++] = vertex + 3;
    indices[this.currentIndex++] = vertex + 5;
  }
  createDefaultSubrayCreationCallbacks() {
    const random1 = this.randomGenerator.random;
    this.onDecideSubrayCreation = (segment, lightningStrike) => {
      const subray = lightningStrike.currentSubray;
      const period = lightningStrike.rayParameters.subrayPeriod;
      const dutyCycle = lightningStrike.rayParameters.subrayDutyCycle;
      const phase0 = lightningStrike.rayParameters.isEternal && subray.recursion == 0 ? -random1() * period : MathUtils.lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period;
      const phase = lightningStrike.time - phase0;
      const currentCycle = Math.floor(phase / period);
      const childSubraySeed = random1() * (currentCycle + 1);
      const isActive = phase % period <= dutyCycle * period;
      let probability = 0;
      if (isActive) {
        probability = lightningStrike.subrayProbability;
      }
      if (subray.recursion < lightningStrike.maxSubrayRecursion && lightningStrike.numSubrays < lightningStrike.maxSubrays && random1() < probability) {
        const childSubray = lightningStrike.addNewSubray();
        const parentSeed = lightningStrike.randomGenerator.getSeed();
        childSubray.seed = childSubraySeed;
        lightningStrike.randomGenerator.setSeed(childSubraySeed);
        childSubray.recursion = subray.recursion + 1;
        childSubray.maxIterations = Math.max(1, subray.maxIterations - 1);
        childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);
        childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);
        childSubray.up0.copy(subray.up0);
        childSubray.up1.copy(subray.up1);
        childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor;
        childSubray.radius1 = Math.min(lightningStrike.rayParameters.minRadius, segment.radius1 * lightningStrike.rayParameters.radius1Factor);
        childSubray.birthTime = phase0 + currentCycle * period;
        childSubray.deathTime = childSubray.birthTime + period * dutyCycle;
        if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {
          childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime);
          childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime);
        }
        childSubray.timeScale = subray.timeScale * 2;
        childSubray.roughness = subray.roughness;
        childSubray.straightness = subray.straightness;
        childSubray.propagationTimeFactor = subray.propagationTimeFactor;
        childSubray.vanishingTimeFactor = subray.vanishingTimeFactor;
        lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike);
        lightningStrike.randomGenerator.setSeed(parentSeed);
      }
    };
    const vec1Pos = new Vector3();
    const vec2Forward = new Vector3();
    const vec3Side = new Vector3();
    const vec4Up = new Vector3();
    this.onSubrayCreation = (segment, parentSubray, childSubray, lightningStrike) => {
      lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2);
    };
    this.subrayConePosition = (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) => {
      childSubray.pos0.copy(segment.pos0);
      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);
      vec2Forward.copy(vec1Pos).normalize();
      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor));
      const length2 = vec1Pos.length();
      vec3Side.crossVectors(parentSubray.up0, vec2Forward);
      const angle = 2 * Math.PI * random1();
      vec3Side.multiplyScalar(Math.cos(angle));
      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));
      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length2 * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);
    };
    this.subrayCylinderPosition = (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) => {
      childSubray.pos0.copy(segment.pos0);
      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);
      vec2Forward.copy(vec1Pos).normalize();
      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor));
      const length2 = vec1Pos.length();
      vec3Side.crossVectors(parentSubray.up0, vec2Forward);
      const angle = 2 * Math.PI * random1();
      vec3Side.multiplyScalar(Math.cos(angle));
      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));
      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length2 * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);
    };
  }
  createSubray() {
    return {
      seed: 0,
      maxIterations: 0,
      recursion: 0,
      pos0: new Vector3(),
      pos1: new Vector3(),
      linPos0: new Vector3(),
      linPos1: new Vector3(),
      up0: new Vector3(),
      up1: new Vector3(),
      radius0: 0,
      radius1: 0,
      birthTime: 0,
      deathTime: 0,
      timeScale: 0,
      roughness: 0,
      straightness: 0,
      propagationTimeFactor: 0,
      vanishingTimeFactor: 0,
      endPropagationTime: 0,
      beginVanishingTime: 0
    };
  }
  createSegment() {
    return {
      iteration: 0,
      pos0: new Vector3(),
      pos1: new Vector3(),
      linPos0: new Vector3(),
      linPos1: new Vector3(),
      up0: new Vector3(),
      up1: new Vector3(),
      radius0: 0,
      radius1: 0,
      fraction0: 0,
      fraction1: 0,
      positionVariationFactor: 0
    };
  }
  getNewSegment() {
    return this.raySegments[this.currentSegmentIndex++];
  }
  copy(source) {
    super.copy(source);
    this.init(LightningStrike.copyParameters({}, source.rayParameters));
    return this;
  }
  clone() {
    return new this.constructor(LightningStrike.copyParameters({}, this.rayParameters));
  }
};
LightningStrike.prototype.isLightningStrike = true;
LightningStrike.RAY_INITIALIZED = 0;
LightningStrike.RAY_UNBORN = 1;
LightningStrike.RAY_PROPAGATING = 2;
LightningStrike.RAY_STEADY = 3;
LightningStrike.RAY_VANISHING = 4;
LightningStrike.RAY_EXTINGUISHED = 5;
LightningStrike.COS30DEG = Math.cos(30 * Math.PI / 180);
LightningStrike.SIN30DEG = Math.sin(30 * Math.PI / 180);
LightningStrike.createRandomGenerator = () => {
  const numSeeds = 2053;
  const seeds = [];
  for (let i2 = 0; i2 < numSeeds; i2++) {
    seeds.push(Math.random());
  }
  const generator = {
    currentSeed: 0,
    random: function() {
      const value = seeds[generator.currentSeed];
      generator.currentSeed = (generator.currentSeed + 1) % numSeeds;
      return value;
    },
    getSeed: function() {
      return generator.currentSeed / numSeeds;
    },
    setSeed: function(seed) {
      generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds;
    }
  };
  return generator;
};
LightningStrike.copyParameters = (dest, source) => {
  source = source || {};
  dest = dest || {};
  const vecCopy = (v3) => {
    if (source === dest) {
      return v3;
    } else {
      return v3.clone();
    }
  };
  dest.sourceOffset = source.sourceOffset !== void 0 ? vecCopy(source.sourceOffset) : new Vector3(0, 100, 0), dest.destOffset = source.destOffset !== void 0 ? vecCopy(source.destOffset) : new Vector3(0, 0, 0), dest.timeScale = source.timeScale !== void 0 ? source.timeScale : 1, dest.roughness = source.roughness !== void 0 ? source.roughness : 0.9, dest.straightness = source.straightness !== void 0 ? source.straightness : 0.7, dest.up0 = source.up0 !== void 0 ? vecCopy(source.up0) : new Vector3(0, 0, 1);
  dest.up1 = source.up1 !== void 0 ? vecCopy(source.up1) : new Vector3(0, 0, 1), dest.radius0 = source.radius0 !== void 0 ? source.radius0 : 1, dest.radius1 = source.radius1 !== void 0 ? source.radius1 : 1, dest.radius0Factor = source.radius0Factor !== void 0 ? source.radius0Factor : 0.5, dest.radius1Factor = source.radius1Factor !== void 0 ? source.radius1Factor : 0.2, dest.minRadius = source.minRadius !== void 0 ? source.minRadius : 0.2, dest.isEternal = source.isEternal !== void 0 ? source.isEternal : source.birthTime === void 0 || source.deathTime === void 0, dest.birthTime = source.birthTime, dest.deathTime = source.deathTime, dest.propagationTimeFactor = source.propagationTimeFactor !== void 0 ? source.propagationTimeFactor : 0.1, dest.vanishingTimeFactor = source.vanishingTimeFactor !== void 0 ? source.vanishingTimeFactor : 0.9, dest.subrayPeriod = source.subrayPeriod !== void 0 ? source.subrayPeriod : 4, dest.subrayDutyCycle = source.subrayDutyCycle !== void 0 ? source.subrayDutyCycle : 0.6;
  dest.maxIterations = source.maxIterations !== void 0 ? source.maxIterations : 9;
  dest.isStatic = source.isStatic !== void 0 ? source.isStatic : false;
  dest.ramification = source.ramification !== void 0 ? source.ramification : 5;
  dest.maxSubrayRecursion = source.maxSubrayRecursion !== void 0 ? source.maxSubrayRecursion : 3;
  dest.recursionProbability = source.recursionProbability !== void 0 ? source.recursionProbability : 0.6;
  dest.generateUVs = source.generateUVs !== void 0 ? source.generateUVs : false;
  dest.randomGenerator = source.randomGenerator, dest.noiseSeed = source.noiseSeed, dest.onDecideSubrayCreation = source.onDecideSubrayCreation, dest.onSubrayCreation = source.onSubrayCreation;
  return dest;
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/objects/LightningStorm.js
var LightningStorm = class extends Object3D {
  constructor(stormParams = {}) {
    super();
    this.stormParams = stormParams;
    stormParams.size = stormParams.size !== void 0 ? stormParams.size : 1e3;
    stormParams.minHeight = stormParams.minHeight !== void 0 ? stormParams.minHeight : 80;
    stormParams.maxHeight = stormParams.maxHeight !== void 0 ? stormParams.maxHeight : 100;
    stormParams.maxSlope = stormParams.maxSlope !== void 0 ? stormParams.maxSlope : 1.1;
    stormParams.maxLightnings = stormParams.maxLightnings !== void 0 ? stormParams.maxLightnings : 3;
    stormParams.lightningMinPeriod = stormParams.lightningMinPeriod !== void 0 ? stormParams.lightningMinPeriod : 3;
    stormParams.lightningMaxPeriod = stormParams.lightningMaxPeriod !== void 0 ? stormParams.lightningMaxPeriod : 7;
    stormParams.lightningMinDuration = stormParams.lightningMinDuration !== void 0 ? stormParams.lightningMinDuration : 1;
    stormParams.lightningMaxDuration = stormParams.lightningMaxDuration !== void 0 ? stormParams.lightningMaxDuration : 2.5;
    this.lightningParameters = LightningStrike.copyParameters(stormParams.lightningParameters, stormParams.lightningParameters);
    this.lightningParameters.isEternal = false;
    this.lightningMaterial = stormParams.lightningMaterial !== void 0 ? stormParams.lightningMaterial : new MeshBasicMaterial({
      color: 11599871
    });
    if (stormParams.onRayPosition !== void 0) {
      this.onRayPosition = stormParams.onRayPosition;
    } else {
      this.onRayPosition = function(source, dest) {
        dest.set((Math.random() - 0.5) * stormParams.size, 0, (Math.random() - 0.5) * stormParams.size);
        const height = MathUtils.lerp(stormParams.minHeight, stormParams.maxHeight, Math.random());
        source.set(stormParams.maxSlope * (2 * Math.random() - 1), 1, stormParams.maxSlope * (2 * Math.random() - 1)).multiplyScalar(height).add(dest);
      };
    }
    this.onLightningDown = stormParams.onLightningDown;
    this.inited = false;
    this.nextLightningTime = 0;
    this.lightningsMeshes = [];
    this.deadLightningsMeshes = [];
    for (let i2 = 0; i2 < this.stormParams.maxLightnings; i2++) {
      const lightning = new LightningStrike(LightningStrike.copyParameters({}, this.lightningParameters));
      const mesh = new Mesh(lightning, this.lightningMaterial);
      this.deadLightningsMeshes.push(mesh);
    }
  }
  update(time) {
    if (!this.inited) {
      this.nextLightningTime = this.getNextLightningTime(time) * Math.random();
      this.inited = true;
    }
    if (time >= this.nextLightningTime) {
      const lightningMesh = this.deadLightningsMeshes.pop();
      if (lightningMesh) {
        const lightningParams1 = LightningStrike.copyParameters(lightningMesh.geometry.rayParameters, this.lightningParameters);
        lightningParams1.birthTime = time;
        lightningParams1.deathTime = time + MathUtils.lerp(this.stormParams.lightningMinDuration, this.stormParams.lightningMaxDuration, Math.random());
        this.onRayPosition(lightningParams1.sourceOffset, lightningParams1.destOffset);
        lightningParams1.noiseSeed = Math.random();
        this.add(lightningMesh);
        this.lightningsMeshes.push(lightningMesh);
      }
      this.nextLightningTime = this.getNextLightningTime(time);
    }
    let i2 = 0, il = this.lightningsMeshes.length;
    while (i2 < il) {
      const mesh = this.lightningsMeshes[i2];
      const lightning = mesh.geometry;
      const prevState = lightning.state;
      lightning.update(time);
      if (prevState === LightningStrike.RAY_PROPAGATING && lightning.state > prevState) {
        if (this.onLightningDown) {
          this.onLightningDown(lightning);
        }
      }
      if (lightning.state === LightningStrike.RAY_EXTINGUISHED) {
        this.lightningsMeshes.splice(this.lightningsMeshes.indexOf(mesh), 1);
        this.deadLightningsMeshes.push(mesh);
        this.remove(mesh);
        il--;
      } else {
        i2++;
      }
    }
  }
  getNextLightningTime(currentTime) {
    return currentTime + MathUtils.lerp(this.stormParams.lightningMinPeriod, this.stormParams.lightningMaxPeriod, Math.random()) / (this.stormParams.maxLightnings + 1);
  }
  copy(source) {
    super.copy(source);
    this.stormParams.size = source.stormParams.size;
    this.stormParams.minHeight = source.stormParams.minHeight;
    this.stormParams.maxHeight = source.stormParams.maxHeight;
    this.stormParams.maxSlope = source.stormParams.maxSlope;
    this.stormParams.maxLightnings = source.stormParams.maxLightnings;
    this.stormParams.lightningMinPeriod = source.stormParams.lightningMinPeriod;
    this.stormParams.lightningMaxPeriod = source.stormParams.lightningMaxPeriod;
    this.stormParams.lightningMinDuration = source.stormParams.lightningMinDuration;
    this.stormParams.lightningMaxDuration = source.stormParams.lightningMaxDuration;
    this.lightningParameters = LightningStrike.copyParameters({}, source.lightningParameters);
    this.lightningMaterial = source.stormParams.lightningMaterial;
    this.onLightningDown = source.onLightningDown;
    return this;
  }
  clone() {
    return new this.constructor(this.stormParams).copy(this);
  }
};
LightningStorm.prototype.isLightningStorm = true;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/objects/ReflectorForSSRPass.js
var ReflectorForSSRPass = class extends Mesh {
  constructor(geometry2, options = {}) {
    super(geometry2);
    this.type = "ReflectorForSSRPass";
    const scope = this;
    const color3 = options.color !== void 0 ? new Color(options.color) : new Color(8355711);
    const textureWidth = options.textureWidth || 512;
    const textureHeight = options.textureHeight || 512;
    const clipBias = options.clipBias || 0;
    const shader = options.shader || ReflectorForSSRPass.ReflectorShader;
    const useDepthTexture = options.useDepthTexture === true;
    const yAxis2 = new Vector3(0, 1, 0);
    const vecTemp0 = new Vector3();
    const vecTemp1 = new Vector3();
    scope.needsUpdate = false;
    scope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;
    scope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;
    scope.color = color3;
    scope.resolution = options.resolution || new Vector2(window.innerWidth, window.innerHeight);
    scope._distanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;
    Object.defineProperty(scope, "distanceAttenuation", {
      get() {
        return scope._distanceAttenuation;
      },
      set(val) {
        if (scope._distanceAttenuation === val)
          return;
        scope._distanceAttenuation = val;
        scope.material.defines.DISTANCE_ATTENUATION = val;
        scope.material.needsUpdate = true;
      }
    });
    scope._fresnel = ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;
    Object.defineProperty(scope, "fresnel", {
      get() {
        return scope._fresnel;
      },
      set(val) {
        if (scope._fresnel === val)
          return;
        scope._fresnel = val;
        scope.material.defines.FRESNEL = val;
        scope.material.needsUpdate = true;
      }
    });
    const normal = new Vector3();
    const reflectorWorldPosition = new Vector3();
    const cameraWorldPosition = new Vector3();
    const rotationMatrix2 = new Matrix4();
    const lookAtPosition = new Vector3(0, 0, -1);
    const view = new Vector3();
    const target = new Vector3();
    const textureMatrix = new Matrix4();
    const virtualCamera = new PerspectiveCamera();
    let depthTexture;
    if (useDepthTexture) {
      depthTexture = new DepthTexture();
      depthTexture.type = UnsignedShortType;
      depthTexture.minFilter = NearestFilter;
      depthTexture.magFilter = NearestFilter;
    }
    const parameters = {
      depthTexture: useDepthTexture ? depthTexture : null
    };
    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);
    const material = new ShaderMaterial({
      transparent: useDepthTexture,
      defines: Object.assign({}, ReflectorForSSRPass.ReflectorShader.defines, {
        useDepthTexture
      }),
      uniforms: UniformsUtils.clone(shader.uniforms),
      fragmentShader: shader.fragmentShader,
      vertexShader: shader.vertexShader
    });
    material.uniforms["tDiffuse"].value = renderTarget.texture;
    material.uniforms["color"].value = scope.color;
    material.uniforms["textureMatrix"].value = textureMatrix;
    if (useDepthTexture) {
      material.uniforms["tDepth"].value = renderTarget.depthTexture;
    }
    this.material = material;
    const globalPlane = new Plane(new Vector3(0, 1, 0), clipBias);
    const globalPlanes = [globalPlane];
    this.doRender = function(renderer, scene, camera) {
      material.uniforms["maxDistance"].value = scope.maxDistance;
      material.uniforms["color"].value = scope.color;
      material.uniforms["opacity"].value = scope.opacity;
      vecTemp0.copy(camera.position).normalize();
      vecTemp1.copy(vecTemp0).reflect(yAxis2);
      material.uniforms["fresnelCoe"].value = (vecTemp0.dot(vecTemp1) + 1) / 2;
      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);
      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
      rotationMatrix2.extractRotation(scope.matrixWorld);
      normal.set(0, 0, 1);
      normal.applyMatrix4(rotationMatrix2);
      view.subVectors(reflectorWorldPosition, cameraWorldPosition);
      if (view.dot(normal) > 0)
        return;
      view.reflect(normal).negate();
      view.add(reflectorWorldPosition);
      rotationMatrix2.extractRotation(camera.matrixWorld);
      lookAtPosition.set(0, 0, -1);
      lookAtPosition.applyMatrix4(rotationMatrix2);
      lookAtPosition.add(cameraWorldPosition);
      target.subVectors(reflectorWorldPosition, lookAtPosition);
      target.reflect(normal).negate();
      target.add(reflectorWorldPosition);
      virtualCamera.position.copy(view);
      virtualCamera.up.set(0, 1, 0);
      virtualCamera.up.applyMatrix4(rotationMatrix2);
      virtualCamera.up.reflect(normal);
      virtualCamera.lookAt(target);
      virtualCamera.far = camera.far;
      virtualCamera.updateMatrixWorld();
      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
      material.uniforms["virtualCameraNear"].value = camera.near;
      material.uniforms["virtualCameraFar"].value = camera.far;
      material.uniforms["virtualCameraMatrixWorld"].value = virtualCamera.matrixWorld;
      material.uniforms["virtualCameraProjectionMatrix"].value = camera.projectionMatrix;
      material.uniforms["virtualCameraProjectionMatrixInverse"].value = camera.projectionMatrixInverse;
      material.uniforms["resolution"].value = scope.resolution;
      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      textureMatrix.multiply(virtualCamera.projectionMatrix);
      textureMatrix.multiply(virtualCamera.matrixWorldInverse);
      textureMatrix.multiply(scope.matrixWorld);
      renderTarget.texture.encoding = renderer.outputEncoding;
      const currentRenderTarget = renderer.getRenderTarget();
      const currentXrEnabled = renderer.xr.enabled;
      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
      const currentClippingPlanes = renderer.clippingPlanes;
      renderer.xr.enabled = false;
      renderer.shadowMap.autoUpdate = false;
      renderer.clippingPlanes = globalPlanes;
      renderer.setRenderTarget(renderTarget);
      renderer.state.buffers.depth.setMask(true);
      if (renderer.autoClear === false)
        renderer.clear();
      renderer.render(scene, virtualCamera);
      renderer.xr.enabled = currentXrEnabled;
      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
      renderer.clippingPlanes = currentClippingPlanes;
      renderer.setRenderTarget(currentRenderTarget);
      const viewport = camera.viewport;
      if (viewport !== void 0) {
        renderer.state.viewport(viewport);
      }
    };
    this.getRenderTarget = function() {
      return renderTarget;
    };
  }
};
ReflectorForSSRPass.prototype.isReflectorForSSRPass = true;
ReflectorForSSRPass.ReflectorShader = {
  defines: {
    DISTANCE_ATTENUATION: true,
    FRESNEL: true
  },
  uniforms: {
    color: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    tDepth: {
      value: null
    },
    textureMatrix: {
      value: new Matrix4()
    },
    maxDistance: {
      value: 180
    },
    opacity: {
      value: 0.5
    },
    fresnelCoe: {
      value: null
    },
    virtualCameraNear: {
      value: null
    },
    virtualCameraFar: {
      value: null
    },
    virtualCameraProjectionMatrix: {
      value: new Matrix4()
    },
    virtualCameraMatrixWorld: {
      value: new Matrix4()
    },
    virtualCameraProjectionMatrixInverse: {
      value: new Matrix4()
    },
    resolution: {
      value: new Vector2()
    }
  },
  vertexShader: `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		uniform sampler2D tDepth;
		uniform float maxDistance;
		uniform float opacity;
		uniform float fresnelCoe;
		uniform float virtualCameraNear;
		uniform float virtualCameraFar;
		uniform mat4 virtualCameraProjectionMatrix;
		uniform mat4 virtualCameraProjectionMatrixInverse;
		uniform mat4 virtualCameraMatrixWorld;
		uniform vec2 resolution;
		varying vec4 vUv;
		#include <packing>
		float blendOverlay( float base, float blend ) {
			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );
		}
		vec3 blendOverlay( vec3 base, vec3 blend ) {
			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );
		}
		float getDepth( const in vec2 uv ) {
			return texture2D( tDepth, uv ).x;
		}
		float getViewZ( const in float depth ) {
			return perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );
		}
		vec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {
			vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc
			clipPosition *= clipW; //clip
			return ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view
		}
		void main() {
			vec4 base = texture2DProj( tDiffuse, vUv );
			#ifdef useDepthTexture
				vec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;
				uv.x=1.-uv.x;
				float depth = texture2DProj( tDepth, vUv ).r;
				float viewZ = getViewZ( depth );
				float clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];
				vec3 viewPosition=getViewPosition( uv, depth, clipW );
				vec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;
				if(worldPosition.y>maxDistance) discard;
				float op=opacity;
				#ifdef DISTANCE_ATTENUATION
					float ratio=1.-(worldPosition.y/maxDistance);
					float attenuation=ratio*ratio;
					op=opacity*attenuation;
				#endif
				#ifdef FRESNEL
					op*=fresnelCoe;
				#endif
				gl_FragColor = vec4( blendOverlay( base.rgb, color ), op );
			#else
				gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );
			#endif
		}
	`
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/objects/Sky.js
var Sky = class extends Mesh {
  constructor() {
    super(new BoxGeometry(1, 1, 1), Sky.material);
  }
};
_defineProperty(Sky, "SkyShader", {
  uniforms: {
    turbidity: {
      value: 2
    },
    rayleigh: {
      value: 1
    },
    mieCoefficient: {
      value: 5e-3
    },
    mieDirectionalG: {
      value: 0.8
    },
    sunPosition: {
      value: new Vector3()
    },
    up: {
      value: new Vector3(0, 1, 0)
    }
  },
  vertexShader: [
    "uniform vec3 sunPosition;",
    "uniform float rayleigh;",
    "uniform float turbidity;",
    "uniform float mieCoefficient;",
    "uniform vec3 up;",
    "varying vec3 vWorldPosition;",
    "varying vec3 vSunDirection;",
    "varying float vSunfade;",
    "varying vec3 vBetaR;",
    "varying vec3 vBetaM;",
    "varying float vSunE;",
    "const float e = 2.71828182845904523536028747135266249775724709369995957;",
    "const float pi = 3.141592653589793238462643383279502884197169;",
    "const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );",
    "const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );",
    "const float v = 4.0;",
    "const vec3 K = vec3( 0.686, 0.678, 0.666 );",
    "const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );",
    "const float cutoffAngle = 1.6110731556870734;",
    "const float steepness = 1.5;",
    "const float EE = 1000.0;",
    "float sunIntensity( float zenithAngleCos ) {",
    "	zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );",
    "	return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );",
    "}",
    "vec3 totalMie( float T ) {",
    "	float c = ( 0.2 * T ) * 10E-18;",
    "	return 0.434 * c * MieConst;",
    "}",
    "void main() {",
    "	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
    "	vWorldPosition = worldPosition.xyz;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "	gl_Position.z = gl_Position.w;",
    "	vSunDirection = normalize( sunPosition );",
    "	vSunE = sunIntensity( dot( vSunDirection, up ) );",
    "	vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );",
    "	float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );",
    "	vBetaR = totalRayleigh * rayleighCoefficient;",
    "	vBetaM = totalMie( turbidity ) * mieCoefficient;",
    "}"
  ].join("\n"),
  fragmentShader: [
    "varying vec3 vWorldPosition;",
    "varying vec3 vSunDirection;",
    "varying float vSunfade;",
    "varying vec3 vBetaR;",
    "varying vec3 vBetaM;",
    "varying float vSunE;",
    "uniform float mieDirectionalG;",
    "uniform vec3 up;",
    "const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );",
    "const float pi = 3.141592653589793238462643383279502884197169;",
    "const float n = 1.0003;",
    "const float N = 2.545E25;",
    "const float rayleighZenithLength = 8.4E3;",
    "const float mieZenithLength = 1.25E3;",
    "const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;",
    "const float THREE_OVER_SIXTEENPI = 0.05968310365946075;",
    "const float ONE_OVER_FOURPI = 0.07957747154594767;",
    "float rayleighPhase( float cosTheta ) {",
    "	return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );",
    "}",
    "float hgPhase( float cosTheta, float g ) {",
    "	float g2 = pow( g, 2.0 );",
    "	float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );",
    "	return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );",
    "}",
    "void main() {",
    "	vec3 direction = normalize( vWorldPosition - cameraPos );",
    "	float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );",
    "	float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );",
    "	float sR = rayleighZenithLength * inverse;",
    "	float sM = mieZenithLength * inverse;",
    "	vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );",
    "	float cosTheta = dot( direction, vSunDirection );",
    "	float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );",
    "	vec3 betaRTheta = vBetaR * rPhase;",
    "	float mPhase = hgPhase( cosTheta, mieDirectionalG );",
    "	vec3 betaMTheta = vBetaM * mPhase;",
    "	vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );",
    "	Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );",
    "	float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]",
    "	float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]",
    "	vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );",
    "	vec3 L0 = vec3( 0.1 ) * Fex;",
    "	float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );",
    "	L0 += ( vSunE * 19000.0 * Fex ) * sundisk;",
    "	vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );",
    "	vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );",
    "	gl_FragColor = vec4( retColor, 1.0 );",
    "#include <tonemapping_fragment>",
    "#include <encodings_fragment>",
    "}"
  ].join("\n")
});
_defineProperty(Sky, "material", new ShaderMaterial({
  name: "SkyShader",
  fragmentShader: Sky.SkyShader.fragmentShader,
  vertexShader: Sky.SkyShader.vertexShader,
  uniforms: UniformsUtils.clone(Sky.SkyShader.uniforms),
  side: BackSide,
  depthWrite: false
}));

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/objects/Water2.js
var Water2 = class extends Mesh {
  constructor(geometry2, options = {}) {
    super(geometry2);
    this.type = "Water";
    const scope = this;
    const color3 = options.color !== void 0 ? new Color(options.color) : new Color(16777215);
    const textureWidth = options.textureWidth || 512;
    const textureHeight = options.textureHeight || 512;
    const clipBias = options.clipBias || 0;
    const flowDirection = options.flowDirection || new Vector2(1, 0);
    const flowSpeed = options.flowSpeed || 0.03;
    const reflectivity = options.reflectivity || 0.02;
    const scale = options.scale || 1;
    const shader = options.shader || Water2.WaterShader;
    const encoding = options.encoding !== void 0 ? options.encoding : LinearEncoding;
    const textureLoader = new TextureLoader();
    const flowMap = options.flowMap || void 0;
    const normalMap0 = options.normalMap0 || textureLoader.load("textures/water/Water_1_M_Normal.jpg");
    const normalMap1 = options.normalMap1 || textureLoader.load("textures/water/Water_2_M_Normal.jpg");
    const cycle = 0.15;
    const halfCycle = cycle * 0.5;
    const textureMatrix = new Matrix4();
    const clock = new Clock();
    if (Reflector === void 0) {
      console.error("THREE.Water: Required component Reflector not found.");
      return;
    }
    if (Refractor === void 0) {
      console.error("THREE.Water: Required component Refractor not found.");
      return;
    }
    const reflector = new Reflector(geometry2, {
      textureWidth,
      textureHeight,
      clipBias,
      encoding
    });
    const refractor = new Refractor(geometry2, {
      textureWidth,
      textureHeight,
      clipBias,
      encoding
    });
    reflector.matrixAutoUpdate = false;
    refractor.matrixAutoUpdate = false;
    this.material = new ShaderMaterial({
      uniforms: UniformsUtils.merge([UniformsLib["fog"], shader.uniforms]),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      transparent: true,
      fog: true
    });
    if (flowMap !== void 0) {
      this.material.defines.USE_FLOWMAP = "";
      this.material.uniforms["tFlowMap"] = {
        type: "t",
        value: flowMap
      };
    } else {
      this.material.uniforms["flowDirection"] = {
        type: "v2",
        value: flowDirection
      };
    }
    normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;
    normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;
    this.material.uniforms["tReflectionMap"].value = reflector.getRenderTarget().texture;
    this.material.uniforms["tRefractionMap"].value = refractor.getRenderTarget().texture;
    this.material.uniforms["tNormalMap0"].value = normalMap0;
    this.material.uniforms["tNormalMap1"].value = normalMap1;
    this.material.uniforms["color"].value = color3;
    this.material.uniforms["reflectivity"].value = reflectivity;
    this.material.uniforms["textureMatrix"].value = textureMatrix;
    this.material.uniforms["config"].value.x = 0;
    this.material.uniforms["config"].value.y = halfCycle;
    this.material.uniforms["config"].value.z = halfCycle;
    this.material.uniforms["config"].value.w = scale;
    function updateTextureMatrix(camera) {
      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      textureMatrix.multiply(camera.projectionMatrix);
      textureMatrix.multiply(camera.matrixWorldInverse);
      textureMatrix.multiply(scope.matrixWorld);
    }
    function updateFlow() {
      const delta = clock.getDelta();
      const config = scope.material.uniforms["config"];
      config.value.x += flowSpeed * delta;
      config.value.y = config.value.x + halfCycle;
      if (config.value.x >= cycle) {
        config.value.x = 0;
        config.value.y = halfCycle;
      } else if (config.value.y >= cycle) {
        config.value.y = config.value.y - cycle;
      }
    }
    this.onBeforeRender = function(renderer, scene, camera) {
      updateTextureMatrix(camera);
      updateFlow();
      scope.visible = false;
      reflector.matrixWorld.copy(scope.matrixWorld);
      refractor.matrixWorld.copy(scope.matrixWorld);
      reflector.onBeforeRender(renderer, scene, camera);
      refractor.onBeforeRender(renderer, scene, camera);
      scope.visible = true;
    };
  }
};
Water2.prototype.isWater = true;
Water2.WaterShader = {
  uniforms: {
    color: {
      type: "c",
      value: null
    },
    reflectivity: {
      type: "f",
      value: 0
    },
    tReflectionMap: {
      type: "t",
      value: null
    },
    tRefractionMap: {
      type: "t",
      value: null
    },
    tNormalMap0: {
      type: "t",
      value: null
    },
    tNormalMap1: {
      type: "t",
      value: null
    },
    textureMatrix: {
      type: "m4",
      value: null
    },
    config: {
      type: "v4",
      value: new Vector4()
    }
  },
  vertexShader: `

		#include <common>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>

		uniform mat4 textureMatrix;

		varying vec4 vCoord;
		varying vec2 vUv;
		varying vec3 vToEye;

		void main() {

			vUv = uv;
			vCoord = textureMatrix * vec4( position, 1.0 );

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vToEye = cameraPosition - worldPosition.xyz;

			vec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex
			gl_Position = projectionMatrix * mvPosition;

			#include <logdepthbuf_vertex>
			#include <fog_vertex>

		}`,
  fragmentShader: `

		#include <common>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>

		uniform sampler2D tReflectionMap;
		uniform sampler2D tRefractionMap;
		uniform sampler2D tNormalMap0;
		uniform sampler2D tNormalMap1;

		#ifdef USE_FLOWMAP
			uniform sampler2D tFlowMap;
		#else
			uniform vec2 flowDirection;
		#endif

		uniform vec3 color;
		uniform float reflectivity;
		uniform vec4 config;

		varying vec4 vCoord;
		varying vec2 vUv;
		varying vec3 vToEye;

		void main() {

			#include <logdepthbuf_fragment>

			float flowMapOffset0 = config.x;
			float flowMapOffset1 = config.y;
			float halfCycle = config.z;
			float scale = config.w;

			vec3 toEye = normalize( vToEye );

			// determine flow direction
			vec2 flow;
			#ifdef USE_FLOWMAP
				flow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;
			#else
				flow = flowDirection;
			#endif
			flow.x *= - 1.0;

			// sample normal maps (distort uvs with flowdata)
			vec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );
			vec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );

			// linear interpolate to get the final normal color
			float flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;
			vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );

			// calculate normal vector
			vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );

			// calculate the fresnel term to blend reflection and refraction maps
			float theta = max( dot( toEye, normal ), 0.0 );
			float reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );

			// calculate final uv coords
			vec3 coord = vCoord.xyz / vCoord.w;
			vec2 uv = coord.xy + coord.z * normal.xz * 0.05;

			vec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );
			vec4 refractColor = texture2D( tRefractionMap, uv );

			// multiply water color with the mix of both textures
			gl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>

		}`
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/utils/RoughnessMipmapper.js
var _mipmapMaterial = _getMipmapMaterial();
var _mesh = new Mesh(new PlaneGeometry(2, 2), _mipmapMaterial);
var _flatCamera = new OrthographicCamera(0, 1, 0, 1, 0, 1);
var _tempTarget = null;
var _renderer = null;
function RoughnessMipmapper(renderer) {
  _renderer = renderer;
  _renderer.compile(_mesh, _flatCamera);
}
RoughnessMipmapper.prototype = {
  constructor: RoughnessMipmapper,
  generateMipmaps: function(material) {
    if ("roughnessMap" in material === false)
      return;
    var {
      roughnessMap,
      normalMap
    } = material;
    if (roughnessMap === null || normalMap === null || !roughnessMap.generateMipmaps || material.userData.roughnessUpdated) {
      return;
    }
    material.userData.roughnessUpdated = true;
    var width = Math.max(roughnessMap.image.width, normalMap.image.width);
    var height = Math.max(roughnessMap.image.height, normalMap.image.height);
    if (!MathUtils.isPowerOfTwo(width) || !MathUtils.isPowerOfTwo(height))
      return;
    var oldTarget = _renderer.getRenderTarget();
    var autoClear = _renderer.autoClear;
    _renderer.autoClear = false;
    if (_tempTarget === null || _tempTarget.width !== width || _tempTarget.height !== height) {
      if (_tempTarget !== null)
        _tempTarget.dispose();
      _tempTarget = new WebGLRenderTarget(width, height, {
        depthBuffer: false
      });
      _tempTarget.scissorTest = true;
    }
    if (width !== roughnessMap.image.width || height !== roughnessMap.image.height) {
      var params = {
        wrapS: roughnessMap.wrapS,
        wrapT: roughnessMap.wrapT,
        magFilter: roughnessMap.magFilter,
        minFilter: roughnessMap.minFilter,
        depthBuffer: false
      };
      var newRoughnessTarget = new WebGLRenderTarget(width, height, params);
      newRoughnessTarget.texture.generateMipmaps = true;
      _renderer.setRenderTarget(newRoughnessTarget);
      material.roughnessMap = newRoughnessTarget.texture;
      if (material.metalnessMap == roughnessMap)
        material.metalnessMap = material.roughnessMap;
      if (material.aoMap == roughnessMap)
        material.aoMap = material.roughnessMap;
    }
    _mipmapMaterial.uniforms.roughnessMap.value = roughnessMap;
    _mipmapMaterial.uniforms.normalMap.value = normalMap;
    var position = new Vector2(0, 0);
    var texelSize = _mipmapMaterial.uniforms.texelSize.value;
    for (let mip = 0; width >= 1 && height >= 1; ++mip, width /= 2, height /= 2) {
      texelSize.set(1 / width, 1 / height);
      if (mip == 0)
        texelSize.set(0, 0);
      _tempTarget.viewport.set(position.x, position.y, width, height);
      _tempTarget.scissor.set(position.x, position.y, width, height);
      _renderer.setRenderTarget(_tempTarget);
      _renderer.render(_mesh, _flatCamera);
      _renderer.copyFramebufferToTexture(position, material.roughnessMap, mip);
      _mipmapMaterial.uniforms.roughnessMap.value = material.roughnessMap;
    }
    if (roughnessMap !== material.roughnessMap)
      roughnessMap.dispose();
    _renderer.setRenderTarget(oldTarget);
    _renderer.autoClear = autoClear;
  },
  dispose: function() {
    _mipmapMaterial.dispose();
    _mesh.geometry.dispose();
    if (_tempTarget != null)
      _tempTarget.dispose();
  }
};
function _getMipmapMaterial() {
  var shaderMaterial = new RawShaderMaterial({
    uniforms: {
      roughnessMap: {
        value: null
      },
      normalMap: {
        value: null
      },
      texelSize: {
        value: new Vector2(1, 1)
      }
    },
    vertexShader: `
			precision mediump float;
			precision mediump int;

			attribute vec3 position;
			attribute vec2 uv;

			varying vec2 vUv;

			void main() {

				vUv = uv;

				gl_Position = vec4( position, 1.0 );

			}
		`,
    fragmentShader: `
			precision mediump float;
			precision mediump int;

			varying vec2 vUv;

			uniform sampler2D roughnessMap;
			uniform sampler2D normalMap;
			uniform vec2 texelSize;

			#define ENVMAP_TYPE_CUBE_UV

			vec4 envMapTexelToLinear( vec4 a ) { return a; }

			#include <cube_uv_reflection_fragment>

			float roughnessToVariance( float roughness ) {

				float variance = 0.0;

				if ( roughness >= r1 ) {

					variance = ( r0 - roughness ) * ( v1 - v0 ) / ( r0 - r1 ) + v0;

				} else if ( roughness >= r4 ) {

					variance = ( r1 - roughness ) * ( v4 - v1 ) / ( r1 - r4 ) + v1;

				} else if ( roughness >= r5 ) {

					variance = ( r4 - roughness ) * ( v5 - v4 ) / ( r4 - r5 ) + v4;

				} else {

					float roughness2 = roughness * roughness;

					variance = 1.79 * roughness2 * roughness2;

				}

				return variance;

			}

			float varianceToRoughness( float variance ) {

				float roughness = 0.0;

				if ( variance >= v1 ) {

					roughness = ( v0 - variance ) * ( r1 - r0 ) / ( v0 - v1 ) + r0;

				} else if ( variance >= v4 ) {

					roughness = ( v1 - variance ) * ( r4 - r1 ) / ( v1 - v4 ) + r1;

				} else if ( variance >= v5 ) {

					roughness = ( v4 - variance ) * ( r5 - r4 ) / ( v4 - v5 ) + r4;

				} else {

					roughness = pow( 0.559 * variance, 0.25 ); // 0.559 = 1.0 / 1.79

				}

				return roughness;

			}

			void main() {

				gl_FragColor = texture2D( roughnessMap, vUv, - 1.0 );

				if ( texelSize.x == 0.0 ) return;

				float roughness = gl_FragColor.g;

				float variance = roughnessToVariance( roughness );

				vec3 avgNormal;

				for ( float x = - 1.0; x < 2.0; x += 2.0 ) {

					for ( float y = - 1.0; y < 2.0; y += 2.0 ) {

						vec2 uv = vUv + vec2( x, y ) * 0.25 * texelSize;

						avgNormal += normalize( texture2D( normalMap, uv, - 1.0 ).xyz - 0.5 );

					}

				}

				variance += 1.0 - 0.25 * length( avgNormal );

				gl_FragColor.g = varianceToRoughness( variance );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  shaderMaterial.type = "RoughnessMipmapper";
  return shaderMaterial;
}

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/utils/SkeletonUtils.js
var SkeletonUtils = {
  retarget: function() {
    var pos = new Vector3(), quat = new Quaternion(), scale = new Vector3(), bindBoneMatrix = new Matrix4(), relativeMatrix = new Matrix4(), globalMatrix = new Matrix4();
    return function(target, source, options) {
      options = options || {};
      options.preserveMatrix = options.preserveMatrix !== void 0 ? options.preserveMatrix : true;
      options.preservePosition = options.preservePosition !== void 0 ? options.preservePosition : true;
      options.preserveHipPosition = options.preserveHipPosition !== void 0 ? options.preserveHipPosition : false;
      options.useTargetMatrix = options.useTargetMatrix !== void 0 ? options.useTargetMatrix : false;
      options.hip = options.hip !== void 0 ? options.hip : "hip";
      options.names = options.names || {};
      var sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source), bones = target.isObject3D ? target.skeleton.bones : this.getBones(target), bindBones, bone, name, boneTo, bonesPosition, i2;
      if (target.isObject3D) {
        target.skeleton.pose();
      } else {
        options.useTargetMatrix = true;
        options.preserveMatrix = false;
      }
      if (options.preservePosition) {
        bonesPosition = [];
        for (i2 = 0; i2 < bones.length; i2++) {
          bonesPosition.push(bones[i2].position.clone());
        }
      }
      if (options.preserveMatrix) {
        target.updateMatrixWorld();
        target.matrixWorld.identity();
        for (i2 = 0; i2 < target.children.length; ++i2) {
          target.children[i2].updateMatrixWorld(true);
        }
      }
      if (options.offsets) {
        bindBones = [];
        for (i2 = 0; i2 < bones.length; ++i2) {
          bone = bones[i2];
          name = options.names[bone.name] || bone.name;
          if (options.offsets && options.offsets[name]) {
            bone.matrix.multiply(options.offsets[name]);
            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
            bone.updateMatrixWorld();
          }
          bindBones.push(bone.matrixWorld.clone());
        }
      }
      for (i2 = 0; i2 < bones.length; ++i2) {
        bone = bones[i2];
        name = options.names[bone.name] || bone.name;
        boneTo = this.getBoneByName(name, sourceBones);
        globalMatrix.copy(bone.matrixWorld);
        if (boneTo) {
          boneTo.updateMatrixWorld();
          if (options.useTargetMatrix) {
            relativeMatrix.copy(boneTo.matrixWorld);
          } else {
            relativeMatrix.copy(target.matrixWorld).invert();
            relativeMatrix.multiply(boneTo.matrixWorld);
          }
          scale.setFromMatrixScale(relativeMatrix);
          relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z));
          globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));
          if (target.isObject3D) {
            var boneIndex = bones.indexOf(bone), wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();
            globalMatrix.multiply(wBindMatrix);
          }
          globalMatrix.copyPosition(relativeMatrix);
        }
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.copy(bone.parent.matrixWorld).invert();
          bone.matrix.multiply(globalMatrix);
        } else {
          bone.matrix.copy(globalMatrix);
        }
        if (options.preserveHipPosition && name === options.hip) {
          bone.matrix.setPosition(pos.set(0, bone.position.y, 0));
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
        bone.updateMatrixWorld();
      }
      if (options.preservePosition) {
        for (i2 = 0; i2 < bones.length; ++i2) {
          bone = bones[i2];
          name = options.names[bone.name] || bone.name;
          if (name !== options.hip) {
            bone.position.copy(bonesPosition[i2]);
          }
        }
      }
      if (options.preserveMatrix) {
        target.updateMatrixWorld(true);
      }
    };
  }(),
  retargetClip: function(target, source, clip, options) {
    options = options || {};
    options.useFirstFramePosition = options.useFirstFramePosition !== void 0 ? options.useFirstFramePosition : false;
    options.fps = options.fps !== void 0 ? options.fps : 30;
    options.names = options.names || [];
    if (!source.isObject3D) {
      source = this.getHelperFromSkeleton(source);
    }
    var numFrames = Math.round(clip.duration * (options.fps / 1e3) * 1e3), delta = 1 / options.fps, convertedTracks = [], mixer = new AnimationMixer(source), bones = this.getBones(target.skeleton), boneDatas = [], positionOffset, bone, boneTo, boneData, name, i2, j2;
    mixer.clipAction(clip).play();
    mixer.update(0);
    source.updateMatrixWorld();
    for (i2 = 0; i2 < numFrames; ++i2) {
      var time = i2 * delta;
      this.retarget(target, source, options);
      for (j2 = 0; j2 < bones.length; ++j2) {
        name = options.names[bones[j2].name] || bones[j2].name;
        boneTo = this.getBoneByName(name, source.skeleton);
        if (boneTo) {
          bone = bones[j2];
          boneData = boneDatas[j2] = boneDatas[j2] || {
            bone
          };
          if (options.hip === name) {
            if (!boneData.pos) {
              boneData.pos = {
                times: new Float32Array(numFrames),
                values: new Float32Array(numFrames * 3)
              };
            }
            if (options.useFirstFramePosition) {
              if (i2 === 0) {
                positionOffset = bone.position.clone();
              }
              bone.position.sub(positionOffset);
            }
            boneData.pos.times[i2] = time;
            bone.position.toArray(boneData.pos.values, i2 * 3);
          }
          if (!boneData.quat) {
            boneData.quat = {
              times: new Float32Array(numFrames),
              values: new Float32Array(numFrames * 4)
            };
          }
          boneData.quat.times[i2] = time;
          bone.quaternion.toArray(boneData.quat.values, i2 * 4);
        }
      }
      mixer.update(delta);
      source.updateMatrixWorld();
    }
    for (i2 = 0; i2 < boneDatas.length; ++i2) {
      boneData = boneDatas[i2];
      if (boneData) {
        if (boneData.pos) {
          convertedTracks.push(new VectorKeyframeTrack(".bones[" + boneData.bone.name + "].position", boneData.pos.times, boneData.pos.values));
        }
        convertedTracks.push(new QuaternionKeyframeTrack(".bones[" + boneData.bone.name + "].quaternion", boneData.quat.times, boneData.quat.values));
      }
    }
    mixer.uncacheAction(clip);
    return new AnimationClip(clip.name, -1, convertedTracks);
  },
  getHelperFromSkeleton: function(skeleton) {
    var source = new SkeletonHelper(skeleton.bones[0]);
    source.skeleton = skeleton;
    return source;
  },
  getSkeletonOffsets: function() {
    var targetParentPos = new Vector3(), targetPos = new Vector3(), sourceParentPos = new Vector3(), sourcePos = new Vector3(), targetDir = new Vector2(), sourceDir = new Vector2();
    return function(target, source, options) {
      options = options || {};
      options.hip = options.hip !== void 0 ? options.hip : "hip";
      options.names = options.names || {};
      if (!source.isObject3D) {
        source = this.getHelperFromSkeleton(source);
      }
      var nameKeys = Object.keys(options.names), nameValues = Object.values(options.names), sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source), bones = target.isObject3D ? target.skeleton.bones : this.getBones(target), offsets = [], bone, boneTo, name, i2;
      target.skeleton.pose();
      for (i2 = 0; i2 < bones.length; ++i2) {
        bone = bones[i2];
        name = options.names[bone.name] || bone.name;
        boneTo = this.getBoneByName(name, sourceBones);
        if (boneTo && name !== options.hip) {
          var boneParent = this.getNearestBone(bone.parent, nameKeys), boneToParent = this.getNearestBone(boneTo.parent, nameValues);
          boneParent.updateMatrixWorld();
          boneToParent.updateMatrixWorld();
          targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);
          targetPos.setFromMatrixPosition(bone.matrixWorld);
          sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);
          sourcePos.setFromMatrixPosition(boneTo.matrixWorld);
          targetDir.subVectors(new Vector2(targetPos.x, targetPos.y), new Vector2(targetParentPos.x, targetParentPos.y)).normalize();
          sourceDir.subVectors(new Vector2(sourcePos.x, sourcePos.y), new Vector2(sourceParentPos.x, sourceParentPos.y)).normalize();
          var laterialAngle = targetDir.angle() - sourceDir.angle();
          var offset = new Matrix4().makeRotationFromEuler(new Euler(0, 0, laterialAngle));
          bone.matrix.multiply(offset);
          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
          bone.updateMatrixWorld();
          offsets[name] = offset;
        }
      }
      return offsets;
    };
  }(),
  renameBones: function(skeleton, names) {
    var bones = this.getBones(skeleton);
    for (let i2 = 0; i2 < bones.length; ++i2) {
      var bone = bones[i2];
      if (names[bone.name]) {
        bone.name = names[bone.name];
      }
    }
    return this;
  },
  getBones: function(skeleton) {
    return Array.isArray(skeleton) ? skeleton : skeleton.bones;
  },
  getBoneByName: function(name, skeleton) {
    for (let i2 = 0, bones = this.getBones(skeleton); i2 < bones.length; i2++) {
      if (name === bones[i2].name)
        return bones[i2];
    }
  },
  getNearestBone: function(bone, names) {
    while (bone.isBone) {
      if (names.indexOf(bone.name) !== -1) {
        return bone;
      }
      bone = bone.parent;
    }
  },
  findBoneTrackData: function(name, tracks) {
    var regexp = /\[(.*)\]\.(.*)/, result = {
      name
    };
    for (let i2 = 0; i2 < tracks.length; ++i2) {
      var trackData = regexp.exec(tracks[i2].name);
      if (trackData && name === trackData[1]) {
        result[trackData[2]] = i2;
      }
    }
    return result;
  },
  getEqualsBonesNames: function(skeleton, targetSkeleton) {
    var sourceBones = this.getBones(skeleton), targetBones = this.getBones(targetSkeleton), bones = [];
    search:
      for (let i2 = 0; i2 < sourceBones.length; i2++) {
        var boneName = sourceBones[i2].name;
        for (let j2 = 0; j2 < targetBones.length; j2++) {
          if (boneName === targetBones[j2].name) {
            bones.push(boneName);
            continue search;
          }
        }
      }
    return bones;
  },
  clone: function(source) {
    var sourceLookup = /* @__PURE__ */ new Map();
    var cloneLookup = /* @__PURE__ */ new Map();
    var clone = source.clone();
    parallelTraverse(source, clone, function(sourceNode, clonedNode) {
      sourceLookup.set(clonedNode, sourceNode);
      cloneLookup.set(sourceNode, clonedNode);
    });
    clone.traverse(function(node) {
      if (!node.isSkinnedMesh)
        return;
      var clonedMesh = node;
      var sourceMesh = sourceLookup.get(node);
      var sourceBones = sourceMesh.skeleton.bones;
      clonedMesh.skeleton = sourceMesh.skeleton.clone();
      clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);
      clonedMesh.skeleton.bones = sourceBones.map(function(bone) {
        return cloneLookup.get(bone);
      });
      clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);
    });
    return clone;
  }
};
function parallelTraverse(a2, b2, callback) {
  callback(a2, b2);
  for (let i2 = 0; i2 < a2.children.length; i2++) {
    parallelTraverse(a2.children[i2], b2.children[i2], callback);
  }
}

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/UnpackDepthRGBAShader.js
var UnpackDepthRGBAShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    opacity: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "#include <packing>", "void main() {", "	float depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );", "	gl_FragColor = vec4( vec3( depth ), opacity );", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/utils/ShadowMapViewer.js
var ShadowMapViewer = function(light) {
  var scope = this;
  var doRenderLabel = light.name !== void 0 && light.name !== "";
  var userAutoClearSetting;
  var frame = {
    x: 10,
    y: 10,
    width: 256,
    height: 256
  };
  var camera = new OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 1, 10);
  camera.position.set(0, 0, 2);
  var scene = new Scene();
  var shader = UnpackDepthRGBAShader;
  var uniforms = UniformsUtils.clone(shader.uniforms);
  var material = new ShaderMaterial({
    uniforms,
    vertexShader: shader.vertexShader,
    fragmentShader: shader.fragmentShader
  });
  var plane = new PlaneGeometry(frame.width, frame.height);
  var mesh = new Mesh(plane, material);
  scene.add(mesh);
  var labelCanvas, labelMesh;
  if (doRenderLabel) {
    labelCanvas = document.createElement("canvas");
    var context = labelCanvas.getContext("2d");
    context.font = "Bold 20px Arial";
    var labelWidth = context.measureText(light.name).width;
    labelCanvas.width = labelWidth;
    labelCanvas.height = 25;
    context.font = "Bold 20px Arial";
    context.fillStyle = "rgba( 255, 0, 0, 1 )";
    context.fillText(light.name, 0, 20);
    var labelTexture = new Texture(labelCanvas);
    labelTexture.magFilter = LinearFilter;
    labelTexture.minFilter = LinearFilter;
    labelTexture.needsUpdate = true;
    var labelMaterial = new MeshBasicMaterial({
      map: labelTexture,
      side: DoubleSide
    });
    labelMaterial.transparent = true;
    var labelPlane = new PlaneGeometry(labelCanvas.width, labelCanvas.height);
    labelMesh = new Mesh(labelPlane, labelMaterial);
    scene.add(labelMesh);
  }
  function resetPosition() {
    scope.position.set(scope.position.x, scope.position.y);
  }
  this.enabled = true;
  this.size = {
    width: frame.width,
    height: frame.height,
    set: function(width, height) {
      this.width = width;
      this.height = height;
      mesh.scale.set(this.width / frame.width, this.height / frame.height, 1);
      resetPosition();
    }
  };
  this.position = {
    x: frame.x,
    y: frame.y,
    set: function(x, y) {
      this.x = x;
      this.y = y;
      var width = scope.size.width;
      var height = scope.size.height;
      mesh.position.set(-window.innerWidth / 2 + width / 2 + this.x, window.innerHeight / 2 - height / 2 - this.y, 0);
      if (doRenderLabel) {
        labelMesh.position.set(mesh.position.x, mesh.position.y - scope.size.height / 2 + labelCanvas.height / 2, 0);
      }
    }
  };
  this.render = function(renderer) {
    if (this.enabled) {
      uniforms.tDiffuse.value = light.shadow.map.texture;
      userAutoClearSetting = renderer.autoClear;
      renderer.autoClear = false;
      renderer.clearDepth();
      renderer.render(scene, camera);
      renderer.autoClear = userAutoClearSetting;
    }
  };
  this.updateForWindowResize = function() {
    if (this.enabled) {
      camera.left = window.innerWidth / -2;
      camera.right = window.innerWidth / 2;
      camera.top = window.innerHeight / 2;
      camera.bottom = window.innerHeight / -2;
      camera.updateProjectionMatrix();
      this.update();
    }
  };
  this.update = function() {
    this.position.set(this.position.x, this.position.y);
    this.size.set(this.size.width, this.size.height);
  };
  this.update();
};
ShadowMapViewer.prototype.constructor = ShadowMapViewer;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/BokehShader2.js
var BokehShader2 = {
  uniforms: {
    textureWidth: {
      value: 1
    },
    textureHeight: {
      value: 1
    },
    focalDepth: {
      value: 1
    },
    focalLength: {
      value: 24
    },
    fstop: {
      value: 0.9
    },
    tColor: {
      value: null
    },
    tDepth: {
      value: null
    },
    maxblur: {
      value: 1
    },
    showFocus: {
      value: 0
    },
    manualdof: {
      value: 0
    },
    vignetting: {
      value: 0
    },
    depthblur: {
      value: 0
    },
    threshold: {
      value: 0.5
    },
    gain: {
      value: 2
    },
    bias: {
      value: 0.5
    },
    fringe: {
      value: 0.7
    },
    znear: {
      value: 0.1
    },
    zfar: {
      value: 100
    },
    noise: {
      value: 1
    },
    dithering: {
      value: 1e-4
    },
    pentagon: {
      value: 0
    },
    shaderFocus: {
      value: 1
    },
    focusCoords: {
      value: new Vector2()
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["#include <common>", "varying vec2 vUv;", "uniform sampler2D tColor;", "uniform sampler2D tDepth;", "uniform float textureWidth;", "uniform float textureHeight;", "uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below", "uniform float focalLength; //focal length in mm", "uniform float fstop; //f-stop value", "uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)", "/*", "make sure that these two values are the same for your camera, otherwise distances will be wrong.", "*/", "uniform float znear; // camera clipping start", "uniform float zfar; // camera clipping end", "//------------------------------------------", "//user variables", "const int samples = SAMPLES; //samples on the first ring", "const int rings = RINGS; //ring count", "const int maxringsamples = rings * samples;", "uniform bool manualdof; // manual dof calculation", "float ndofstart = 1.0; // near dof blur start", "float ndofdist = 2.0; // near dof blur falloff distance", "float fdofstart = 1.0; // far dof blur start", "float fdofdist = 3.0; // far dof blur falloff distance", "float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)", "uniform bool vignetting; // use optical lens vignetting", "float vignout = 1.3; // vignetting outer border", "float vignin = 0.0; // vignetting inner border", "float vignfade = 22.0; // f-stops till vignete fades", "uniform bool shaderFocus;", "// disable if you use external focalDepth value", "uniform vec2 focusCoords;", "// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)", "// if center of screen use vec2(0.5, 0.5);", "uniform float maxblur;", "//clamp value of max blur (0.0 = no blur, 1.0 default)", "uniform float threshold; // highlight threshold;", "uniform float gain; // highlight gain;", "uniform float bias; // bokeh edge bias", "uniform float fringe; // bokeh chromatic aberration / fringing", "uniform bool noise; //use noise instead of pattern for sample dithering", "uniform float dithering;", "uniform bool depthblur; // blur the depth buffer", "float dbsize = 1.25; // depth blur size", "/*", "next part is experimental", "not looking good with small sample and ring count", "looks okay starting from samples = 4, rings = 4", "*/", "uniform bool pentagon; //use pentagon as bokeh shape?", "float feather = 0.4; //pentagon shape feather", "//------------------------------------------", "float penta(vec2 coords) {", "	//pentagonal shape", "	float scale = float(rings) - 1.3;", "	vec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);", "	vec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);", "	vec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);", "	vec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);", "	vec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);", "	vec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);", "	vec4  one = vec4( 1.0 );", "	vec4 P = vec4((coords),vec2(scale, scale));", "	vec4 dist = vec4(0.0);", "	float inorout = -4.0;", "	dist.x = dot( P, HS0 );", "	dist.y = dot( P, HS1 );", "	dist.z = dot( P, HS2 );", "	dist.w = dot( P, HS3 );", "	dist = smoothstep( -feather, feather, dist );", "	inorout += dot( dist, one );", "	dist.x = dot( P, HS4 );", "	dist.y = HS5.w - abs( P.z );", "	dist = smoothstep( -feather, feather, dist );", "	inorout += dist.x;", "	return clamp( inorout, 0.0, 1.0 );", "}", "float bdepth(vec2 coords) {", "	// Depth buffer blur", "	float d = 0.0;", "	float kernel[9];", "	vec2 offset[9];", "	vec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;", "	offset[0] = vec2(-wh.x,-wh.y);", "	offset[1] = vec2( 0.0, -wh.y);", "	offset[2] = vec2( wh.x -wh.y);", "	offset[3] = vec2(-wh.x,  0.0);", "	offset[4] = vec2( 0.0,   0.0);", "	offset[5] = vec2( wh.x,  0.0);", "	offset[6] = vec2(-wh.x, wh.y);", "	offset[7] = vec2( 0.0,  wh.y);", "	offset[8] = vec2( wh.x, wh.y);", "	kernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;", "	kernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;", "	kernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;", "	for( int i=0; i<9; i++ ) {", "		float tmp = texture2D(tDepth, coords + offset[i]).r;", "		d += tmp * kernel[i];", "	}", "	return d;", "}", "vec3 color(vec2 coords,float blur) {", "	//processing the sample", "	vec3 col = vec3(0.0);", "	vec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);", "	col.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;", "	col.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;", "	col.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;", "	vec3 lumcoeff = vec3(0.299,0.587,0.114);", "	float lum = dot(col.rgb, lumcoeff);", "	float thresh = max((lum-threshold)*gain, 0.0);", "	return col+mix(vec3(0.0),col,thresh*blur);", "}", "vec3 debugFocus(vec3 col, float blur, float depth) {", "	float edge = 0.002*depth; //distance based edge smoothing", "	float m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);", "	float e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);", "	col = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);", "	col = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);", "	return col;", "}", "float linearize(float depth) {", "	return -zfar * znear / (depth * (zfar - znear) - zfar);", "}", "float vignette() {", "	float dist = distance(vUv.xy, vec2(0.5,0.5));", "	dist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);", "	return clamp(dist,0.0,1.0);", "}", "float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {", "	float rings2 = float(rings);", "	float step = PI*2.0 / float(ringsamples);", "	float pw = cos(j*step)*i;", "	float ph = sin(j*step)*i;", "	float p = 1.0;", "	if (pentagon) {", "		p = penta(vec2(pw,ph));", "	}", "	col += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;", "	return 1.0 * mix(1.0, i /rings2, bias) * p;", "}", "void main() {", "	//scene depth calculation", "	float depth = linearize(texture2D(tDepth,vUv.xy).x);", "	// Blur depth?", "	if ( depthblur ) {", "		depth = linearize(bdepth(vUv.xy));", "	}", "	//focal plane calculation", "	float fDepth = focalDepth;", "	if (shaderFocus) {", "		fDepth = linearize(texture2D(tDepth,focusCoords).x);", "	}", "	// dof blur factor calculation", "	float blur = 0.0;", "	if (manualdof) {", "		float a = depth-fDepth; // Focal plane", "		float b = (a-fdofstart)/fdofdist; // Far DoF", "		float c = (-a-ndofstart)/ndofdist; // Near Dof", "		blur = (a>0.0) ? b : c;", "	} else {", "		float f = focalLength; // focal length in mm", "		float d = fDepth*1000.0; // focal plane in mm", "		float o = depth*1000.0; // depth in mm", "		float a = (o*f)/(o-f);", "		float b = (d*f)/(d-f);", "		float c = (d-f)/(d*fstop*CoC);", "		blur = abs(a-b)*c;", "	}", "	blur = clamp(blur,0.0,1.0);", "	// calculation of pattern for dithering", "	vec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;", "	// getting blur x and y step factor", "	float w = (1.0/textureWidth)*blur*maxblur+noise.x;", "	float h = (1.0/textureHeight)*blur*maxblur+noise.y;", "	// calculation of final color", "	vec3 col = vec3(0.0);", "	if(blur < 0.05) {", "		//some optimization thingy", "		col = texture2D(tColor, vUv.xy).rgb;", "	} else {", "		col = texture2D(tColor, vUv.xy).rgb;", "		float s = 1.0;", "		int ringsamples;", "		for (int i = 1; i <= rings; i++) {", "			/*unboxstart*/", "			ringsamples = i * samples;", "			for (int j = 0 ; j < maxringsamples ; j++) {", "				if (j >= ringsamples) break;", "				s += gather(float(i), float(j), ringsamples, col, w, h, blur);", "			}", "			/*unboxend*/", "		}", "		col /= s; //divide by sample count", "	}", "	if (showFocus) {", "		col = debugFocus(col, blur, depth);", "	}", "	if (vignetting) {", "		col *= vignette();", "	}", "	gl_FragColor.rgb = col;", "	gl_FragColor.a = 1.0;", "} "].join("\n")
};
var BokehDepthShader = {
  uniforms: {
    mNear: {
      value: 1
    },
    mFar: {
      value: 1e3
    }
  },
  vertexShader: ["varying float vViewZDepth;", "void main() {", "	#include <begin_vertex>", "	#include <project_vertex>", "	vViewZDepth = - mvPosition.z;", "}"].join("\n"),
  fragmentShader: ["uniform float mNear;", "uniform float mFar;", "varying float vViewZDepth;", "void main() {", "	float color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );", "	gl_FragColor = vec4( vec3( color ), 1.0 );", "} "].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/math/MeshSurfaceSampler.js
var MeshSurfaceSampler = function() {
  var _face = new Triangle();
  var _color = new Vector3();
  function MeshSurfaceSampler2(mesh) {
    var geometry2 = mesh.geometry;
    if (!geometry2.isBufferGeometry || geometry2.attributes.position.itemSize !== 3) {
      throw new Error("THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.");
    }
    if (geometry2.index) {
      console.warn("THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.");
      geometry2 = geometry2.toNonIndexed();
    }
    this.geometry = geometry2;
    this.randomFunction = Math.random;
    this.positionAttribute = this.geometry.getAttribute("position");
    this.colorAttribute = this.geometry.getAttribute("color");
    this.weightAttribute = null;
    this.distribution = null;
  }
  MeshSurfaceSampler2.prototype = {
    constructor: MeshSurfaceSampler2,
    setWeightAttribute: function(name) {
      this.weightAttribute = name ? this.geometry.getAttribute(name) : null;
      return this;
    },
    build: function() {
      var positionAttribute = this.positionAttribute;
      var weightAttribute = this.weightAttribute;
      var faceWeights = new Float32Array(positionAttribute.count / 3);
      for (let i2 = 0; i2 < positionAttribute.count; i2 += 3) {
        var faceWeight = 1;
        if (weightAttribute) {
          faceWeight = weightAttribute.getX(i2) + weightAttribute.getX(i2 + 1) + weightAttribute.getX(i2 + 2);
        }
        _face.a.fromBufferAttribute(positionAttribute, i2);
        _face.b.fromBufferAttribute(positionAttribute, i2 + 1);
        _face.c.fromBufferAttribute(positionAttribute, i2 + 2);
        faceWeight *= _face.getArea();
        faceWeights[i2 / 3] = faceWeight;
      }
      this.distribution = new Float32Array(positionAttribute.count / 3);
      var cumulativeTotal = 0;
      for (let i2 = 0; i2 < faceWeights.length; i2++) {
        cumulativeTotal += faceWeights[i2];
        this.distribution[i2] = cumulativeTotal;
      }
      return this;
    },
    setRandomGenerator: function(randomFunction) {
      this.randomFunction = randomFunction;
      return this;
    },
    sample: function(targetPosition2, targetNormal, targetColor) {
      var cumulativeTotal = this.distribution[this.distribution.length - 1];
      var faceIndex = this.binarySearch(this.randomFunction() * cumulativeTotal);
      return this.sampleFace(faceIndex, targetPosition2, targetNormal, targetColor);
    },
    binarySearch: function(x) {
      var dist = this.distribution;
      var start = 0;
      var end = dist.length - 1;
      var index = -1;
      while (start <= end) {
        var mid = Math.ceil((start + end) / 2);
        if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {
          index = mid;
          break;
        } else if (x < dist[mid]) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return index;
    },
    sampleFace: function(faceIndex, targetPosition2, targetNormal, targetColor) {
      var u = this.randomFunction();
      var v3 = this.randomFunction();
      if (u + v3 > 1) {
        u = 1 - u;
        v3 = 1 - v3;
      }
      _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3);
      _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1);
      _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2);
      targetPosition2.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v3).addScaledVector(_face.c, 1 - (u + v3));
      if (targetNormal !== void 0) {
        _face.getNormal(targetNormal);
      }
      if (targetColor !== void 0 && this.colorAttribute !== void 0) {
        _face.a.fromBufferAttribute(this.colorAttribute, faceIndex * 3);
        _face.b.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 1);
        _face.c.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 2);
        _color.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v3).addScaledVector(_face.c, 1 - (u + v3));
        targetColor.r = _color.x;
        targetColor.g = _color.y;
        targetColor.b = _color.z;
      }
      return this;
    }
  };
  return MeshSurfaceSampler2;
}();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/math/OBB.js
var a = {
  c: null,
  u: [new Vector3(), new Vector3(), new Vector3()],
  e: []
};
var b = {
  c: null,
  u: [new Vector3(), new Vector3(), new Vector3()],
  e: []
};
var R = [[], [], []];
var AbsR = [[], [], []];
var t = [];
var xAxis = new Vector3();
var yAxis = new Vector3();
var zAxis = new Vector3();
var v1 = new Vector3();
var size = new Vector3();
var closestPoint = new Vector3();
var rotationMatrix = new Matrix3();
var aabb = new Box3();
var matrix2 = new Matrix4();
var inverse = new Matrix4();
var localRay = new Ray();
function OBB(center = new Vector3(), halfSize = new Vector3(), rotation = new Matrix3()) {
  this.center = center;
  this.halfSize = halfSize;
  this.rotation = rotation;
}
Object.assign(OBB.prototype, {
  set: function(center, halfSize, rotation) {
    this.center = center;
    this.halfSize = halfSize;
    this.rotation = rotation;
    return this;
  },
  copy: function(obb2) {
    this.center.copy(obb2.center);
    this.halfSize.copy(obb2.halfSize);
    this.rotation.copy(obb2.rotation);
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  getSize: function(result) {
    return result.copy(this.halfSize).multiplyScalar(2);
  },
  clampPoint: function(point, result) {
    var halfSize = this.halfSize;
    v1.subVectors(point, this.center);
    this.rotation.extractBasis(xAxis, yAxis, zAxis);
    result.copy(this.center);
    var x = MathUtils.clamp(v1.dot(xAxis), -halfSize.x, halfSize.x);
    result.add(xAxis.multiplyScalar(x));
    var y = MathUtils.clamp(v1.dot(yAxis), -halfSize.y, halfSize.y);
    result.add(yAxis.multiplyScalar(y));
    var z = MathUtils.clamp(v1.dot(zAxis), -halfSize.z, halfSize.z);
    result.add(zAxis.multiplyScalar(z));
    return result;
  },
  containsPoint: function(point) {
    v1.subVectors(point, this.center);
    this.rotation.extractBasis(xAxis, yAxis, zAxis);
    return Math.abs(v1.dot(xAxis)) <= this.halfSize.x && Math.abs(v1.dot(yAxis)) <= this.halfSize.y && Math.abs(v1.dot(zAxis)) <= this.halfSize.z;
  },
  intersectsBox3: function(box3) {
    return this.intersectsOBB(obb.fromBox3(box3));
  },
  intersectsSphere: function(sphere) {
    this.clampPoint(sphere.center, closestPoint);
    return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  },
  intersectsOBB: function(obb2, epsilon = Number.EPSILON) {
    a.c = this.center;
    a.e[0] = this.halfSize.x;
    a.e[1] = this.halfSize.y;
    a.e[2] = this.halfSize.z;
    this.rotation.extractBasis(a.u[0], a.u[1], a.u[2]);
    b.c = obb2.center;
    b.e[0] = obb2.halfSize.x;
    b.e[1] = obb2.halfSize.y;
    b.e[2] = obb2.halfSize.z;
    obb2.rotation.extractBasis(b.u[0], b.u[1], b.u[2]);
    for (let i2 = 0; i2 < 3; i2++) {
      for (let j2 = 0; j2 < 3; j2++) {
        R[i2][j2] = a.u[i2].dot(b.u[j2]);
      }
    }
    v1.subVectors(b.c, a.c);
    t[0] = v1.dot(a.u[0]);
    t[1] = v1.dot(a.u[1]);
    t[2] = v1.dot(a.u[2]);
    for (let i2 = 0; i2 < 3; i2++) {
      for (let j2 = 0; j2 < 3; j2++) {
        AbsR[i2][j2] = Math.abs(R[i2][j2]) + epsilon;
      }
    }
    var ra, rb;
    for (let i2 = 0; i2 < 3; i2++) {
      ra = a.e[i2];
      rb = b.e[0] * AbsR[i2][0] + b.e[1] * AbsR[i2][1] + b.e[2] * AbsR[i2][2];
      if (Math.abs(t[i2]) > ra + rb)
        return false;
    }
    for (let i2 = 0; i2 < 3; i2++) {
      ra = a.e[0] * AbsR[0][i2] + a.e[1] * AbsR[1][i2] + a.e[2] * AbsR[2][i2];
      rb = b.e[i2];
      if (Math.abs(t[0] * R[0][i2] + t[1] * R[1][i2] + t[2] * R[2][i2]) > ra + rb)
        return false;
    }
    ra = a.e[1] * AbsR[2][0] + a.e[2] * AbsR[1][0];
    rb = b.e[1] * AbsR[0][2] + b.e[2] * AbsR[0][1];
    if (Math.abs(t[2] * R[1][0] - t[1] * R[2][0]) > ra + rb)
      return false;
    ra = a.e[1] * AbsR[2][1] + a.e[2] * AbsR[1][1];
    rb = b.e[0] * AbsR[0][2] + b.e[2] * AbsR[0][0];
    if (Math.abs(t[2] * R[1][1] - t[1] * R[2][1]) > ra + rb)
      return false;
    ra = a.e[1] * AbsR[2][2] + a.e[2] * AbsR[1][2];
    rb = b.e[0] * AbsR[0][1] + b.e[1] * AbsR[0][0];
    if (Math.abs(t[2] * R[1][2] - t[1] * R[2][2]) > ra + rb)
      return false;
    ra = a.e[0] * AbsR[2][0] + a.e[2] * AbsR[0][0];
    rb = b.e[1] * AbsR[1][2] + b.e[2] * AbsR[1][1];
    if (Math.abs(t[0] * R[2][0] - t[2] * R[0][0]) > ra + rb)
      return false;
    ra = a.e[0] * AbsR[2][1] + a.e[2] * AbsR[0][1];
    rb = b.e[0] * AbsR[1][2] + b.e[2] * AbsR[1][0];
    if (Math.abs(t[0] * R[2][1] - t[2] * R[0][1]) > ra + rb)
      return false;
    ra = a.e[0] * AbsR[2][2] + a.e[2] * AbsR[0][2];
    rb = b.e[0] * AbsR[1][1] + b.e[1] * AbsR[1][0];
    if (Math.abs(t[0] * R[2][2] - t[2] * R[0][2]) > ra + rb)
      return false;
    ra = a.e[0] * AbsR[1][0] + a.e[1] * AbsR[0][0];
    rb = b.e[1] * AbsR[2][2] + b.e[2] * AbsR[2][1];
    if (Math.abs(t[1] * R[0][0] - t[0] * R[1][0]) > ra + rb)
      return false;
    ra = a.e[0] * AbsR[1][1] + a.e[1] * AbsR[0][1];
    rb = b.e[0] * AbsR[2][2] + b.e[2] * AbsR[2][0];
    if (Math.abs(t[1] * R[0][1] - t[0] * R[1][1]) > ra + rb)
      return false;
    ra = a.e[0] * AbsR[1][2] + a.e[1] * AbsR[0][2];
    rb = b.e[0] * AbsR[2][1] + b.e[1] * AbsR[2][0];
    if (Math.abs(t[1] * R[0][2] - t[0] * R[1][2]) > ra + rb)
      return false;
    return true;
  },
  intersectsPlane: function(plane) {
    this.rotation.extractBasis(xAxis, yAxis, zAxis);
    const r = this.halfSize.x * Math.abs(plane.normal.dot(xAxis)) + this.halfSize.y * Math.abs(plane.normal.dot(yAxis)) + this.halfSize.z * Math.abs(plane.normal.dot(zAxis));
    const d = plane.normal.dot(this.center) - plane.constant;
    return Math.abs(d) <= r;
  },
  intersectRay: function(ray, result) {
    this.getSize(size);
    aabb.setFromCenterAndSize(v1.set(0, 0, 0), size);
    matrix4FromRotationMatrix(matrix2, this.rotation);
    matrix2.setPosition(this.center);
    inverse.copy(matrix2).invert();
    localRay.copy(ray).applyMatrix4(inverse);
    if (localRay.intersectBox(aabb, result)) {
      return result.applyMatrix4(matrix2);
    } else {
      return null;
    }
  },
  intersectsRay: function(ray) {
    return this.intersectRay(ray, v1) !== null;
  },
  fromBox3: function(box3) {
    box3.getCenter(this.center);
    box3.getSize(this.halfSize).multiplyScalar(0.5);
    this.rotation.identity();
    return this;
  },
  equals: function(obb2) {
    return obb2.center.equals(this.center) && obb2.halfSize.equals(this.halfSize) && obb2.rotation.equals(this.rotation);
  },
  applyMatrix4: function(matrix3) {
    var e = matrix3.elements;
    var sx = v1.set(e[0], e[1], e[2]).length();
    var sy = v1.set(e[4], e[5], e[6]).length();
    var sz = v1.set(e[8], e[9], e[10]).length();
    var det = matrix3.determinant();
    if (det < 0)
      sx = -sx;
    rotationMatrix.setFromMatrix4(matrix3);
    var invSX = 1 / sx;
    var invSY = 1 / sy;
    var invSZ = 1 / sz;
    rotationMatrix.elements[0] *= invSX;
    rotationMatrix.elements[1] *= invSX;
    rotationMatrix.elements[2] *= invSX;
    rotationMatrix.elements[3] *= invSY;
    rotationMatrix.elements[4] *= invSY;
    rotationMatrix.elements[5] *= invSY;
    rotationMatrix.elements[6] *= invSZ;
    rotationMatrix.elements[7] *= invSZ;
    rotationMatrix.elements[8] *= invSZ;
    this.rotation.multiply(rotationMatrix);
    this.halfSize.x *= sx;
    this.halfSize.y *= sy;
    this.halfSize.z *= sz;
    v1.setFromMatrixPosition(matrix3);
    this.center.add(v1);
    return this;
  }
});
function matrix4FromRotationMatrix(matrix4, matrix3) {
  var e = matrix4.elements;
  var me = matrix3.elements;
  e[0] = me[0];
  e[1] = me[1];
  e[2] = me[2];
  e[3] = 0;
  e[4] = me[3];
  e[5] = me[4];
  e[6] = me[5];
  e[7] = 0;
  e[8] = me[6];
  e[9] = me[7];
  e[10] = me[8];
  e[11] = 0;
  e[12] = 0;
  e[13] = 0;
  e[14] = 0;
  e[15] = 1;
}
var obb = new OBB();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/math/Capsule.js
var Capsule = function() {
  var _v14 = new Vector3();
  var _v23 = new Vector3();
  var _v3 = new Vector3();
  var EPS = 1e-10;
  function Capsule2(start, end, radius) {
    this.start = start == void 0 ? new Vector3(0, 0, 0) : start;
    this.end = end == void 0 ? new Vector3(0, 1, 0) : end;
    this.radius = radius == void 0 ? 1 : radius;
  }
  Object.assign(Capsule2.prototype, {
    clone: function() {
      return new Capsule2(this.start.clone(), this.end.clone(), this.radius);
    },
    set: function(start, end, radius) {
      this.start.copy(start);
      this.end.copy(end);
      this.radius = radius;
    },
    copy: function(capsule) {
      this.start.copy(capsule.start);
      this.end.copy(capsule.end);
      this.radius = capsule.radius;
    },
    getCenter: function(target) {
      return target.copy(this.end).add(this.start).multiplyScalar(0.5);
    },
    translate: function(v3) {
      this.start.add(v3);
      this.end.add(v3);
    },
    checkAABBAxis: function(p1x, p1y, p2x, p2y, minx, maxx, miny, maxy, radius) {
      return (minx - p1x < radius || minx - p2x < radius) && (p1x - maxx < radius || p2x - maxx < radius) && (miny - p1y < radius || miny - p2y < radius) && (p1y - maxy < radius || p2y - maxy < radius);
    },
    intersectsBox: function(box) {
      return this.checkAABBAxis(this.start.x, this.start.y, this.end.x, this.end.y, box.min.x, box.max.x, box.min.y, box.max.y, this.radius) && this.checkAABBAxis(this.start.x, this.start.z, this.end.x, this.end.z, box.min.x, box.max.x, box.min.z, box.max.z, this.radius) && this.checkAABBAxis(this.start.y, this.start.z, this.end.y, this.end.z, box.min.y, box.max.y, box.min.z, box.max.z, this.radius);
    },
    lineLineMinimumPoints: function(line1, line2) {
      var r = _v14.copy(line1.end).sub(line1.start);
      var s = _v23.copy(line2.end).sub(line2.start);
      var w = _v3.copy(line2.start).sub(line1.start);
      var a2 = r.dot(s), b2 = r.dot(r), c2 = s.dot(s), d = s.dot(w), e = r.dot(w);
      var t1, t2, divisor = b2 * c2 - a2 * a2;
      if (Math.abs(divisor) < EPS) {
        var d1 = -d / c2;
        var d2 = (a2 - d) / c2;
        if (Math.abs(d1 - 0.5) < Math.abs(d2 - 0.5)) {
          t1 = 0;
          t2 = d1;
        } else {
          t1 = 1;
          t2 = d2;
        }
      } else {
        t1 = (d * a2 + e * c2) / divisor;
        t2 = (t1 * a2 - d) / c2;
      }
      t2 = Math.max(0, Math.min(1, t2));
      t1 = Math.max(0, Math.min(1, t1));
      var point1 = r.multiplyScalar(t1).add(line1.start);
      var point2 = s.multiplyScalar(t2).add(line2.start);
      return [point1, point2];
    }
  });
  return Capsule2;
}();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/math/ColorConverter.js
var ColorConverter = {
  setHSV: function(color3, h, s, v3) {
    h = MathUtils.euclideanModulo(h, 1);
    s = MathUtils.clamp(s, 0, 1);
    v3 = MathUtils.clamp(v3, 0, 1);
    return color3.setHSL(h, s * v3 / ((h = (2 - s) * v3) < 1 ? h : 2 - h), h * 0.5);
  },
  getHSV: function() {
    var hsl = {};
    return function getHSV(color3, target) {
      if (target === void 0) {
        console.warn("THREE.ColorConverter: .getHSV() target is now required");
        target = {
          h: 0,
          s: 0,
          l: 0
        };
      }
      color3.getHSL(hsl);
      hsl.s *= hsl.l < 0.5 ? hsl.l : 1 - hsl.l;
      target.h = hsl.h;
      target.s = 2 * hsl.s / (hsl.l + hsl.s);
      target.v = hsl.l + hsl.s;
      return target;
    };
  }(),
  setCMYK: function(color3, c2, m2, y, k) {
    var r = (1 - c2) * (1 - k);
    var g = (1 - m2) * (1 - k);
    var b2 = (1 - y) * (1 - k);
    return color3.setRGB(r, g, b2);
  },
  getCMYK: function(color3, target) {
    if (target === void 0) {
      console.warn("THREE.ColorConverter: .getCMYK() target is now required");
      target = {
        c: 0,
        m: 0,
        y: 0,
        k: 0
      };
    }
    var r = color3.r;
    var g = color3.g;
    var b2 = color3.b;
    var k = 1 - Math.max(r, g, b2);
    var c2 = (1 - r - k) / (1 - k);
    var m2 = (1 - g - k) / (1 - k);
    var y = (1 - b2 - k) / (1 - k);
    target.c = c2;
    target.m = m2;
    target.y = y;
    target.k = k;
    return target;
  }
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/math/Octree.js
var Octree = function() {
  var _v14 = new Vector3();
  var _v23 = new Vector3();
  var _plane2 = new Plane();
  var _line1 = new Line3();
  var _line2 = new Line3();
  var _sphere2 = new Sphere();
  var _capsule = new Capsule();
  function Octree2(box) {
    this.triangles = [];
    this.box = box;
    this.subTrees = [];
  }
  Object.assign(Octree2.prototype, {
    addTriangle: function(triangle) {
      if (!this.bounds)
        this.bounds = new Box3();
      this.bounds.min.x = Math.min(this.bounds.min.x, triangle.a.x, triangle.b.x, triangle.c.x);
      this.bounds.min.y = Math.min(this.bounds.min.y, triangle.a.y, triangle.b.y, triangle.c.y);
      this.bounds.min.z = Math.min(this.bounds.min.z, triangle.a.z, triangle.b.z, triangle.c.z);
      this.bounds.max.x = Math.max(this.bounds.max.x, triangle.a.x, triangle.b.x, triangle.c.x);
      this.bounds.max.y = Math.max(this.bounds.max.y, triangle.a.y, triangle.b.y, triangle.c.y);
      this.bounds.max.z = Math.max(this.bounds.max.z, triangle.a.z, triangle.b.z, triangle.c.z);
      this.triangles.push(triangle);
      return this;
    },
    calcBox: function() {
      this.box = this.bounds.clone();
      this.box.min.x -= 0.01;
      this.box.min.y -= 0.01;
      this.box.min.z -= 0.01;
      return this;
    },
    split: function(level) {
      if (!this.box)
        return;
      var subTrees = [], halfsize = _v23.copy(this.box.max).sub(this.box.min).multiplyScalar(0.5), box, v3, triangle;
      for (let x = 0; x < 2; x++) {
        for (let y = 0; y < 2; y++) {
          for (let z = 0; z < 2; z++) {
            box = new Box3();
            v3 = _v14.set(x, y, z);
            box.min.copy(this.box.min).add(v3.multiply(halfsize));
            box.max.copy(box.min).add(halfsize);
            subTrees.push(new Octree2(box));
          }
        }
      }
      while (triangle = this.triangles.pop()) {
        for (let i2 = 0; i2 < subTrees.length; i2++) {
          if (subTrees[i2].box.intersectsTriangle(triangle)) {
            subTrees[i2].triangles.push(triangle);
          }
        }
      }
      for (let i2 = 0; i2 < subTrees.length; i2++) {
        var len = subTrees[i2].triangles.length;
        if (len > 8 && level < 16) {
          subTrees[i2].split(level + 1);
        }
        if (len != 0) {
          this.subTrees.push(subTrees[i2]);
        }
      }
      return this;
    },
    build: function() {
      this.calcBox();
      this.split(0);
      return this;
    },
    getRayTriangles: function(ray, triangles) {
      for (let i2 = 0; i2 < this.subTrees.length; i2++) {
        var subTree = this.subTrees[i2];
        if (!ray.intersectsBox(subTree.box))
          continue;
        if (subTree.triangles.length > 0) {
          for (let j2 = 0; j2 < subTree.triangles.length; j2++) {
            if (triangles.indexOf(subTree.triangles[j2]) === -1)
              triangles.push(subTree.triangles[j2]);
          }
        } else {
          subTree.getRayTriangles(ray, triangles);
        }
      }
      return triangles;
    },
    triangleCapsuleIntersect: function(capsule, triangle) {
      var point1, point2, line1, line2;
      triangle.getPlane(_plane2);
      var d1 = _plane2.distanceToPoint(capsule.start) - capsule.radius;
      var d2 = _plane2.distanceToPoint(capsule.end) - capsule.radius;
      if (d1 > 0 && d2 > 0 || d1 < -capsule.radius && d2 < -capsule.radius) {
        return false;
      }
      var delta = Math.abs(d1 / (Math.abs(d1) + Math.abs(d2)));
      var intersectPoint = _v14.copy(capsule.start).lerp(capsule.end, delta);
      if (triangle.containsPoint(intersectPoint)) {
        return {
          normal: _plane2.normal.clone(),
          point: intersectPoint.clone(),
          depth: Math.abs(Math.min(d1, d2))
        };
      }
      var r2 = capsule.radius * capsule.radius;
      line1 = _line1.set(capsule.start, capsule.end);
      var lines = [[triangle.a, triangle.b], [triangle.b, triangle.c], [triangle.c, triangle.a]];
      for (let i2 = 0; i2 < lines.length; i2++) {
        line2 = _line2.set(lines[i2][0], lines[i2][1]);
        [point1, point2] = capsule.lineLineMinimumPoints(line1, line2);
        if (point1.distanceToSquared(point2) < r2) {
          return {
            normal: point1.clone().sub(point2).normalize(),
            point: point2.clone(),
            depth: capsule.radius - point1.distanceTo(point2)
          };
        }
      }
      return false;
    },
    triangleSphereIntersect: function(sphere, triangle) {
      triangle.getPlane(_plane2);
      if (!sphere.intersectsPlane(_plane2))
        return false;
      var depth = Math.abs(_plane2.distanceToSphere(sphere));
      var r2 = sphere.radius * sphere.radius - depth * depth;
      var plainPoint = _plane2.projectPoint(sphere.center, _v14);
      if (triangle.containsPoint(sphere.center)) {
        return {
          normal: _plane2.normal.clone(),
          point: plainPoint.clone(),
          depth: Math.abs(_plane2.distanceToSphere(sphere))
        };
      }
      var lines = [[triangle.a, triangle.b], [triangle.b, triangle.c], [triangle.c, triangle.a]];
      for (let i2 = 0; i2 < lines.length; i2++) {
        _line1.set(lines[i2][0], lines[i2][1]);
        _line1.closestPointToPoint(plainPoint, true, _v23);
        var d = _v23.distanceToSquared(sphere.center);
        if (d < r2) {
          return {
            normal: sphere.center.clone().sub(_v23).normalize(),
            point: _v23.clone(),
            depth: sphere.radius - Math.sqrt(d)
          };
        }
      }
      return false;
    },
    getSphereTriangles: function(sphere, triangles) {
      for (let i2 = 0; i2 < this.subTrees.length; i2++) {
        var subTree = this.subTrees[i2];
        if (!sphere.intersectsBox(subTree.box))
          continue;
        if (subTree.triangles.length > 0) {
          for (let j2 = 0; j2 < subTree.triangles.length; j2++) {
            if (triangles.indexOf(subTree.triangles[j2]) === -1)
              triangles.push(subTree.triangles[j2]);
          }
        } else {
          subTree.getSphereTriangles(sphere, triangles);
        }
      }
    },
    getCapsuleTriangles: function(capsule, triangles) {
      for (let i2 = 0; i2 < this.subTrees.length; i2++) {
        var subTree = this.subTrees[i2];
        if (!capsule.intersectsBox(subTree.box))
          continue;
        if (subTree.triangles.length > 0) {
          for (let j2 = 0; j2 < subTree.triangles.length; j2++) {
            if (triangles.indexOf(subTree.triangles[j2]) === -1)
              triangles.push(subTree.triangles[j2]);
          }
        } else {
          subTree.getCapsuleTriangles(capsule, triangles);
        }
      }
    },
    sphereIntersect(sphere) {
      _sphere2.copy(sphere);
      var triangles = [], result, hit = false;
      this.getSphereTriangles(sphere, triangles);
      for (let i2 = 0; i2 < triangles.length; i2++) {
        if (result = this.triangleSphereIntersect(_sphere2, triangles[i2])) {
          hit = true;
          _sphere2.center.add(result.normal.multiplyScalar(result.depth));
        }
      }
      if (hit) {
        var collisionVector = _sphere2.center.clone().sub(sphere.center);
        var depth = collisionVector.length();
        return {
          normal: collisionVector.normalize(),
          depth
        };
      }
      return false;
    },
    capsuleIntersect: function(capsule) {
      _capsule.copy(capsule);
      var triangles = [], result, hit = false;
      this.getCapsuleTriangles(_capsule, triangles);
      for (let i2 = 0; i2 < triangles.length; i2++) {
        if (result = this.triangleCapsuleIntersect(_capsule, triangles[i2])) {
          hit = true;
          _capsule.translate(result.normal.multiplyScalar(result.depth));
        }
      }
      if (hit) {
        var collisionVector = _capsule.getCenter(new Vector3()).sub(capsule.getCenter(_v14));
        var depth = collisionVector.length();
        return {
          normal: collisionVector.normalize(),
          depth
        };
      }
      return false;
    },
    rayIntersect: function(ray) {
      if (ray.direction.length() === 0)
        return;
      var triangles = [], triangle, position, distance2 = 1e100, result;
      this.getRayTriangles(ray, triangles);
      for (let i2 = 0; i2 < triangles.length; i2++) {
        result = ray.intersectTriangle(triangles[i2].a, triangles[i2].b, triangles[i2].c, true, _v14);
        if (result) {
          var newdistance = result.sub(ray.origin).length();
          if (distance2 > newdistance) {
            position = result.clone().add(ray.origin);
            distance2 = newdistance;
            triangle = triangles[i2];
          }
        }
      }
      return distance2 < 1e100 ? {
        distance: distance2,
        triangle,
        position
      } : false;
    },
    fromGraphNode: function(group) {
      group.traverse((obj) => {
        if (obj.type === "Mesh") {
          obj.updateMatrix();
          obj.updateWorldMatrix();
          var geometry2, isTemp = false;
          if (obj.geometry.index) {
            isTemp = true;
            geometry2 = obj.geometry.clone().toNonIndexed();
          } else {
            geometry2 = obj.geometry;
          }
          var positions = geometry2.attributes.position.array;
          var transform = obj.matrixWorld;
          for (let i2 = 0; i2 < positions.length; i2 += 9) {
            var v12 = new Vector3(positions[i2], positions[i2 + 1], positions[i2 + 2]);
            var v22 = new Vector3(positions[i2 + 3], positions[i2 + 4], positions[i2 + 5]);
            var v3 = new Vector3(positions[i2 + 6], positions[i2 + 7], positions[i2 + 8]);
            v12.applyMatrix4(transform);
            v22.applyMatrix4(transform);
            v3.applyMatrix4(transform);
            this.addTriangle(new Triangle(v12, v22, v3));
          }
          if (isTemp) {
            geometry2.dispose();
          }
        }
      });
      this.build();
      return this;
    }
  });
  return Octree2;
}();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/math/Lut.js
var Lut = function(colormap, numberofcolors) {
  this.lut = [];
  this.setColorMap(colormap, numberofcolors);
  return this;
};
Lut.prototype = {
  constructor: Lut,
  lut: [],
  map: [],
  n: 256,
  minV: 0,
  maxV: 1,
  set: function(value) {
    if (value instanceof Lut) {
      this.copy(value);
    }
    return this;
  },
  setMin: function(min2) {
    this.minV = min2;
    return this;
  },
  setMax: function(max2) {
    this.maxV = max2;
    return this;
  },
  setColorMap: function(colormap, numberofcolors) {
    this.map = ColorMapKeywords[colormap] || ColorMapKeywords.rainbow;
    this.n = numberofcolors || 32;
    var step2 = 1 / this.n;
    this.lut.length = 0;
    for (let i2 = 0; i2 <= 1; i2 += step2) {
      for (let j2 = 0; j2 < this.map.length - 1; j2++) {
        if (i2 >= this.map[j2][0] && i2 < this.map[j2 + 1][0]) {
          var min2 = this.map[j2][0];
          var max2 = this.map[j2 + 1][0];
          var minColor = new Color(this.map[j2][1]);
          var maxColor = new Color(this.map[j2 + 1][1]);
          var color3 = minColor.lerp(maxColor, (i2 - min2) / (max2 - min2));
          this.lut.push(color3);
        }
      }
    }
    return this;
  },
  copy: function(lut) {
    this.lut = lut.lut;
    this.map = lut.map;
    this.n = lut.n;
    this.minV = lut.minV;
    this.maxV = lut.maxV;
    return this;
  },
  getColor: function(alpha) {
    if (alpha <= this.minV) {
      alpha = this.minV;
    } else if (alpha >= this.maxV) {
      alpha = this.maxV;
    }
    alpha = (alpha - this.minV) / (this.maxV - this.minV);
    var colorPosition = Math.round(alpha * this.n);
    colorPosition == this.n ? colorPosition -= 1 : colorPosition;
    return this.lut[colorPosition];
  },
  addColorMap: function(colormapName, arrayOfColors) {
    ColorMapKeywords[colormapName] = arrayOfColors;
  },
  createCanvas: function() {
    var canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = this.n;
    this.updateCanvas(canvas);
    return canvas;
  },
  updateCanvas: function(canvas) {
    var ctx = canvas.getContext("2d", {
      alpha: false
    });
    var imageData = ctx.getImageData(0, 0, 1, this.n);
    var data = imageData.data;
    var k = 0;
    var step2 = 1 / this.n;
    for (let i2 = 1; i2 >= 0; i2 -= step2) {
      for (let j2 = this.map.length - 1; j2 >= 0; j2--) {
        if (i2 < this.map[j2][0] && i2 >= this.map[j2 - 1][0]) {
          var min2 = this.map[j2 - 1][0];
          var max2 = this.map[j2][0];
          var minColor = new Color(this.map[j2 - 1][1]);
          var maxColor = new Color(this.map[j2][1]);
          var color3 = minColor.lerp(maxColor, (i2 - min2) / (max2 - min2));
          data[k * 4] = Math.round(color3.r * 255);
          data[k * 4 + 1] = Math.round(color3.g * 255);
          data[k * 4 + 2] = Math.round(color3.b * 255);
          data[k * 4 + 3] = 255;
          k += 1;
        }
      }
    }
    ctx.putImageData(imageData, 0, 0);
    return canvas;
  }
};
var ColorMapKeywords = {
  rainbow: [[0, 255], [0.2, 65535], [0.5, 65280], [0.8, 16776960], [1, 16711680]],
  cooltowarm: [[0, 3952322], [0.2, 10206463], [0.5, 14474460], [0.8, 16163717], [1, 11797542]],
  blackbody: [[0, 0], [0.2, 7864320], [0.5, 15086080], [0.8, 16776960], [1, 16777215]],
  grayscale: [[0, 0], [0.2, 4210752], [0.5, 8355712], [0.8, 12566463], [1, 16777215]]
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/controls/experimental/CameraControls.js
var STATE;
(function(STATE3) {
  STATE3[STATE3["NONE"] = -1] = "NONE";
  STATE3[STATE3["ROTATE"] = 0] = "ROTATE";
  STATE3[STATE3["DOLLY"] = 1] = "DOLLY";
  STATE3[STATE3["PAN"] = 2] = "PAN";
  STATE3[STATE3["TOUCH_ROTATE"] = 3] = "TOUCH_ROTATE";
  STATE3[STATE3["TOUCH_PAN"] = 4] = "TOUCH_PAN";
  STATE3[STATE3["TOUCH_DOLLY_PAN"] = 5] = "TOUCH_DOLLY_PAN";
  STATE3[STATE3["TOUCH_DOLLY_ROTATE"] = 6] = "TOUCH_DOLLY_ROTATE";
})(STATE || (STATE = {}));

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/controls/FirstPersonControls.js
var targetPosition = new Vector3();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/controls/ArcballControls.js
var STATE2 = {
  IDLE: Symbol(),
  ROTATE: Symbol(),
  PAN: Symbol(),
  SCALE: Symbol(),
  FOV: Symbol(),
  FOCUS: Symbol(),
  ZROTATE: Symbol(),
  TOUCH_MULTI: Symbol(),
  ANIMATION_FOCUS: Symbol(),
  ANIMATION_ROTATE: Symbol()
};
var INPUT = {
  NONE: Symbol(),
  ONE_FINGER: Symbol(),
  ONE_FINGER_SWITCHED: Symbol(),
  TWO_FINGER: Symbol(),
  MULT_FINGER: Symbol(),
  CURSOR: Symbol()
};
var _transformation = {
  camera: new Matrix4(),
  gizmos: new Matrix4()
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/postprocessing/Pass.js
var Pass2 = class {
  constructor() {
    _defineProperty(this, "enabled", true);
    _defineProperty(this, "needsSwap", true);
    _defineProperty(this, "clear", false);
    _defineProperty(this, "renderToScreen", false);
  }
  setSize(width, height) {
  }
  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
};
var FullScreenQuad = class {
  constructor(material) {
    _defineProperty(this, "camera", new OrthographicCamera(-1, 1, 1, -1, 0, 1));
    _defineProperty(this, "geometry", new PlaneGeometry(2, 2));
    _defineProperty(this, "mesh", void 0);
    this.mesh = new Mesh(this.geometry, material);
  }
  get material() {
    return this.mesh.material;
  }
  set material(value) {
    this.mesh.material = value;
  }
  dispose() {
    this.mesh.geometry.dispose();
  }
  render(renderer) {
    renderer.render(this.mesh, this.camera);
  }
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/DigitalGlitch.js
var DigitalGlitch = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    tDisp: {
      value: null
    },
    byp: {
      value: 0
    },
    amount: {
      value: 0.08
    },
    angle: {
      value: 0.02
    },
    seed: {
      value: 0.02
    },
    seed_x: {
      value: 0.02
    },
    seed_y: {
      value: 0.02
    },
    distortion_x: {
      value: 0.5
    },
    distortion_y: {
      value: 0.6
    },
    col_s: {
      value: 0.05
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "uniform int byp;",
    "uniform sampler2D tDiffuse;",
    "uniform sampler2D tDisp;",
    "uniform float amount;",
    "uniform float angle;",
    "uniform float seed;",
    "uniform float seed_x;",
    "uniform float seed_y;",
    "uniform float distortion_x;",
    "uniform float distortion_y;",
    "uniform float col_s;",
    "varying vec2 vUv;",
    "float rand(vec2 co){",
    "	return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);",
    "}",
    "void main() {",
    "	if(byp<1) {",
    "		vec2 p = vUv;",
    "		float xs = floor(gl_FragCoord.x / 0.5);",
    "		float ys = floor(gl_FragCoord.y / 0.5);",
    "		vec4 normal = texture2D (tDisp, p*seed*seed);",
    "		if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {",
    "			if(seed_x>0.){",
    "				p.y = 1. - (p.y + distortion_y);",
    "			}",
    "			else {",
    "				p.y = distortion_y;",
    "			}",
    "		}",
    "		if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {",
    "			if(seed_y>0.){",
    "				p.x=distortion_x;",
    "			}",
    "			else {",
    "				p.x = 1. - (p.x + distortion_x);",
    "			}",
    "		}",
    "		p.x+=normal.x*seed_x*(seed/5.);",
    "		p.y+=normal.y*seed_y*(seed/5.);",
    "		vec2 offset = amount * vec2( cos(angle), sin(angle));",
    "		vec4 cr = texture2D(tDiffuse, p + offset);",
    "		vec4 cga = texture2D(tDiffuse, p);",
    "		vec4 cb = texture2D(tDiffuse, p - offset);",
    "		gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);",
    "		vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);",
    "		gl_FragColor = gl_FragColor+ snow;",
    "	}",
    "	else {",
    "		gl_FragColor=texture2D (tDiffuse, vUv);",
    "	}",
    "}"
  ].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/HalftoneShader.js
var HalftoneShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    shape: {
      value: 1
    },
    radius: {
      value: 4
    },
    rotateR: {
      value: Math.PI / 12 * 1
    },
    rotateG: {
      value: Math.PI / 12 * 2
    },
    rotateB: {
      value: Math.PI / 12 * 3
    },
    scatter: {
      value: 0
    },
    width: {
      value: 1
    },
    height: {
      value: 1
    },
    blending: {
      value: 1
    },
    blendingMode: {
      value: 1
    },
    greyscale: {
      value: false
    },
    disable: {
      value: false
    }
  },
  vertexShader: ["varying vec2 vUV;", "void main() {", "	vUV = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);", "}"].join("\n"),
  fragmentShader: [
    "#define SQRT2_MINUS_ONE 0.41421356",
    "#define SQRT2_HALF_MINUS_ONE 0.20710678",
    "#define PI2 6.28318531",
    "#define SHAPE_DOT 1",
    "#define SHAPE_ELLIPSE 2",
    "#define SHAPE_LINE 3",
    "#define SHAPE_SQUARE 4",
    "#define BLENDING_LINEAR 1",
    "#define BLENDING_MULTIPLY 2",
    "#define BLENDING_ADD 3",
    "#define BLENDING_LIGHTER 4",
    "#define BLENDING_DARKER 5",
    "uniform sampler2D tDiffuse;",
    "uniform float radius;",
    "uniform float rotateR;",
    "uniform float rotateG;",
    "uniform float rotateB;",
    "uniform float scatter;",
    "uniform float width;",
    "uniform float height;",
    "uniform int shape;",
    "uniform bool disable;",
    "uniform float blending;",
    "uniform int blendingMode;",
    "varying vec2 vUV;",
    "uniform bool greyscale;",
    "const int samples = 8;",
    "float blend( float a, float b, float t ) {",
    "	return a * ( 1.0 - t ) + b * t;",
    "}",
    "float hypot( float x, float y ) {",
    "	return sqrt( x * x + y * y );",
    "}",
    "float rand( vec2 seed ){",
    "return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );",
    "}",
    "float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {",
    "	float dist = hypot( coord.x - p.x, coord.y - p.y );",
    "	float rad = channel;",
    "	if ( shape == SHAPE_DOT ) {",
    "		rad = pow( abs( rad ), 1.125 ) * rad_max;",
    "	} else if ( shape == SHAPE_ELLIPSE ) {",
    "		rad = pow( abs( rad ), 1.125 ) * rad_max;",
    "		if ( dist != 0.0 ) {",
    "			float dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );",
    "			dist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;",
    "		}",
    "	} else if ( shape == SHAPE_LINE ) {",
    "		rad = pow( abs( rad ), 1.5) * rad_max;",
    "		float dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;",
    "		dist = hypot( normal.x * dot_p, normal.y * dot_p );",
    "	} else if ( shape == SHAPE_SQUARE ) {",
    "		float theta = atan( p.y - coord.y, p.x - coord.x ) - angle;",
    "		float sin_t = abs( sin( theta ) );",
    "		float cos_t = abs( cos( theta ) );",
    "		rad = pow( abs( rad ), 1.4 );",
    "		rad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );",
    "	}",
    "	return rad - dist;",
    "}",
    "struct Cell {",
    "	vec2 normal;",
    "	vec2 p1;",
    "	vec2 p2;",
    "	vec2 p3;",
    "	vec2 p4;",
    "	float samp2;",
    "	float samp1;",
    "	float samp3;",
    "	float samp4;",
    "};",
    "vec4 getSample( vec2 point ) {",
    "	vec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );",
    "	float base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;",
    "	float step = PI2 / float( samples );",
    "	float dist = radius * 0.66;",
    "	for ( int i = 0; i < samples; ++i ) {",
    "		float r = base + step * float( i );",
    "		vec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );",
    "		tex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );",
    "	}",
    "	tex /= float( samples ) + 1.0;",
    "	return tex;",
    "}",
    "float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {",
    "	float dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;",
    "	if ( channel == 0 ) {",
    "		c.samp1 = getSample( c.p1 ).r;",
    "		c.samp2 = getSample( c.p2 ).r;",
    "		c.samp3 = getSample( c.p3 ).r;",
    "		c.samp4 = getSample( c.p4 ).r;",
    "	} else if (channel == 1) {",
    "		c.samp1 = getSample( c.p1 ).g;",
    "		c.samp2 = getSample( c.p2 ).g;",
    "		c.samp3 = getSample( c.p3 ).g;",
    "		c.samp4 = getSample( c.p4 ).g;",
    "	} else {",
    "		c.samp1 = getSample( c.p1 ).b;",
    "		c.samp3 = getSample( c.p3 ).b;",
    "		c.samp2 = getSample( c.p2 ).b;",
    "		c.samp4 = getSample( c.p4 ).b;",
    "	}",
    "	dist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );",
    "	dist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );",
    "	dist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );",
    "	dist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );",
    "	res = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;",
    "	res += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;",
    "	res += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;",
    "	res += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;",
    "	res = clamp( res, 0.0, 1.0 );",
    "	return res;",
    "}",
    "Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {",
    "	Cell c;",
    "	vec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );",
    "	float threshold = step * 0.5;",
    "	float dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );",
    "	float dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );",
    "	vec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );",
    "	float offset_normal = mod( hypot( offset.x, offset.y ), step );",
    "	float normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;",
    "	float normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;",
    "	float offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );",
    "	float line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;",
    "	float line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;",
    "	c.normal = n;",
    "	c.p1.x = p.x - n.x * normal_scale + n.y * line_scale;",
    "	c.p1.y = p.y - n.y * normal_scale - n.x * line_scale;",
    "	if ( scatter != 0.0 ) {",
    "		float off_mag = scatter * threshold * 0.5;",
    "		float off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;",
    "		c.p1.x += cos( off_angle ) * off_mag;",
    "		c.p1.y += sin( off_angle ) * off_mag;",
    "	}",
    "	float normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );",
    "	float line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );",
    "	c.p2.x = c.p1.x - n.x * normal_step;",
    "	c.p2.y = c.p1.y - n.y * normal_step;",
    "	c.p3.x = c.p1.x + n.y * line_step;",
    "	c.p3.y = c.p1.y - n.x * line_step;",
    "	c.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;",
    "	c.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;",
    "	return c;",
    "}",
    "float blendColour( float a, float b, float t ) {",
    "	if ( blendingMode == BLENDING_LINEAR ) {",
    "		return blend( a, b, 1.0 - t );",
    "	} else if ( blendingMode == BLENDING_ADD ) {",
    "		return blend( a, min( 1.0, a + b ), t );",
    "	} else if ( blendingMode == BLENDING_MULTIPLY ) {",
    "		return blend( a, max( 0.0, a * b ), t );",
    "	} else if ( blendingMode == BLENDING_LIGHTER ) {",
    "		return blend( a, max( a, b ), t );",
    "	} else if ( blendingMode == BLENDING_DARKER ) {",
    "		return blend( a, min( a, b ), t );",
    "	} else {",
    "		return blend( a, b, 1.0 - t );",
    "	}",
    "}",
    "void main() {",
    "	if ( ! disable ) {",
    "		vec2 p = vec2( vUV.x * width, vUV.y * height );",
    "		vec2 origin = vec2( 0, 0 );",
    "		float aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;",
    "		Cell cell_r = getReferenceCell( p, origin, rotateR, radius );",
    "		Cell cell_g = getReferenceCell( p, origin, rotateG, radius );",
    "		Cell cell_b = getReferenceCell( p, origin, rotateB, radius );",
    "		float r = getDotColour( cell_r, p, 0, rotateR, aa );",
    "		float g = getDotColour( cell_g, p, 1, rotateG, aa );",
    "		float b = getDotColour( cell_b, p, 2, rotateB, aa );",
    "		vec4 colour = texture2D( tDiffuse, vUV );",
    "		r = blendColour( r, colour.r, blending );",
    "		g = blendColour( g, colour.g, blending );",
    "		b = blendColour( b, colour.b, blending );",
    "		if ( greyscale ) {",
    "			r = g = b = (r + b + g) / 3.0;",
    "		}",
    "		gl_FragColor = vec4( r, g, b, 1.0 );",
    "	} else {",
    "		gl_FragColor = texture2D( tDiffuse, vUV );",
    "	}",
    "}"
  ].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/SMAAShader.js
var SMAAEdgesShader = {
  defines: {
    SMAA_THRESHOLD: "0.1"
  },
  uniforms: {
    tDiffuse: {
      value: null
    },
    resolution: {
      value: new Vector2(1 / 1024, 1 / 512)
    }
  },
  vertexShader: [
    "uniform vec2 resolution;",
    "varying vec2 vUv;",
    "varying vec4 vOffset[ 3 ];",
    "void SMAAEdgeDetectionVS( vec2 texcoord ) {",
    "	vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );",
    "	vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );",
    "	vOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );",
    "}",
    "void main() {",
    "	vUv = uv;",
    "	SMAAEdgeDetectionVS( vUv );",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "varying vec4 vOffset[ 3 ];",
    "vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {",
    "	vec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );",
    "	vec4 delta;",
    "	vec3 C = texture2D( colorTex, texcoord ).rgb;",
    "	vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;",
    "	vec3 t = abs( C - Cleft );",
    "	delta.x = max( max( t.r, t.g ), t.b );",
    "	vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;",
    "	t = abs( C - Ctop );",
    "	delta.y = max( max( t.r, t.g ), t.b );",
    "	vec2 edges = step( threshold, delta.xy );",
    "	if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )",
    "		discard;",
    "	vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;",
    "	t = abs( C - Cright );",
    "	delta.z = max( max( t.r, t.g ), t.b );",
    "	vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;",
    "	t = abs( C - Cbottom );",
    "	delta.w = max( max( t.r, t.g ), t.b );",
    "	float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );",
    "	vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;",
    "	t = abs( C - Cleftleft );",
    "	delta.z = max( max( t.r, t.g ), t.b );",
    "	vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;",
    "	t = abs( C - Ctoptop );",
    "	delta.w = max( max( t.r, t.g ), t.b );",
    "	maxDelta = max( max( maxDelta, delta.z ), delta.w );",
    "	edges.xy *= step( 0.5 * maxDelta, delta.xy );",
    "	return vec4( edges, 0.0, 0.0 );",
    "}",
    "void main() {",
    "	gl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );",
    "}"
  ].join("\n")
};
var SMAAWeightsShader = {
  defines: {
    SMAA_MAX_SEARCH_STEPS: "8",
    SMAA_AREATEX_MAX_DISTANCE: "16",
    SMAA_AREATEX_PIXEL_SIZE: "( 1.0 / vec2( 160.0, 560.0 ) )",
    SMAA_AREATEX_SUBTEX_SIZE: "( 1.0 / 7.0 )"
  },
  uniforms: {
    tDiffuse: {
      value: null
    },
    tArea: {
      value: null
    },
    tSearch: {
      value: null
    },
    resolution: {
      value: new Vector2(1 / 1024, 1 / 512)
    }
  },
  vertexShader: [
    "uniform vec2 resolution;",
    "varying vec2 vUv;",
    "varying vec4 vOffset[ 3 ];",
    "varying vec2 vPixcoord;",
    "void SMAABlendingWeightCalculationVS( vec2 texcoord ) {",
    "	vPixcoord = texcoord / resolution;",
    "	vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );",
    "	vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );",
    "	vOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );",
    "}",
    "void main() {",
    "	vUv = uv;",
    "	SMAABlendingWeightCalculationVS( vUv );",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )",
    "uniform sampler2D tDiffuse;",
    "uniform sampler2D tArea;",
    "uniform sampler2D tSearch;",
    "uniform vec2 resolution;",
    "varying vec2 vUv;",
    "varying vec4 vOffset[3];",
    "varying vec2 vPixcoord;",
    "#if __VERSION__ == 100",
    "vec2 round( vec2 x ) {",
    "	return sign( x ) * floor( abs( x ) + 0.5 );",
    "}",
    "#endif",
    "float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {",
    "	e.r = bias + e.r * scale;",
    "	return 255.0 * texture2D( searchTex, e, 0.0 ).r;",
    "}",
    "float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
    "	vec2 e = vec2( 0.0, 1.0 );",
    "	for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {",
    "		e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
    "		texcoord -= vec2( 2.0, 0.0 ) * resolution;",
    "		if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;",
    "	}",
    "	texcoord.x += 0.25 * resolution.x;",
    "	texcoord.x += resolution.x;",
    "	texcoord.x += 2.0 * resolution.x;",
    "	texcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);",
    "	return texcoord.x;",
    "}",
    "float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
    "	vec2 e = vec2( 0.0, 1.0 );",
    "	for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {",
    "		e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
    "		texcoord += vec2( 2.0, 0.0 ) * resolution;",
    "		if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;",
    "	}",
    "	texcoord.x -= 0.25 * resolution.x;",
    "	texcoord.x -= resolution.x;",
    "	texcoord.x -= 2.0 * resolution.x;",
    "	texcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );",
    "	return texcoord.x;",
    "}",
    "float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
    "	vec2 e = vec2( 1.0, 0.0 );",
    "	for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {",
    "		e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
    "		texcoord += vec2( 0.0, 2.0 ) * resolution;",
    "		if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;",
    "	}",
    "	texcoord.y -= 0.25 * resolution.y;",
    "	texcoord.y -= resolution.y;",
    "	texcoord.y -= 2.0 * resolution.y;",
    "	texcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );",
    "	return texcoord.y;",
    "}",
    "float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
    "	vec2 e = vec2( 1.0, 0.0 );",
    "	for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {",
    "		e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
    "		texcoord -= vec2( 0.0, 2.0 ) * resolution;",
    "		if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;",
    "	}",
    "	texcoord.y += 0.25 * resolution.y;",
    "	texcoord.y += resolution.y;",
    "	texcoord.y += 2.0 * resolution.y;",
    "	texcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );",
    "	return texcoord.y;",
    "}",
    "vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {",
    "	vec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;",
    "	texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );",
    "	texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;",
    "	return texture2D( areaTex, texcoord, 0.0 ).rg;",
    "}",
    "vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {",
    "	vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );",
    "	vec2 e = texture2D( edgesTex, texcoord ).rg;",
    "	if ( e.g > 0.0 ) {",
    "		vec2 d;",
    "		vec2 coords;",
    "		coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );",
    "		coords.y = offset[ 1 ].y;",
    "		d.x = coords.x;",
    "		float e1 = texture2D( edgesTex, coords, 0.0 ).r;",
    "		coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );",
    "		d.y = coords.x;",
    "		d = d / resolution.x - pixcoord.x;",
    "		vec2 sqrt_d = sqrt( abs( d ) );",
    "		coords.y -= 1.0 * resolution.y;",
    "		float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;",
    "		weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );",
    "	}",
    "	if ( e.r > 0.0 ) {",
    "		vec2 d;",
    "		vec2 coords;",
    "		coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );",
    "		coords.x = offset[ 0 ].x;",
    "		d.x = coords.y;",
    "		float e1 = texture2D( edgesTex, coords, 0.0 ).g;",
    "		coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );",
    "		d.y = coords.y;",
    "		d = d / resolution.y - pixcoord.y;",
    "		vec2 sqrt_d = sqrt( abs( d ) );",
    "		coords.y -= 1.0 * resolution.y;",
    "		float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;",
    "		weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );",
    "	}",
    "	return weights;",
    "}",
    "void main() {",
    "	gl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );",
    "}"
  ].join("\n")
};
var SMAABlendShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    tColor: {
      value: null
    },
    resolution: {
      value: new Vector2(1 / 1024, 1 / 512)
    }
  },
  vertexShader: [
    "uniform vec2 resolution;",
    "varying vec2 vUv;",
    "varying vec4 vOffset[ 2 ];",
    "void SMAANeighborhoodBlendingVS( vec2 texcoord ) {",
    "	vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );",
    "	vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );",
    "}",
    "void main() {",
    "	vUv = uv;",
    "	SMAANeighborhoodBlendingVS( vUv );",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform sampler2D tColor;",
    "uniform vec2 resolution;",
    "varying vec2 vUv;",
    "varying vec4 vOffset[ 2 ];",
    "vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {",
    "	vec4 a;",
    "	a.xz = texture2D( blendTex, texcoord ).xz;",
    "	a.y = texture2D( blendTex, offset[ 1 ].zw ).g;",
    "	a.w = texture2D( blendTex, offset[ 1 ].xy ).a;",
    "	if ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {",
    "		return texture2D( colorTex, texcoord, 0.0 );",
    "	} else {",
    "		vec2 offset;",
    "		offset.x = a.a > a.b ? a.a : -a.b;",
    "		offset.y = a.g > a.r ? -a.g : a.r;",
    "		if ( abs( offset.x ) > abs( offset.y )) {",
    "			offset.y = 0.0;",
    "		} else {",
    "			offset.x = 0.0;",
    "		}",
    "		vec4 C = texture2D( colorTex, texcoord, 0.0 );",
    "		texcoord += sign( offset ) * resolution;",
    "		vec4 Cop = texture2D( colorTex, texcoord, 0.0 );",
    "		float s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );",
    "		C.xyz = pow(C.xyz, vec3(2.2));",
    "		Cop.xyz = pow(Cop.xyz, vec3(2.2));",
    "		vec4 mixed = mix(C, Cop, s);",
    "		mixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));",
    "		return mixed;",
    "	}",
    "}",
    "void main() {",
    "	gl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );",
    "}"
  ].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/FilmShader.js
var FilmShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    time: {
      value: 0
    },
    nIntensity: {
      value: 0.5
    },
    sIntensity: {
      value: 0.05
    },
    sCount: {
      value: 4096
    },
    grayscale: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "#include <common>",
    "uniform float time;",
    "uniform bool grayscale;",
    "uniform float nIntensity;",
    "uniform float sIntensity;",
    "uniform float sCount;",
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec4 cTextureScreen = texture2D( tDiffuse, vUv );",
    "	float dx = rand( vUv + time );",
    "	vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );",
    "	vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );",
    "	cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;",
    "	cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );",
    "	if( grayscale ) {",
    "		cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );",
    "	}",
    "	gl_FragColor =  vec4( cResult, cTextureScreen.a );",
    "}"
  ].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/CopyShader.js
var CopyShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    opacity: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 texel = texture2D( tDiffuse, vUv );", "	gl_FragColor = opacity * texel;", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/SSAOShader.js
var SSAOShader = {
  defines: {
    PERSPECTIVE_CAMERA: 1,
    KERNEL_SIZE: 32
  },
  uniforms: {
    tDiffuse: {
      value: null
    },
    tNormal: {
      value: null
    },
    tDepth: {
      value: null
    },
    tNoise: {
      value: null
    },
    kernel: {
      value: null
    },
    cameraNear: {
      value: null
    },
    cameraFar: {
      value: null
    },
    resolution: {
      value: new Vector2()
    },
    cameraProjectionMatrix: {
      value: new Matrix4()
    },
    cameraInverseProjectionMatrix: {
      value: new Matrix4()
    },
    kernelRadius: {
      value: 8
    },
    minDistance: {
      value: 5e-3
    },
    maxDistance: {
      value: 0.05
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform sampler2D tNormal;",
    "uniform sampler2D tDepth;",
    "uniform sampler2D tNoise;",
    "uniform vec3 kernel[ KERNEL_SIZE ];",
    "uniform vec2 resolution;",
    "uniform float cameraNear;",
    "uniform float cameraFar;",
    "uniform mat4 cameraProjectionMatrix;",
    "uniform mat4 cameraInverseProjectionMatrix;",
    "uniform float kernelRadius;",
    "uniform float minDistance;",
    "uniform float maxDistance;",
    "varying vec2 vUv;",
    "#include <packing>",
    "float getDepth( const in vec2 screenPosition ) {",
    "	return texture2D( tDepth, screenPosition ).x;",
    "}",
    "float getLinearDepth( const in vec2 screenPosition ) {",
    "	#if PERSPECTIVE_CAMERA == 1",
    "		float fragCoordZ = texture2D( tDepth, screenPosition ).x;",
    "		float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );",
    "		return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );",
    "	#else",
    "		return texture2D( tDepth, screenPosition ).x;",
    "	#endif",
    "}",
    "float getViewZ( const in float depth ) {",
    "	#if PERSPECTIVE_CAMERA == 1",
    "		return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );",
    "	#else",
    "		return orthographicDepthToViewZ( depth, cameraNear, cameraFar );",
    "	#endif",
    "}",
    "vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {",
    "	float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];",
    "	vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );",
    "	clipPosition *= clipW; // unprojection.",
    "	return ( cameraInverseProjectionMatrix * clipPosition ).xyz;",
    "}",
    "vec3 getViewNormal( const in vec2 screenPosition ) {",
    "	return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );",
    "}",
    "void main() {",
    "	float depth = getDepth( vUv );",
    "	float viewZ = getViewZ( depth );",
    "	vec3 viewPosition = getViewPosition( vUv, depth, viewZ );",
    "	vec3 viewNormal = getViewNormal( vUv );",
    " vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );",
    "	vec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;",
    "	vec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );",
    "	vec3 bitangent = cross( viewNormal, tangent );",
    "	mat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );",
    " float occlusion = 0.0;",
    " for ( int i = 0; i < KERNEL_SIZE; i ++ ) {",
    "		vec3 sampleVector = kernelMatrix * kernel[ i ];",
    "		vec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );",
    "		vec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );",
    "		samplePointNDC /= samplePointNDC.w;",
    "		vec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;",
    "		float realDepth = getLinearDepth( samplePointUv );",
    "		float sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );",
    "		float delta = sampleDepth - realDepth;",
    "		if ( delta > minDistance && delta < maxDistance ) {",
    "			occlusion += 1.0;",
    "		}",
    "	}",
    "	occlusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );",
    "	gl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );",
    "}"
  ].join("\n")
};
var SSAODepthShader = {
  defines: {
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tDepth: {
      value: null
    },
    cameraNear: {
      value: null
    },
    cameraFar: {
      value: null
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDepth;", "uniform float cameraNear;", "uniform float cameraFar;", "varying vec2 vUv;", "#include <packing>", "float getLinearDepth( const in vec2 screenPosition ) {", "	#if PERSPECTIVE_CAMERA == 1", "		float fragCoordZ = texture2D( tDepth, screenPosition ).x;", "		float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );", "		return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );", "	#else", "		return texture2D( tDepth, screenPosition ).x;", "	#endif", "}", "void main() {", "	float depth = getLinearDepth( vUv );", "	gl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );", "}"].join("\n")
};
var SSAOBlurShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    resolution: {
      value: new Vector2()
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform vec2 resolution;", "varying vec2 vUv;", "void main() {", "	vec2 texelSize = ( 1.0 / resolution );", "	float result = 0.0;", "	for ( int i = - 2; i <= 2; i ++ ) {", "		for ( int j = - 2; j <= 2; j ++ ) {", "			vec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;", "			result += texture2D( tDiffuse, vUv + offset ).r;", "		}", "	}", "	gl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/postprocessing/SSAOPass.js
var SSAOPass = class extends Pass2 {
  constructor(scene, camera, width, height) {
    super();
    this.width = width !== void 0 ? width : 512;
    this.height = height !== void 0 ? height : 512;
    this.clear = true;
    this.camera = camera;
    this.scene = scene;
    this.kernelRadius = 8;
    this.kernelSize = 32;
    this.kernel = [];
    this.noiseTexture = null;
    this.output = 0;
    this.minDistance = 5e-3;
    this.maxDistance = 0.1;
    this._visibilityCache = /* @__PURE__ */ new Map();
    this.generateSampleKernel();
    this.generateRandomKernelRotations();
    const depthTexture = new DepthTexture();
    depthTexture.format = DepthStencilFormat;
    depthTexture.type = UnsignedInt248Type;
    this.beautyRenderTarget = new WebGLRenderTarget(this.width, this.height);
    this.normalRenderTarget = new WebGLRenderTarget(this.width, this.height, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      depthTexture
    });
    this.ssaoRenderTarget = new WebGLRenderTarget(this.width, this.height);
    this.blurRenderTarget = this.ssaoRenderTarget.clone();
    if (SSAOShader === void 0) {
      console.error("THREE.SSAOPass: The pass relies on SSAOShader.");
    }
    this.ssaoMaterial = new ShaderMaterial({
      defines: Object.assign({}, SSAOShader.defines),
      uniforms: UniformsUtils.clone(SSAOShader.uniforms),
      vertexShader: SSAOShader.vertexShader,
      fragmentShader: SSAOShader.fragmentShader,
      blending: NoBlending
    });
    this.ssaoMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
    this.ssaoMaterial.uniforms["tNormal"].value = this.normalRenderTarget.texture;
    this.ssaoMaterial.uniforms["tDepth"].value = this.normalRenderTarget.depthTexture;
    this.ssaoMaterial.uniforms["tNoise"].value = this.noiseTexture;
    this.ssaoMaterial.uniforms["kernel"].value = this.kernel;
    this.ssaoMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.ssaoMaterial.uniforms["cameraFar"].value = this.camera.far;
    this.ssaoMaterial.uniforms["resolution"].value.set(this.width, this.height);
    this.ssaoMaterial.uniforms["cameraProjectionMatrix"].value.copy(this.camera.projectionMatrix);
    this.ssaoMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
    this.normalMaterial = new MeshNormalMaterial();
    this.normalMaterial.blending = NoBlending;
    this.blurMaterial = new ShaderMaterial({
      defines: Object.assign({}, SSAOBlurShader.defines),
      uniforms: UniformsUtils.clone(SSAOBlurShader.uniforms),
      vertexShader: SSAOBlurShader.vertexShader,
      fragmentShader: SSAOBlurShader.fragmentShader
    });
    this.blurMaterial.uniforms["tDiffuse"].value = this.ssaoRenderTarget.texture;
    this.blurMaterial.uniforms["resolution"].value.set(this.width, this.height);
    this.depthRenderMaterial = new ShaderMaterial({
      defines: Object.assign({}, SSAODepthShader.defines),
      uniforms: UniformsUtils.clone(SSAODepthShader.uniforms),
      vertexShader: SSAODepthShader.vertexShader,
      fragmentShader: SSAODepthShader.fragmentShader,
      blending: NoBlending
    });
    this.depthRenderMaterial.uniforms["tDepth"].value = this.normalRenderTarget.depthTexture;
    this.depthRenderMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.depthRenderMaterial.uniforms["cameraFar"].value = this.camera.far;
    this.copyMaterial = new ShaderMaterial({
      uniforms: UniformsUtils.clone(CopyShader.uniforms),
      vertexShader: CopyShader.vertexShader,
      fragmentShader: CopyShader.fragmentShader,
      transparent: true,
      depthTest: false,
      depthWrite: false,
      blendSrc: DstColorFactor,
      blendDst: ZeroFactor,
      blendEquation: AddEquation,
      blendSrcAlpha: DstAlphaFactor,
      blendDstAlpha: ZeroFactor,
      blendEquationAlpha: AddEquation
    });
    this.fsQuad = new FullScreenQuad(null);
    this.originalClearColor = new Color();
  }
  dispose() {
    this.beautyRenderTarget.dispose();
    this.normalRenderTarget.dispose();
    this.ssaoRenderTarget.dispose();
    this.blurRenderTarget.dispose();
    this.normalMaterial.dispose();
    this.blurMaterial.dispose();
    this.copyMaterial.dispose();
    this.depthRenderMaterial.dispose();
    this.fsQuad.dispose();
  }
  render(renderer, writeBuffer) {
    if (renderer.capabilities.isWebGL2 === false)
      this.noiseTexture.format = LuminanceFormat;
    renderer.setRenderTarget(this.beautyRenderTarget);
    renderer.clear();
    renderer.render(this.scene, this.camera);
    this.overrideVisibility();
    this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 7829503, 1);
    this.restoreVisibility();
    this.ssaoMaterial.uniforms["kernelRadius"].value = this.kernelRadius;
    this.ssaoMaterial.uniforms["minDistance"].value = this.minDistance;
    this.ssaoMaterial.uniforms["maxDistance"].value = this.maxDistance;
    this.renderPass(renderer, this.ssaoMaterial, this.ssaoRenderTarget);
    this.renderPass(renderer, this.blurMaterial, this.blurRenderTarget);
    switch (this.output) {
      case SSAOPass.OUTPUT.SSAO:
        this.copyMaterial.uniforms["tDiffuse"].value = this.ssaoRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSAOPass.OUTPUT.Blur:
        this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSAOPass.OUTPUT.Beauty:
        this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSAOPass.OUTPUT.Depth:
        this.renderPass(renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSAOPass.OUTPUT.Normal:
        this.copyMaterial.uniforms["tDiffuse"].value = this.normalRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSAOPass.OUTPUT.Default:
        this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget.texture;
        this.copyMaterial.blending = CustomBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      default:
        console.warn("THREE.SSAOPass: Unknown output type.");
    }
  }
  renderPass(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {
    renderer.getClearColor(this.originalClearColor);
    const originalClearAlpha = renderer.getClearAlpha();
    const originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.fsQuad.material = passMaterial;
    this.fsQuad.render(renderer);
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  }
  renderOverride(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {
    renderer.getClearColor(this.originalClearColor);
    const originalClearAlpha = renderer.getClearAlpha();
    const originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    clearColor = overrideMaterial.clearColor || clearColor;
    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.scene.overrideMaterial = overrideMaterial;
    renderer.render(this.scene, this.camera);
    this.scene.overrideMaterial = null;
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  }
  setSize(width, height) {
    this.width = width;
    this.height = height;
    this.beautyRenderTarget.setSize(width, height);
    this.ssaoRenderTarget.setSize(width, height);
    this.normalRenderTarget.setSize(width, height);
    this.blurRenderTarget.setSize(width, height);
    this.ssaoMaterial.uniforms["resolution"].value.set(width, height);
    this.ssaoMaterial.uniforms["cameraProjectionMatrix"].value.copy(this.camera.projectionMatrix);
    this.ssaoMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
    this.blurMaterial.uniforms["resolution"].value.set(width, height);
  }
  generateSampleKernel() {
    const kernelSize = this.kernelSize;
    const kernel = this.kernel;
    for (let i2 = 0; i2 < kernelSize; i2++) {
      const sample = new Vector3();
      sample.x = Math.random() * 2 - 1;
      sample.y = Math.random() * 2 - 1;
      sample.z = Math.random();
      sample.normalize();
      let scale = i2 / kernelSize;
      scale = MathUtils.lerp(0.1, 1, scale * scale);
      sample.multiplyScalar(scale);
      kernel.push(sample);
    }
  }
  generateRandomKernelRotations() {
    const width = 4, height = 4;
    if (SimplexNoise === void 0) {
      console.error("THREE.SSAOPass: The pass relies on SimplexNoise.");
    }
    const simplex = new SimplexNoise();
    const size2 = width * height;
    const data = new Float32Array(size2);
    for (let i2 = 0; i2 < size2; i2++) {
      const x = Math.random() * 2 - 1;
      const y = Math.random() * 2 - 1;
      const z = 0;
      data[i2] = simplex.noise3d(x, y, z);
    }
    this.noiseTexture = new DataTexture(data, width, height, RedFormat, FloatType);
    this.noiseTexture.wrapS = RepeatWrapping;
    this.noiseTexture.wrapT = RepeatWrapping;
    this.noiseTexture.needsUpdate = true;
  }
  overrideVisibility() {
    const scene = this.scene;
    const cache = this._visibilityCache;
    scene.traverse(function(object) {
      cache.set(object, object.visible);
      if (object.isPoints || object.isLine)
        object.visible = false;
    });
  }
  restoreVisibility() {
    const scene = this.scene;
    const cache = this._visibilityCache;
    scene.traverse(function(object) {
      const visible = cache.get(object);
      object.visible = visible;
    });
    cache.clear();
  }
};
SSAOPass.OUTPUT = {
  Default: 0,
  SSAO: 1,
  Blur: 2,
  Beauty: 3,
  Depth: 4,
  Normal: 5
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/BokehShader.js
var BokehShader = {
  defines: {
    DEPTH_PACKING: 1,
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tColor: {
      value: null
    },
    tDepth: {
      value: null
    },
    focus: {
      value: 1
    },
    aspect: {
      value: 1
    },
    aperture: {
      value: 0.025
    },
    maxblur: {
      value: 0.01
    },
    nearClip: {
      value: 1
    },
    farClip: {
      value: 1e3
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "#include <common>",
    "varying vec2 vUv;",
    "uniform sampler2D tColor;",
    "uniform sampler2D tDepth;",
    "uniform float maxblur;",
    "uniform float aperture;",
    "uniform float nearClip;",
    "uniform float farClip;",
    "uniform float focus;",
    "uniform float aspect;",
    "#include <packing>",
    "float getDepth( const in vec2 screenPosition ) {",
    "	#if DEPTH_PACKING == 1",
    "	return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );",
    "	#else",
    "	return texture2D( tDepth, screenPosition ).x;",
    "	#endif",
    "}",
    "float getViewZ( const in float depth ) {",
    "	#if PERSPECTIVE_CAMERA == 1",
    "	return perspectiveDepthToViewZ( depth, nearClip, farClip );",
    "	#else",
    "	return orthographicDepthToViewZ( depth, nearClip, farClip );",
    "	#endif",
    "}",
    "void main() {",
    "	vec2 aspectcorrect = vec2( 1.0, aspect );",
    "	float viewZ = getViewZ( getDepth( vUv ) );",
    "	float factor = ( focus + viewZ );",
    "	vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );",
    "	vec2 dofblur9 = dofblur * 0.9;",
    "	vec2 dofblur7 = dofblur * 0.7;",
    "	vec2 dofblur4 = dofblur * 0.4;",
    "	vec4 col = vec4( 0.0 );",
    "	col += texture2D( tColor, vUv.xy );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );",
    "	gl_FragColor = col / 41.0;",
    "	gl_FragColor.a = 1.0;",
    "}"
  ].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/postprocessing/TexturePass.js
var TexturePass = function(map, opacity) {
  if (CopyShader === void 0)
    console.error("THREE.TexturePass relies on CopyShader");
  var shader = CopyShader;
  this.map = map;
  this.opacity = opacity !== void 0 ? opacity : 1;
  this.uniforms = UniformsUtils.clone(shader.uniforms);
  this.material = new ShaderMaterial({
    uniforms: this.uniforms,
    vertexShader: shader.vertexShader,
    fragmentShader: shader.fragmentShader,
    depthTest: false,
    depthWrite: false
  });
  this.needsSwap = false;
  this.fsQuad = new FullScreenQuad(null);
};
TexturePass.prototype = Object.assign(Object.create(Pass2.prototype), {
  constructor: TexturePass,
  render: function(renderer, writeBuffer, readBuffer) {
    var oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    this.fsQuad.material = this.material;
    this.uniforms["opacity"].value = this.opacity;
    this.uniforms["tDiffuse"].value = this.map;
    this.material.transparent = this.opacity < 1;
    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
    if (this.clear)
      renderer.clear();
    this.fsQuad.render(renderer);
    renderer.autoClear = oldAutoClear;
  }
});

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/LuminosityShader.js
var LuminosityShader = {
  uniforms: {
    tDiffuse: {
      value: null
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["#include <common>", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 texel = texture2D( tDiffuse, vUv );", "	float l = linearToRelativeLuminance( texel.rgb );", "	gl_FragColor = vec4( l, l, l, texel.w );", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/ToneMapShader.js
var ToneMapShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    averageLuminance: {
      value: 1
    },
    luminanceMap: {
      value: null
    },
    maxLuminance: {
      value: 16
    },
    minLuminance: {
      value: 0.01
    },
    middleGrey: {
      value: 0.6
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "#include <common>",
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "uniform float middleGrey;",
    "uniform float minLuminance;",
    "uniform float maxLuminance;",
    "#ifdef ADAPTED_LUMINANCE",
    "	uniform sampler2D luminanceMap;",
    "#else",
    "	uniform float averageLuminance;",
    "#endif",
    "vec3 ToneMap( vec3 vColor ) {",
    "	#ifdef ADAPTED_LUMINANCE",
    "		float fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;",
    "	#else",
    "		float fLumAvg = averageLuminance;",
    "	#endif",
    "	float fLumPixel = linearToRelativeLuminance( vColor );",
    "	float fLumScaled = (fLumPixel * middleGrey) / max( minLuminance, fLumAvg );",
    "	float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);",
    "	return fLumCompressed * vColor;",
    "}",
    "void main() {",
    "	vec4 texel = texture2D( tDiffuse, vUv );",
    "	gl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );",
    "}"
  ].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/postprocessing/AdaptiveToneMappingPass.js
var AdaptiveToneMappingPass = function(adaptive, resolution) {
  this.resolution = resolution !== void 0 ? resolution : 256;
  this.needsInit = true;
  this.adaptive = adaptive !== void 0 ? !!adaptive : true;
  this.luminanceRT = null;
  this.previousLuminanceRT = null;
  this.currentLuminanceRT = null;
  if (CopyShader === void 0)
    console.error("THREE.AdaptiveToneMappingPass relies on CopyShader");
  var copyShader = CopyShader;
  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);
  this.materialCopy = new ShaderMaterial({
    uniforms: this.copyUniforms,
    vertexShader: copyShader.vertexShader,
    fragmentShader: copyShader.fragmentShader,
    blending: NoBlending,
    depthTest: false
  });
  if (LuminosityShader === void 0)
    console.error("THREE.AdaptiveToneMappingPass relies on LuminosityShader");
  this.materialLuminance = new ShaderMaterial({
    uniforms: UniformsUtils.clone(LuminosityShader.uniforms),
    vertexShader: LuminosityShader.vertexShader,
    fragmentShader: LuminosityShader.fragmentShader,
    blending: NoBlending
  });
  this.adaptLuminanceShader = {
    defines: {
      MIP_LEVEL_1X1: (Math.log(this.resolution) / Math.log(2)).toFixed(1)
    },
    uniforms: {
      lastLum: {
        value: null
      },
      currentLum: {
        value: null
      },
      minLuminance: {
        value: 0.01
      },
      delta: {
        value: 0.016
      },
      tau: {
        value: 1
      }
    },
    vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: [
      "varying vec2 vUv;",
      "uniform sampler2D lastLum;",
      "uniform sampler2D currentLum;",
      "uniform float minLuminance;",
      "uniform float delta;",
      "uniform float tau;",
      "void main() {",
      "	vec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );",
      "	vec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );",
      "	float fLastLum = max( minLuminance, lastLum.r );",
      "	float fCurrentLum = max( minLuminance, currentLum.r );",
      "	fCurrentLum *= fCurrentLum;",
      "	float fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));",
      "	gl_FragColor.r = fAdaptedLum;",
      "}"
    ].join("\n")
  };
  this.materialAdaptiveLum = new ShaderMaterial({
    uniforms: UniformsUtils.clone(this.adaptLuminanceShader.uniforms),
    vertexShader: this.adaptLuminanceShader.vertexShader,
    fragmentShader: this.adaptLuminanceShader.fragmentShader,
    defines: Object.assign({}, this.adaptLuminanceShader.defines),
    blending: NoBlending
  });
  if (ToneMapShader === void 0)
    console.error("THREE.AdaptiveToneMappingPass relies on ToneMapShader");
  this.materialToneMap = new ShaderMaterial({
    uniforms: UniformsUtils.clone(ToneMapShader.uniforms),
    vertexShader: ToneMapShader.vertexShader,
    fragmentShader: ToneMapShader.fragmentShader,
    blending: NoBlending
  });
  this.fsQuad = new FullScreenQuad(null);
};
AdaptiveToneMappingPass.prototype = Object.assign(Object.create(Pass2.prototype), {
  constructor: AdaptiveToneMappingPass,
  render: function(renderer, writeBuffer, readBuffer, deltaTime) {
    if (this.needsInit) {
      this.reset(renderer);
      this.luminanceRT.texture.type = readBuffer.texture.type;
      this.previousLuminanceRT.texture.type = readBuffer.texture.type;
      this.currentLuminanceRT.texture.type = readBuffer.texture.type;
      this.needsInit = false;
    }
    if (this.adaptive) {
      this.fsQuad.material = this.materialLuminance;
      this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;
      renderer.setRenderTarget(this.currentLuminanceRT);
      this.fsQuad.render(renderer);
      this.fsQuad.material = this.materialAdaptiveLum;
      this.materialAdaptiveLum.uniforms.delta.value = deltaTime;
      this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;
      this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;
      renderer.setRenderTarget(this.luminanceRT);
      this.fsQuad.render(renderer);
      this.fsQuad.material = this.materialCopy;
      this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;
      renderer.setRenderTarget(this.previousLuminanceRT);
      this.fsQuad.render(renderer);
    }
    this.fsQuad.material = this.materialToneMap;
    this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear)
        renderer.clear();
      this.fsQuad.render(renderer);
    }
  },
  reset: function() {
    if (this.luminanceRT) {
      this.luminanceRT.dispose();
    }
    if (this.currentLuminanceRT) {
      this.currentLuminanceRT.dispose();
    }
    if (this.previousLuminanceRT) {
      this.previousLuminanceRT.dispose();
    }
    var pars = {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBAFormat
    };
    this.luminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);
    this.luminanceRT.texture.name = "AdaptiveToneMappingPass.l";
    this.luminanceRT.texture.generateMipmaps = false;
    this.previousLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);
    this.previousLuminanceRT.texture.name = "AdaptiveToneMappingPass.pl";
    this.previousLuminanceRT.texture.generateMipmaps = false;
    pars.minFilter = LinearMipmapLinearFilter;
    pars.generateMipmaps = true;
    this.currentLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);
    this.currentLuminanceRT.texture.name = "AdaptiveToneMappingPass.cl";
    if (this.adaptive) {
      this.materialToneMap.defines["ADAPTED_LUMINANCE"] = "";
      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;
    }
    this.fsQuad.material = new MeshBasicMaterial({
      color: 7829367
    });
    this.materialLuminance.needsUpdate = true;
    this.materialAdaptiveLum.needsUpdate = true;
    this.materialToneMap.needsUpdate = true;
  },
  setAdaptive: function(adaptive) {
    if (adaptive) {
      this.adaptive = true;
      this.materialToneMap.defines["ADAPTED_LUMINANCE"] = "";
      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;
    } else {
      this.adaptive = false;
      delete this.materialToneMap.defines["ADAPTED_LUMINANCE"];
      this.materialToneMap.uniforms.luminanceMap.value = null;
    }
    this.materialToneMap.needsUpdate = true;
  },
  setAdaptionRate: function(rate) {
    if (rate) {
      this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);
    }
  },
  setMinLuminance: function(minLum) {
    if (minLum) {
      this.materialToneMap.uniforms.minLuminance.value = minLum;
      this.materialAdaptiveLum.uniforms.minLuminance.value = minLum;
    }
  },
  setMaxLuminance: function(maxLum) {
    if (maxLum) {
      this.materialToneMap.uniforms.maxLuminance.value = maxLum;
    }
  },
  setAverageLuminance: function(avgLum) {
    if (avgLum) {
      this.materialToneMap.uniforms.averageLuminance.value = avgLum;
    }
  },
  setMiddleGrey: function(middleGrey) {
    if (middleGrey) {
      this.materialToneMap.uniforms.middleGrey.value = middleGrey;
    }
  },
  dispose: function() {
    if (this.luminanceRT) {
      this.luminanceRT.dispose();
    }
    if (this.previousLuminanceRT) {
      this.previousLuminanceRT.dispose();
    }
    if (this.currentLuminanceRT) {
      this.currentLuminanceRT.dispose();
    }
    if (this.materialLuminance) {
      this.materialLuminance.dispose();
    }
    if (this.materialAdaptiveLum) {
      this.materialAdaptiveLum.dispose();
    }
    if (this.materialCopy) {
      this.materialCopy.dispose();
    }
    if (this.materialToneMap) {
      this.materialToneMap.dispose();
    }
  }
});

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/LuminosityHighPassShader.js
var LuminosityHighPassShader = {
  shaderID: "luminosityHighPass",
  uniforms: {
    tDiffuse: {
      value: null
    },
    luminosityThreshold: {
      value: 1
    },
    smoothWidth: {
      value: 1
    },
    defaultColor: {
      value: new Color(0)
    },
    defaultOpacity: {
      value: 0
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform vec3 defaultColor;", "uniform float defaultOpacity;", "uniform float luminosityThreshold;", "uniform float smoothWidth;", "varying vec2 vUv;", "void main() {", "	vec4 texel = texture2D( tDiffuse, vUv );", "	vec3 luma = vec3( 0.299, 0.587, 0.114 );", "	float v = dot( texel.xyz, luma );", "	vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );", "	float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );", "	gl_FragColor = mix( outputColor, texel, alpha );", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/postprocessing/UnrealBloomPass.js
var UnrealBloomPass = function(resolution, strength, radius, threshold) {
  this.strength = strength !== void 0 ? strength : 1;
  this.radius = radius;
  this.threshold = threshold;
  this.resolution = resolution !== void 0 ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);
  this.clearColor = new Color(0, 0, 0);
  var pars = {
    minFilter: LinearFilter,
    magFilter: LinearFilter,
    format: RGBAFormat
  };
  this.renderTargetsHorizontal = [];
  this.renderTargetsVertical = [];
  this.nMips = 5;
  var resx = Math.round(this.resolution.x / 2);
  var resy = Math.round(this.resolution.y / 2);
  this.renderTargetBright = new WebGLRenderTarget(resx, resy, pars);
  this.renderTargetBright.texture.name = "UnrealBloomPass.bright";
  this.renderTargetBright.texture.generateMipmaps = false;
  for (let i2 = 0; i2 < this.nMips; i2++) {
    var renderTargetHorizonal = new WebGLRenderTarget(resx, resy, pars);
    renderTargetHorizonal.texture.name = "UnrealBloomPass.h" + i2;
    renderTargetHorizonal.texture.generateMipmaps = false;
    this.renderTargetsHorizontal.push(renderTargetHorizonal);
    var renderTargetVertical = new WebGLRenderTarget(resx, resy, pars);
    renderTargetVertical.texture.name = "UnrealBloomPass.v" + i2;
    renderTargetVertical.texture.generateMipmaps = false;
    this.renderTargetsVertical.push(renderTargetVertical);
    resx = Math.round(resx / 2);
    resy = Math.round(resy / 2);
  }
  if (LuminosityHighPassShader === void 0)
    console.error("THREE.UnrealBloomPass relies on LuminosityHighPassShader");
  var highPassShader = LuminosityHighPassShader;
  this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);
  this.highPassUniforms["luminosityThreshold"].value = threshold;
  this.highPassUniforms["smoothWidth"].value = 0.01;
  this.materialHighPassFilter = new ShaderMaterial({
    uniforms: this.highPassUniforms,
    vertexShader: highPassShader.vertexShader,
    fragmentShader: highPassShader.fragmentShader,
    defines: {}
  });
  this.separableBlurMaterials = [];
  var kernelSizeArray = [3, 5, 7, 9, 11];
  var resx = Math.round(this.resolution.x / 2);
  var resy = Math.round(this.resolution.y / 2);
  for (let i2 = 0; i2 < this.nMips; i2++) {
    this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i2]));
    this.separableBlurMaterials[i2].uniforms["texSize"].value = new Vector2(resx, resy);
    resx = Math.round(resx / 2);
    resy = Math.round(resy / 2);
  }
  this.compositeMaterial = this.getCompositeMaterial(this.nMips);
  this.compositeMaterial.uniforms["blurTexture1"].value = this.renderTargetsVertical[0].texture;
  this.compositeMaterial.uniforms["blurTexture2"].value = this.renderTargetsVertical[1].texture;
  this.compositeMaterial.uniforms["blurTexture3"].value = this.renderTargetsVertical[2].texture;
  this.compositeMaterial.uniforms["blurTexture4"].value = this.renderTargetsVertical[3].texture;
  this.compositeMaterial.uniforms["blurTexture5"].value = this.renderTargetsVertical[4].texture;
  this.compositeMaterial.uniforms["bloomStrength"].value = strength;
  this.compositeMaterial.uniforms["bloomRadius"].value = 0.1;
  this.compositeMaterial.needsUpdate = true;
  var bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];
  this.compositeMaterial.uniforms["bloomFactors"].value = bloomFactors;
  this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];
  this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;
  if (CopyShader === void 0) {
    console.error("THREE.UnrealBloomPass relies on CopyShader");
  }
  var copyShader = CopyShader;
  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);
  this.copyUniforms["opacity"].value = 1;
  this.materialCopy = new ShaderMaterial({
    uniforms: this.copyUniforms,
    vertexShader: copyShader.vertexShader,
    fragmentShader: copyShader.fragmentShader,
    blending: AdditiveBlending,
    depthTest: false,
    depthWrite: false,
    transparent: true
  });
  this.enabled = true;
  this.needsSwap = false;
  this._oldClearColor = new Color();
  this.oldClearAlpha = 1;
  this.basic = new MeshBasicMaterial();
  this.fsQuad = new FullScreenQuad(null);
};
UnrealBloomPass.prototype = Object.assign(Object.create(Pass2.prototype), {
  constructor: UnrealBloomPass,
  dispose: function() {
    for (let i2 = 0; i2 < this.renderTargetsHorizontal.length; i2++) {
      this.renderTargetsHorizontal[i2].dispose();
    }
    for (let i2 = 0; i2 < this.renderTargetsVertical.length; i2++) {
      this.renderTargetsVertical[i2].dispose();
    }
    this.renderTargetBright.dispose();
  },
  setSize: function(width, height) {
    var resx = Math.round(width / 2);
    var resy = Math.round(height / 2);
    this.renderTargetBright.setSize(resx, resy);
    for (let i2 = 0; i2 < this.nMips; i2++) {
      this.renderTargetsHorizontal[i2].setSize(resx, resy);
      this.renderTargetsVertical[i2].setSize(resx, resy);
      this.separableBlurMaterials[i2].uniforms["texSize"].value = new Vector2(resx, resy);
      resx = Math.round(resx / 2);
      resy = Math.round(resy / 2);
    }
  },
  render: function(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    renderer.getClearColor(this._oldClearColor);
    this.oldClearAlpha = renderer.getClearAlpha();
    var oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    renderer.setClearColor(this.clearColor, 0);
    if (maskActive)
      renderer.state.buffers.stencil.setTest(false);
    if (this.renderToScreen) {
      this.fsQuad.material = this.basic;
      this.basic.map = readBuffer.texture;
      renderer.setRenderTarget(null);
      renderer.clear();
      this.fsQuad.render(renderer);
    }
    this.highPassUniforms["tDiffuse"].value = readBuffer.texture;
    this.highPassUniforms["luminosityThreshold"].value = this.threshold;
    this.fsQuad.material = this.materialHighPassFilter;
    renderer.setRenderTarget(this.renderTargetBright);
    renderer.clear();
    this.fsQuad.render(renderer);
    var inputRenderTarget = this.renderTargetBright;
    for (let i2 = 0; i2 < this.nMips; i2++) {
      this.fsQuad.material = this.separableBlurMaterials[i2];
      this.separableBlurMaterials[i2].uniforms["colorTexture"].value = inputRenderTarget.texture;
      this.separableBlurMaterials[i2].uniforms["direction"].value = UnrealBloomPass.BlurDirectionX;
      renderer.setRenderTarget(this.renderTargetsHorizontal[i2]);
      renderer.clear();
      this.fsQuad.render(renderer);
      this.separableBlurMaterials[i2].uniforms["colorTexture"].value = this.renderTargetsHorizontal[i2].texture;
      this.separableBlurMaterials[i2].uniforms["direction"].value = UnrealBloomPass.BlurDirectionY;
      renderer.setRenderTarget(this.renderTargetsVertical[i2]);
      renderer.clear();
      this.fsQuad.render(renderer);
      inputRenderTarget = this.renderTargetsVertical[i2];
    }
    this.fsQuad.material = this.compositeMaterial;
    this.compositeMaterial.uniforms["bloomStrength"].value = this.strength;
    this.compositeMaterial.uniforms["bloomRadius"].value = this.radius;
    this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;
    renderer.setRenderTarget(this.renderTargetsHorizontal[0]);
    renderer.clear();
    this.fsQuad.render(renderer);
    this.fsQuad.material = this.materialCopy;
    this.copyUniforms["tDiffuse"].value = this.renderTargetsHorizontal[0].texture;
    if (maskActive)
      renderer.state.buffers.stencil.setTest(true);
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(readBuffer);
      this.fsQuad.render(renderer);
    }
    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);
    renderer.autoClear = oldAutoClear;
  },
  getSeperableBlurMaterial: function(kernelRadius) {
    return new ShaderMaterial({
      defines: {
        KERNEL_RADIUS: kernelRadius,
        SIGMA: kernelRadius
      },
      uniforms: {
        colorTexture: {
          value: null
        },
        texSize: {
          value: new Vector2(0.5, 0.5)
        },
        direction: {
          value: new Vector2(0.5, 0.5)
        }
      },
      vertexShader: "varying vec2 vUv;\nvoid main() {\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
      fragmentShader: "#include <common>varying vec2 vUv;\nuniform sampler2D colorTexture;\nuniform vec2 texSize;uniform vec2 direction;\nfloat gaussianPdf(in float x, in float sigma) {	return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;}void main() {\n	vec2 invSize = 1.0 / texSize;	float fSigma = float(SIGMA);	float weightSum = gaussianPdf(0.0, fSigma);	vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;	for( int i = 1; i < KERNEL_RADIUS; i ++ ) {		float x = float(i);		float w = gaussianPdf(x, fSigma);		vec2 uvOffset = direction * invSize * x;		vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;		vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;		diffuseSum += (sample1 + sample2) * w;		weightSum += 2.0 * w;	}	gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n}"
    });
  },
  getCompositeMaterial: function(nMips) {
    return new ShaderMaterial({
      defines: {
        NUM_MIPS: nMips
      },
      uniforms: {
        blurTexture1: {
          value: null
        },
        blurTexture2: {
          value: null
        },
        blurTexture3: {
          value: null
        },
        blurTexture4: {
          value: null
        },
        blurTexture5: {
          value: null
        },
        dirtTexture: {
          value: null
        },
        bloomStrength: {
          value: 1
        },
        bloomFactors: {
          value: null
        },
        bloomTintColors: {
          value: null
        },
        bloomRadius: {
          value: 0
        }
      },
      vertexShader: "varying vec2 vUv;\nvoid main() {\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
      fragmentShader: "varying vec2 vUv;uniform sampler2D blurTexture1;uniform sampler2D blurTexture2;uniform sampler2D blurTexture3;uniform sampler2D blurTexture4;uniform sampler2D blurTexture5;uniform sampler2D dirtTexture;uniform float bloomStrength;uniform float bloomRadius;uniform float bloomFactors[NUM_MIPS];uniform vec3 bloomTintColors[NUM_MIPS];float lerpBloomFactor(const in float factor) { 	float mirrorFactor = 1.2 - factor;	return mix(factor, mirrorFactor, bloomRadius);}void main() {	gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + 									 lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + 									 lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + 									 lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + 									 lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );}"
    });
  }
});
UnrealBloomPass.BlurDirectionX = new Vector2(1, 0);
UnrealBloomPass.BlurDirectionY = new Vector2(0, 1);

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/postprocessing/CubeTexturePass.js
var CubeTexturePass = function(camera, envMap, opacity) {
  this.camera = camera;
  this.needsSwap = false;
  this.cubeShader = ShaderLib["cube"];
  this.cubeMesh = new Mesh(new BoxGeometry(10, 10, 10), new ShaderMaterial({
    uniforms: UniformsUtils.clone(this.cubeShader.uniforms),
    vertexShader: this.cubeShader.vertexShader,
    fragmentShader: this.cubeShader.fragmentShader,
    depthTest: false,
    depthWrite: false,
    side: BackSide
  }));
  Object.defineProperty(this.cubeMesh.material, "envMap", {
    get: function() {
      return this.uniforms.envMap.value;
    }
  });
  this.envMap = envMap;
  this.opacity = opacity !== void 0 ? opacity : 1;
  this.cubeScene = new Scene();
  this.cubeCamera = new PerspectiveCamera();
  this.cubeScene.add(this.cubeMesh);
};
CubeTexturePass.prototype = Object.assign(Object.create(Pass2.prototype), {
  constructor: CubeTexturePass,
  render: function(renderer, writeBuffer, readBuffer) {
    var oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    this.cubeCamera.projectionMatrix.copy(this.camera.projectionMatrix);
    this.cubeCamera.quaternion.setFromRotationMatrix(this.camera.matrixWorld);
    this.cubeMesh.material.uniforms.envMap.value = this.envMap;
    this.cubeMesh.material.uniforms.flipEnvMap.value = this.envMap.isCubeTexture && this.envMap._needsFlipEnvMap ? -1 : 1;
    this.cubeMesh.material.uniforms.opacity.value = this.opacity;
    this.cubeMesh.material.transparent = this.opacity < 1;
    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
    if (this.clear)
      renderer.clear();
    renderer.render(this.cubeScene, this.cubeCamera);
    renderer.autoClear = oldAutoClear;
  }
});

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/SAOShader.js
var SAOShader = {
  defines: {
    NUM_SAMPLES: 7,
    NUM_RINGS: 4,
    NORMAL_TEXTURE: 0,
    DIFFUSE_TEXTURE: 0,
    DEPTH_PACKING: 1,
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tDepth: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    tNormal: {
      value: null
    },
    size: {
      value: new Vector2(512, 512)
    },
    cameraNear: {
      value: 1
    },
    cameraFar: {
      value: 100
    },
    cameraProjectionMatrix: {
      value: new Matrix4()
    },
    cameraInverseProjectionMatrix: {
      value: new Matrix4()
    },
    scale: {
      value: 1
    },
    intensity: {
      value: 0.1
    },
    bias: {
      value: 0.5
    },
    minResolution: {
      value: 0
    },
    kernelRadius: {
      value: 100
    },
    randomSeed: {
      value: 0
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["#include <common>", "varying vec2 vUv;", "#if DIFFUSE_TEXTURE == 1", "uniform sampler2D tDiffuse;", "#endif", "uniform sampler2D tDepth;", "#if NORMAL_TEXTURE == 1", "uniform sampler2D tNormal;", "#endif", "uniform float cameraNear;", "uniform float cameraFar;", "uniform mat4 cameraProjectionMatrix;", "uniform mat4 cameraInverseProjectionMatrix;", "uniform float scale;", "uniform float intensity;", "uniform float bias;", "uniform float kernelRadius;", "uniform float minResolution;", "uniform vec2 size;", "uniform float randomSeed;", "// RGBA depth", "#include <packing>", "vec4 getDefaultColor( const in vec2 screenPosition ) {", "	#if DIFFUSE_TEXTURE == 1", "	return texture2D( tDiffuse, vUv );", "	#else", "	return vec4( 1.0 );", "	#endif", "}", "float getDepth( const in vec2 screenPosition ) {", "	#if DEPTH_PACKING == 1", "	return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );", "	#else", "	return texture2D( tDepth, screenPosition ).x;", "	#endif", "}", "float getViewZ( const in float depth ) {", "	#if PERSPECTIVE_CAMERA == 1", "	return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );", "	#else", "	return orthographicDepthToViewZ( depth, cameraNear, cameraFar );", "	#endif", "}", "vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {", "	float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];", "	vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );", "	clipPosition *= clipW; // unprojection.", "	return ( cameraInverseProjectionMatrix * clipPosition ).xyz;", "}", "vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {", "	#if NORMAL_TEXTURE == 1", "	return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );", "	#else", "	return normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );", "	#endif", "}", "float scaleDividedByCameraFar;", "float minResolutionMultipliedByCameraFar;", "float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {", "	vec3 viewDelta = sampleViewPosition - centerViewPosition;", "	float viewDistance = length( viewDelta );", "	float scaledScreenDistance = scaleDividedByCameraFar * viewDistance;", "	return max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );", "}", "// moving costly divides into consts", "const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );", "const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );", "float getAmbientOcclusion( const in vec3 centerViewPosition ) {", "	// precompute some variables require in getOcclusion.", "	scaleDividedByCameraFar = scale / cameraFar;", "	minResolutionMultipliedByCameraFar = minResolution * cameraFar;", "	vec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );", "	// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/", "	float angle = rand( vUv + randomSeed ) * PI2;", "	vec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;", "	vec2 radiusStep = radius;", "	float occlusionSum = 0.0;", "	float weightSum = 0.0;", "	for( int i = 0; i < NUM_SAMPLES; i ++ ) {", "		vec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;", "		radius += radiusStep;", "		angle += ANGLE_STEP;", "		float sampleDepth = getDepth( sampleUv );", "		if( sampleDepth >= ( 1.0 - EPSILON ) ) {", "			continue;", "		}", "		float sampleViewZ = getViewZ( sampleDepth );", "		vec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );", "		occlusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );", "		weightSum += 1.0;", "	}", "	if( weightSum == 0.0 ) discard;", "	return occlusionSum * ( intensity / weightSum );", "}", "void main() {", "	float centerDepth = getDepth( vUv );", "	if( centerDepth >= ( 1.0 - EPSILON ) ) {", "		discard;", "	}", "	float centerViewZ = getViewZ( centerDepth );", "	vec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );", "	float ambientOcclusion = getAmbientOcclusion( viewPosition );", "	gl_FragColor = getDefaultColor( vUv );", "	gl_FragColor.xyz *=  1.0 - ambientOcclusion;", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/DepthLimitedBlurShader.js
var DepthLimitedBlurShader = {
  defines: {
    KERNEL_RADIUS: 4,
    DEPTH_PACKING: 1,
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tDiffuse: {
      value: null
    },
    size: {
      value: new Vector2(512, 512)
    },
    sampleUvOffsets: {
      value: [new Vector2(0, 0)]
    },
    sampleWeights: {
      value: [1]
    },
    tDepth: {
      value: null
    },
    cameraNear: {
      value: 10
    },
    cameraFar: {
      value: 1e3
    },
    depthCutoff: {
      value: 10
    }
  },
  vertexShader: ["#include <common>", "uniform vec2 size;", "varying vec2 vUv;", "varying vec2 vInvSize;", "void main() {", "	vUv = uv;", "	vInvSize = 1.0 / size;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["#include <common>", "#include <packing>", "uniform sampler2D tDiffuse;", "uniform sampler2D tDepth;", "uniform float cameraNear;", "uniform float cameraFar;", "uniform float depthCutoff;", "uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];", "uniform float sampleWeights[ KERNEL_RADIUS + 1 ];", "varying vec2 vUv;", "varying vec2 vInvSize;", "float getDepth( const in vec2 screenPosition ) {", "	#if DEPTH_PACKING == 1", "	return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );", "	#else", "	return texture2D( tDepth, screenPosition ).x;", "	#endif", "}", "float getViewZ( const in float depth ) {", "	#if PERSPECTIVE_CAMERA == 1", "	return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );", "	#else", "	return orthographicDepthToViewZ( depth, cameraNear, cameraFar );", "	#endif", "}", "void main() {", "	float depth = getDepth( vUv );", "	if( depth >= ( 1.0 - EPSILON ) ) {", "		discard;", "	}", "	float centerViewZ = -getViewZ( depth );", "	bool rBreak = false, lBreak = false;", "	float weightSum = sampleWeights[0];", "	vec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;", "	for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {", "		float sampleWeight = sampleWeights[i];", "		vec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;", "		vec2 sampleUv = vUv + sampleUvOffset;", "		float viewZ = -getViewZ( getDepth( sampleUv ) );", "		if( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;", "		if( ! rBreak ) {", "			diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;", "			weightSum += sampleWeight;", "		}", "		sampleUv = vUv - sampleUvOffset;", "		viewZ = -getViewZ( getDepth( sampleUv ) );", "		if( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;", "		if( ! lBreak ) {", "			diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;", "			weightSum += sampleWeight;", "		}", "	}", "	gl_FragColor = diffuseSum / weightSum;", "}"].join("\n")
};
var BlurShaderUtils = {
  createSampleWeights: (kernelRadius, stdDev) => {
    const gaussian = (x, stdDev2) => {
      return Math.exp(-(x * x) / (2 * (stdDev2 * stdDev2))) / (Math.sqrt(2 * Math.PI) * stdDev2);
    };
    const weights = [];
    for (let i2 = 0; i2 <= kernelRadius; i2++) {
      weights.push(gaussian(i2, stdDev));
    }
    return weights;
  },
  createSampleOffsets: (kernelRadius, uvIncrement) => {
    const offsets = [];
    for (let i2 = 0; i2 <= kernelRadius; i2++) {
      offsets.push(uvIncrement.clone().multiplyScalar(i2));
    }
    return offsets;
  },
  configure: (shader, kernelRadius, stdDev, uvIncrement) => {
    shader.defines["KERNEL_RADIUS"] = kernelRadius;
    shader.uniforms["sampleUvOffsets"].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);
    shader.uniforms["sampleWeights"].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);
    shader.needsUpdate = true;
  }
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/postprocessing/SAOPass.js
var SAOPass = function(scene, camera, depthTexture, useNormals, resolution) {
  this.scene = scene;
  this.camera = camera;
  this.clear = true;
  this.needsSwap = false;
  this.supportsDepthTextureExtension = depthTexture !== void 0 ? depthTexture : false;
  this.supportsNormalTexture = useNormals !== void 0 ? useNormals : false;
  this.originalClearColor = new Color();
  this._oldClearColor = new Color();
  this.oldClearAlpha = 1;
  this.params = {
    output: 0,
    saoBias: 0.5,
    saoIntensity: 0.18,
    saoScale: 1,
    saoKernelRadius: 100,
    saoMinResolution: 0,
    saoBlur: true,
    saoBlurRadius: 8,
    saoBlurStdDev: 4,
    saoBlurDepthCutoff: 0.01
  };
  this.resolution = resolution !== void 0 ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);
  this.saoRenderTarget = new WebGLRenderTarget(this.resolution.x, this.resolution.y, {
    minFilter: LinearFilter,
    magFilter: LinearFilter,
    format: RGBAFormat
  });
  this.blurIntermediateRenderTarget = this.saoRenderTarget.clone();
  this.beautyRenderTarget = this.saoRenderTarget.clone();
  this.normalRenderTarget = new WebGLRenderTarget(this.resolution.x, this.resolution.y, {
    minFilter: NearestFilter,
    magFilter: NearestFilter,
    format: RGBAFormat
  });
  this.depthRenderTarget = this.normalRenderTarget.clone();
  if (this.supportsDepthTextureExtension) {
    var depthTexture = new DepthTexture();
    depthTexture.type = UnsignedShortType;
    this.beautyRenderTarget.depthTexture = depthTexture;
    this.beautyRenderTarget.depthBuffer = true;
  }
  this.depthMaterial = new MeshDepthMaterial();
  this.depthMaterial.depthPacking = RGBADepthPacking;
  this.depthMaterial.blending = NoBlending;
  this.normalMaterial = new MeshNormalMaterial();
  this.normalMaterial.blending = NoBlending;
  if (SAOShader === void 0) {
    console.error("THREE.SAOPass relies on SAOShader");
  }
  this.saoMaterial = new ShaderMaterial({
    defines: Object.assign({}, SAOShader.defines),
    fragmentShader: SAOShader.fragmentShader,
    vertexShader: SAOShader.vertexShader,
    uniforms: UniformsUtils.clone(SAOShader.uniforms)
  });
  this.saoMaterial.extensions.derivatives = true;
  this.saoMaterial.defines["DEPTH_PACKING"] = this.supportsDepthTextureExtension ? 0 : 1;
  this.saoMaterial.defines["NORMAL_TEXTURE"] = this.supportsNormalTexture ? 1 : 0;
  this.saoMaterial.defines["PERSPECTIVE_CAMERA"] = this.camera.isPerspectiveCamera ? 1 : 0;
  this.saoMaterial.uniforms["tDepth"].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;
  this.saoMaterial.uniforms["tNormal"].value = this.normalRenderTarget.texture;
  this.saoMaterial.uniforms["size"].value.set(this.resolution.x, this.resolution.y);
  this.saoMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
  this.saoMaterial.uniforms["cameraProjectionMatrix"].value = this.camera.projectionMatrix;
  this.saoMaterial.blending = NoBlending;
  if (DepthLimitedBlurShader === void 0) {
    console.error("THREE.SAOPass relies on DepthLimitedBlurShader");
  }
  this.vBlurMaterial = new ShaderMaterial({
    uniforms: UniformsUtils.clone(DepthLimitedBlurShader.uniforms),
    defines: Object.assign({}, DepthLimitedBlurShader.defines),
    vertexShader: DepthLimitedBlurShader.vertexShader,
    fragmentShader: DepthLimitedBlurShader.fragmentShader
  });
  this.vBlurMaterial.defines["DEPTH_PACKING"] = this.supportsDepthTextureExtension ? 0 : 1;
  this.vBlurMaterial.defines["PERSPECTIVE_CAMERA"] = this.camera.isPerspectiveCamera ? 1 : 0;
  this.vBlurMaterial.uniforms["tDiffuse"].value = this.saoRenderTarget.texture;
  this.vBlurMaterial.uniforms["tDepth"].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;
  this.vBlurMaterial.uniforms["size"].value.set(this.resolution.x, this.resolution.y);
  this.vBlurMaterial.blending = NoBlending;
  this.hBlurMaterial = new ShaderMaterial({
    uniforms: UniformsUtils.clone(DepthLimitedBlurShader.uniforms),
    defines: Object.assign({}, DepthLimitedBlurShader.defines),
    vertexShader: DepthLimitedBlurShader.vertexShader,
    fragmentShader: DepthLimitedBlurShader.fragmentShader
  });
  this.hBlurMaterial.defines["DEPTH_PACKING"] = this.supportsDepthTextureExtension ? 0 : 1;
  this.hBlurMaterial.defines["PERSPECTIVE_CAMERA"] = this.camera.isPerspectiveCamera ? 1 : 0;
  this.hBlurMaterial.uniforms["tDiffuse"].value = this.blurIntermediateRenderTarget.texture;
  this.hBlurMaterial.uniforms["tDepth"].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;
  this.hBlurMaterial.uniforms["size"].value.set(this.resolution.x, this.resolution.y);
  this.hBlurMaterial.blending = NoBlending;
  if (CopyShader === void 0) {
    console.error("THREE.SAOPass relies on CopyShader");
  }
  this.materialCopy = new ShaderMaterial({
    uniforms: UniformsUtils.clone(CopyShader.uniforms),
    vertexShader: CopyShader.vertexShader,
    fragmentShader: CopyShader.fragmentShader,
    blending: NoBlending
  });
  this.materialCopy.transparent = true;
  this.materialCopy.depthTest = false;
  this.materialCopy.depthWrite = false;
  this.materialCopy.blending = CustomBlending;
  this.materialCopy.blendSrc = DstColorFactor;
  this.materialCopy.blendDst = ZeroFactor;
  this.materialCopy.blendEquation = AddEquation;
  this.materialCopy.blendSrcAlpha = DstAlphaFactor;
  this.materialCopy.blendDstAlpha = ZeroFactor;
  this.materialCopy.blendEquationAlpha = AddEquation;
  if (UnpackDepthRGBAShader === void 0) {
    console.error("THREE.SAOPass relies on UnpackDepthRGBAShader");
  }
  this.depthCopy = new ShaderMaterial({
    uniforms: UniformsUtils.clone(UnpackDepthRGBAShader.uniforms),
    vertexShader: UnpackDepthRGBAShader.vertexShader,
    fragmentShader: UnpackDepthRGBAShader.fragmentShader,
    blending: NoBlending
  });
  this.fsQuad = new FullScreenQuad(null);
};
SAOPass.OUTPUT = {
  Beauty: 1,
  Default: 0,
  SAO: 2,
  Depth: 3,
  Normal: 4
};
SAOPass.prototype = Object.assign(Object.create(Pass2.prototype), {
  constructor: SAOPass,
  render: function(renderer, writeBuffer, readBuffer) {
    if (this.renderToScreen) {
      this.materialCopy.blending = NoBlending;
      this.materialCopy.uniforms["tDiffuse"].value = readBuffer.texture;
      this.materialCopy.needsUpdate = true;
      this.renderPass(renderer, this.materialCopy, null);
    }
    if (this.params.output === 1) {
      return;
    }
    renderer.getClearColor(this._oldClearColor);
    this.oldClearAlpha = renderer.getClearAlpha();
    var oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    renderer.setRenderTarget(this.depthRenderTarget);
    renderer.clear();
    this.saoMaterial.uniforms["bias"].value = this.params.saoBias;
    this.saoMaterial.uniforms["intensity"].value = this.params.saoIntensity;
    this.saoMaterial.uniforms["scale"].value = this.params.saoScale;
    this.saoMaterial.uniforms["kernelRadius"].value = this.params.saoKernelRadius;
    this.saoMaterial.uniforms["minResolution"].value = this.params.saoMinResolution;
    this.saoMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.saoMaterial.uniforms["cameraFar"].value = this.camera.far;
    var depthCutoff = this.params.saoBlurDepthCutoff * (this.camera.far - this.camera.near);
    this.vBlurMaterial.uniforms["depthCutoff"].value = depthCutoff;
    this.hBlurMaterial.uniforms["depthCutoff"].value = depthCutoff;
    this.vBlurMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.vBlurMaterial.uniforms["cameraFar"].value = this.camera.far;
    this.hBlurMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.hBlurMaterial.uniforms["cameraFar"].value = this.camera.far;
    this.params.saoBlurRadius = Math.floor(this.params.saoBlurRadius);
    if (this.prevStdDev !== this.params.saoBlurStdDev || this.prevNumSamples !== this.params.saoBlurRadius) {
      BlurShaderUtils.configure(this.vBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2(0, 1));
      BlurShaderUtils.configure(this.hBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2(1, 0));
      this.prevStdDev = this.params.saoBlurStdDev;
      this.prevNumSamples = this.params.saoBlurRadius;
    }
    renderer.setClearColor(0);
    renderer.setRenderTarget(this.beautyRenderTarget);
    renderer.clear();
    renderer.render(this.scene, this.camera);
    if (!this.supportsDepthTextureExtension) {
      this.renderOverride(renderer, this.depthMaterial, this.depthRenderTarget, 0, 1);
    }
    if (this.supportsNormalTexture) {
      this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 7829503, 1);
    }
    this.renderPass(renderer, this.saoMaterial, this.saoRenderTarget, 16777215, 1);
    if (this.params.saoBlur) {
      this.renderPass(renderer, this.vBlurMaterial, this.blurIntermediateRenderTarget, 16777215, 1);
      this.renderPass(renderer, this.hBlurMaterial, this.saoRenderTarget, 16777215, 1);
    }
    var outputMaterial = this.materialCopy;
    if (this.params.output === 3) {
      if (this.supportsDepthTextureExtension) {
        this.materialCopy.uniforms["tDiffuse"].value = this.beautyRenderTarget.depthTexture;
        this.materialCopy.needsUpdate = true;
      } else {
        this.depthCopy.uniforms["tDiffuse"].value = this.depthRenderTarget.texture;
        this.depthCopy.needsUpdate = true;
        outputMaterial = this.depthCopy;
      }
    } else if (this.params.output === 4) {
      this.materialCopy.uniforms["tDiffuse"].value = this.normalRenderTarget.texture;
      this.materialCopy.needsUpdate = true;
    } else {
      this.materialCopy.uniforms["tDiffuse"].value = this.saoRenderTarget.texture;
      this.materialCopy.needsUpdate = true;
    }
    if (this.params.output === 0) {
      outputMaterial.blending = CustomBlending;
    } else {
      outputMaterial.blending = NoBlending;
    }
    this.renderPass(renderer, outputMaterial, this.renderToScreen ? null : readBuffer);
    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);
    renderer.autoClear = oldAutoClear;
  },
  renderPass: function(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {
    renderer.getClearColor(this.originalClearColor);
    var originalClearAlpha = renderer.getClearAlpha();
    var originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.fsQuad.material = passMaterial;
    this.fsQuad.render(renderer);
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  },
  renderOverride: function(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {
    renderer.getClearColor(this.originalClearColor);
    var originalClearAlpha = renderer.getClearAlpha();
    var originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    clearColor = overrideMaterial.clearColor || clearColor;
    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.scene.overrideMaterial = overrideMaterial;
    renderer.render(this.scene, this.camera);
    this.scene.overrideMaterial = null;
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  },
  setSize: function(width, height) {
    this.beautyRenderTarget.setSize(width, height);
    this.saoRenderTarget.setSize(width, height);
    this.blurIntermediateRenderTarget.setSize(width, height);
    this.normalRenderTarget.setSize(width, height);
    this.depthRenderTarget.setSize(width, height);
    this.saoMaterial.uniforms["size"].value.set(width, height);
    this.saoMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
    this.saoMaterial.uniforms["cameraProjectionMatrix"].value = this.camera.projectionMatrix;
    this.saoMaterial.needsUpdate = true;
    this.vBlurMaterial.uniforms["size"].value.set(width, height);
    this.vBlurMaterial.needsUpdate = true;
    this.hBlurMaterial.uniforms["size"].value.set(width, height);
    this.hBlurMaterial.needsUpdate = true;
  }
});

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/AfterimageShader.js
var AfterimageShader = {
  uniforms: {
    damp: {
      value: 0.96
    },
    tOld: {
      value: null
    },
    tNew: {
      value: null
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float damp;", "uniform sampler2D tOld;", "uniform sampler2D tNew;", "varying vec2 vUv;", "vec4 when_gt( vec4 x, float y ) {", "	return max( sign( x - y ), 0.0 );", "}", "void main() {", "	vec4 texelOld = texture2D( tOld, vUv );", "	vec4 texelNew = texture2D( tNew, vUv );", "	texelOld *= damp * when_gt( texelOld, 0.1 );", "	gl_FragColor = max(texelNew, texelOld);", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/DotScreenShader.js
var DotScreenShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    tSize: {
      value: new Vector2(256, 256)
    },
    center: {
      value: new Vector2(0.5, 0.5)
    },
    angle: {
      value: 1.57
    },
    scale: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform vec2 center;", "uniform float angle;", "uniform float scale;", "uniform vec2 tSize;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "float pattern() {", "	float s = sin( angle ), c = cos( angle );", "	vec2 tex = vUv * tSize - center;", "	vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;", "	return ( sin( point.x ) * sin( point.y ) ) * 4.0;", "}", "void main() {", "	vec4 color = texture2D( tDiffuse, vUv );", "	float average = ( color.r + color.g + color.b ) / 3.0;", "	gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/SSRShader.js
var SSRShader = {
  defines: {
    MAX_STEP: 0,
    isPerspectiveCamera: true,
    isDistanceAttenuation: true,
    isFresnel: true,
    isInfiniteThick: false,
    isSelective: false
  },
  uniforms: {
    tDiffuse: {
      value: null
    },
    tNormal: {
      value: null
    },
    tMetalness: {
      value: null
    },
    tDepth: {
      value: null
    },
    cameraNear: {
      value: null
    },
    cameraFar: {
      value: null
    },
    resolution: {
      value: new Vector2()
    },
    cameraProjectionMatrix: {
      value: new Matrix4()
    },
    cameraInverseProjectionMatrix: {
      value: new Matrix4()
    },
    opacity: {
      value: 0.5
    },
    maxDistance: {
      value: 180
    },
    cameraRange: {
      value: 0
    },
    surfDist: {
      value: 7e-3
    },
    thickTolerance: {
      value: 0.03
    }
  },
  vertexShader: `

    varying vec2 vUv;

    void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }

  `,
  fragmentShader: `
		// precision highp float;
		precision highp sampler2D;
		varying vec2 vUv;
		uniform sampler2D tDepth;
		uniform sampler2D tNormal;
		uniform sampler2D tMetalness;
		uniform sampler2D tDiffuse;
		uniform float cameraRange;
		uniform vec2 resolution;
		uniform float opacity;
		uniform float cameraNear;
		uniform float cameraFar;
		uniform float maxDistance;
		uniform float surfDist;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;
		uniform float thickTolerance;
		#include <packing>
		float pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {
			//x0: point, x1: linePointA, x2: linePointB
			//https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html
			return length(cross(x0-x1,x0-x2))/length(x2-x1);
		}
		float pointPlaneDistance(vec3 point,vec3 planePoint,vec3 planeNormal){
			// https://mathworld.wolfram.com/Point-PlaneDistance.html
			//// https://en.wikipedia.org/wiki/Plane_(geometry)
			//// http://paulbourke.net/geometry/pointlineplane/
			float a=planeNormal.x,b=planeNormal.y,c=planeNormal.z;
			float x0=point.x,y0=point.y,z0=point.z;
			float x=planePoint.x,y=planePoint.y,z=planePoint.z;
			float d=-(a*x+b*y+c*z);
			float distance=(a*x0+b*y0+c*z0+d)/sqrt(a*a+b*b+c*c);
			return distance;
		}
		float getDepth( const in vec2 uv ) {
			return texture2D( tDepth, uv ).x;
		}
		float getViewZ( const in float depth ) {
			#ifdef isPerspectiveCamera
				return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
				return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}
		vec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {
			vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc
			clipPosition *= clipW; //clip
			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;//view
		}
		vec3 getViewNormal( const in vec2 uv ) {
			return unpackRGBToNormal( texture2D( tNormal, uv ).xyz );
		}
		vec2 viewPositionToXY(vec3 viewPosition){
			vec2 xy;
			vec4 clip=cameraProjectionMatrix*vec4(viewPosition,1);
			xy=clip.xy;//clip
			float clipW=clip.w;
			xy/=clipW;//NDC
			xy=(xy+1.)/2.;//uv
			xy*=resolution;//screen
			return xy;
		}
		void main(){
			#ifdef isSelective
				float metalness=texture2D(tMetalness,vUv).r;
				if(metalness==0.) return;
			#endif

			float depth = getDepth( vUv );
			float viewZ = getViewZ( depth );
			if(-viewZ>=cameraFar) return;

			float clipW = cameraProjectionMatrix[2][3] * viewZ+cameraProjectionMatrix[3][3];
			vec3 viewPosition=getViewPosition( vUv, depth, clipW );

			vec2 d0=gl_FragCoord.xy;
			vec2 d1;

			vec3 viewNormal=getViewNormal( vUv );

			#ifdef isPerspectiveCamera
				vec3 viewIncidenceDir=normalize(viewPosition);
				vec3 viewReflectDir=reflect(viewIncidenceDir,viewNormal);
			#else
				vec3 viewIncidenceDir=vec3(0,0,-1);
				vec3 viewReflectDir=reflect(viewIncidenceDir,viewNormal);
			#endif

			float maxReflectRayLen=maxDistance/dot(-viewIncidenceDir,viewNormal);
			// dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html
			// if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)
			// maxDistance/maxReflectRayLen=cos(theta)
			// maxDistance/maxReflectRayLen==dot(a,b)
			// maxReflectRayLen==maxDistance/dot(a,b)

			vec3 d1viewPosition=viewPosition+viewReflectDir*maxReflectRayLen;
			#ifdef isPerspectiveCamera
				if(d1viewPosition.z>-cameraNear){
					//https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx
					float t=(-cameraNear-viewPosition.z)/viewReflectDir.z;
					d1viewPosition=viewPosition+viewReflectDir*t;
				}
			#endif
			d1=viewPositionToXY(d1viewPosition);

			float totalLen=length(d1-d0);
			float xLen=d1.x-d0.x;
			float yLen=d1.y-d0.y;
			float totalStep=max(abs(xLen),abs(yLen));
			float xSpan=xLen/totalStep;
			float ySpan=yLen/totalStep;
			for(float i=0.;i<MAX_STEP;i++){
				if(i>=totalStep) break;
				vec2 xy=vec2(d0.x+i*xSpan,d0.y+i*ySpan);
				if(xy.x<0.||xy.x>resolution.x||xy.y<0.||xy.y>resolution.y) break;
				float s=length(xy-d0)/totalLen;
				vec2 uv=xy/resolution;

				float d = getDepth(uv);
				float vZ = getViewZ( d );
				if(-vZ>=cameraFar) continue;
				float cW = cameraProjectionMatrix[2][3] * vZ+cameraProjectionMatrix[3][3];
				vec3 vP=getViewPosition( uv, d, cW );

				#ifdef isPerspectiveCamera
					// https://www.comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf
					float recipVPZ=1./viewPosition.z;
					float viewReflectRayZ=1./(recipVPZ+s*(1./d1viewPosition.z-recipVPZ));
					float sD=surfDist*cW;
				#else
					float viewReflectRayZ=viewPosition.z+s*(d1viewPosition.z-viewPosition.z);
					float sD=surfDist;
				#endif
				if(viewReflectRayZ-sD>vZ) continue;

				#ifdef isInfiniteThick
					if(viewReflectRayZ+thickTolerance*clipW<vP.z) break;
				#endif
				float away=pointToLineDistance(vP,viewPosition,d1viewPosition);

				float op=opacity;

				if(away<sD){
					vec3 vN=getViewNormal( uv );
					if(dot(viewReflectDir,vN)>=0.) continue;
					float distance=pointPlaneDistance(vP,viewPosition,viewNormal);
					if(distance>maxDistance) break;
					#ifdef isDistanceAttenuation
						float ratio=1.-(distance/maxDistance);
						float attenuation=ratio*ratio;
						op=opacity*attenuation;
					#endif
					#ifdef isFresnel
						float fresnel=(dot(viewIncidenceDir,viewReflectDir)+1.)/2.;
						op*=fresnel;
					#endif
					vec4 reflectColor=texture2D(tDiffuse,uv);
					gl_FragColor.xyz=reflectColor.xyz;
					gl_FragColor.a=op;
					break;
				}
			}
		}
	`
};
var SSRDepthShader = {
  defines: {
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tDepth: {
      value: null
    },
    cameraNear: {
      value: null
    },
    cameraFar: {
      value: null
    }
  },
  vertexShader: `

    varying vec2 vUv;

    void main() {

    	vUv = uv;
    	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }

  `,
  fragmentShader: `

    uniform sampler2D tDepth;

    uniform float cameraNear;
    uniform float cameraFar;

    varying vec2 vUv;

    #include <packing>

		float getLinearDepth( const in vec2 uv ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, uv ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, uv ).x;

			#endif

		}

    void main() {

    	float depth = getLinearDepth( vUv );
			float d = 1.0 - depth;
			// d=(d-.999)*1000.;
    	gl_FragColor = vec4( vec3( d ), 1.0 );

    }

  `
};
var SSRBlurShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    resolution: {
      value: new Vector2()
    },
    opacity: {
      value: 0.5
    }
  },
  vertexShader: `

    varying vec2 vUv;

    void main() {

    	vUv = uv;
    	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }

  `,
  fragmentShader: `

    uniform sampler2D tDiffuse;
    uniform vec2 resolution;
    varying vec2 vUv;
    void main() {
			//reverse engineering from PhotoShop blur filter, then change coefficient

    	vec2 texelSize = ( 1.0 / resolution );

			vec4 c=texture2D(tDiffuse,vUv);

			vec2 offset;

			offset=(vec2(-1,0))*texelSize;
			vec4 cl=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(1,0))*texelSize;
			vec4 cr=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(0,-1))*texelSize;
			vec4 cb=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(0,1))*texelSize;
			vec4 ct=texture2D(tDiffuse,vUv+offset);

			// float coeCenter=.5;
			// float coeSide=.125;
			float coeCenter=.2;
			float coeSide=.2;
			float a=c.a*coeCenter+cl.a*coeSide+cr.a*coeSide+cb.a*coeSide+ct.a*coeSide;
			vec3 rgb=(c.rgb*c.a*coeCenter+cl.rgb*cl.a*coeSide+cr.rgb*cr.a*coeSide+cb.rgb*cb.a*coeSide+ct.rgb*ct.a*coeSide)/a;
			gl_FragColor=vec4(rgb,a);

		}
	`
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/postprocessing/SSRPass.js
var SSRPass = function({
  renderer,
  scene,
  camera,
  width,
  height,
  selects,
  encoding,
  isPerspectiveCamera = true,
  isBouncing = false,
  morphTargets = false,
  groundReflector
}) {
  this.width = width !== void 0 ? width : 512;
  this.height = height !== void 0 ? height : 512;
  this.clear = true;
  this.renderer = renderer;
  this.scene = scene;
  this.camera = camera;
  this.groundReflector = groundReflector;
  this.opacity = SSRShader.uniforms.opacity.value;
  this.output = 0;
  this.maxDistance = SSRShader.uniforms.maxDistance.value;
  this.surfDist = SSRShader.uniforms.surfDist.value;
  this.encoding = encoding;
  this.tempColor = new Color();
  this._selects = selects;
  this.isSelective = Array.isArray(this._selects);
  Object.defineProperty(this, "selects", {
    get() {
      return this._selects;
    },
    set(val) {
      if (this._selects === val)
        return;
      this._selects = val;
      if (Array.isArray(val)) {
        this.isSelective = true;
        this.ssrMaterial.defines.isSelective = true;
        this.ssrMaterial.needsUpdate = true;
      } else {
        this.isSelective = false;
        this.ssrMaterial.defines.isSelective = false;
        this.ssrMaterial.needsUpdate = true;
      }
    }
  });
  this._isBouncing = isBouncing;
  Object.defineProperty(this, "isBouncing", {
    get() {
      return this._isBouncing;
    },
    set(val) {
      if (this._isBouncing === val)
        return;
      this._isBouncing = val;
      if (val) {
        this.ssrMaterial.uniforms["tDiffuse"].value = this.prevRenderTarget.texture;
      } else {
        this.ssrMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
      }
    }
  });
  this.isBlur = true;
  this._isDistanceAttenuation = SSRShader.defines.isDistanceAttenuation;
  Object.defineProperty(this, "isDistanceAttenuation", {
    get() {
      return this._isDistanceAttenuation;
    },
    set(val) {
      if (this._isDistanceAttenuation === val)
        return;
      this._isDistanceAttenuation = val;
      this.ssrMaterial.defines.isDistanceAttenuation = val;
      this.ssrMaterial.needsUpdate = true;
    }
  });
  this._isFresnel = SSRShader.defines.isFresnel;
  Object.defineProperty(this, "isFresnel", {
    get() {
      return this._isFresnel;
    },
    set(val) {
      if (this._isFresnel === val)
        return;
      this._isFresnel = val;
      this.ssrMaterial.defines.isFresnel = val;
      this.ssrMaterial.needsUpdate = true;
    }
  });
  this._isInfiniteThick = SSRShader.defines.isInfiniteThick;
  Object.defineProperty(this, "isInfiniteThick", {
    get() {
      return this._isInfiniteThick;
    },
    set(val) {
      if (this._isInfiniteThick === val)
        return;
      this._isInfiniteThick = val;
      this.ssrMaterial.defines.isInfiniteThick = val;
      this.ssrMaterial.needsUpdate = true;
    }
  });
  this.thickTolerance = SSRShader.uniforms.thickTolerance.value;
  var depthTexture = new DepthTexture();
  depthTexture.type = UnsignedShortType;
  depthTexture.minFilter = NearestFilter;
  depthTexture.maxFilter = NearestFilter;
  this.beautyRenderTarget = new WebGLRenderTarget(this.width, this.height, {
    minFilter: LinearFilter,
    magFilter: LinearFilter,
    format: RGBAFormat,
    depthTexture,
    depthBuffer: true
  });
  this.prevRenderTarget = new WebGLRenderTarget(this.width, this.height, {
    minFilter: LinearFilter,
    magFilter: LinearFilter,
    format: RGBAFormat
  });
  this.normalRenderTarget = new WebGLRenderTarget(this.width, this.height, {
    minFilter: NearestFilter,
    magFilter: NearestFilter,
    format: RGBAFormat,
    type: HalfFloatType
  });
  this.metalnessRenderTarget = new WebGLRenderTarget(this.width, this.height, {
    minFilter: NearestFilter,
    magFilter: NearestFilter,
    format: RGBAFormat
  });
  this.ssrRenderTarget = new WebGLRenderTarget(this.width, this.height, {
    minFilter: LinearFilter,
    magFilter: LinearFilter,
    format: RGBAFormat
  });
  this.blurRenderTarget = this.ssrRenderTarget.clone();
  this.blurRenderTarget2 = this.ssrRenderTarget.clone();
  if (SSRShader === void 0) {
    console.error("THREE.SSRPass: The pass relies on SSRShader.");
  }
  this.ssrMaterial = new ShaderMaterial({
    defines: Object.assign({
      MAX_STEP: Math.sqrt(window.innerWidth * window.innerWidth + window.innerHeight * window.innerHeight)
    }, SSRShader.defines),
    uniforms: UniformsUtils.clone(SSRShader.uniforms),
    vertexShader: SSRShader.vertexShader,
    fragmentShader: SSRShader.fragmentShader,
    blending: NoBlending
  });
  if (!isPerspectiveCamera) {
    this.ssrMaterial.defines.isPerspectiveCamera = isPerspectiveCamera;
    this.ssrMaterial.needsUpdate = true;
  }
  this.ssrMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
  this.ssrMaterial.uniforms["tNormal"].value = this.normalRenderTarget.texture;
  this.ssrMaterial.defines.isSelective = this.isSelective;
  this.ssrMaterial.needsUpdate = true;
  this.ssrMaterial.uniforms["tMetalness"].value = this.metalnessRenderTarget.texture;
  this.ssrMaterial.uniforms["tDepth"].value = this.beautyRenderTarget.depthTexture;
  this.ssrMaterial.uniforms["cameraNear"].value = this.camera.near;
  this.ssrMaterial.uniforms["cameraFar"].value = this.camera.far;
  this.ssrMaterial.uniforms["surfDist"].value = this.surfDist;
  this.ssrMaterial.uniforms["resolution"].value.set(this.width, this.height);
  this.ssrMaterial.uniforms["cameraProjectionMatrix"].value.copy(this.camera.projectionMatrix);
  this.ssrMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
  this.normalMaterial = new MeshNormalMaterial({
    morphTargets
  });
  this.normalMaterial.blending = NoBlending;
  this.metalnessOnMaterial = new MeshBasicMaterial({
    color: "white"
  });
  this.metalnessOffMaterial = new MeshBasicMaterial({
    color: "black"
  });
  this.blurMaterial = new ShaderMaterial({
    defines: Object.assign({}, SSRBlurShader.defines),
    uniforms: UniformsUtils.clone(SSRBlurShader.uniforms),
    vertexShader: SSRBlurShader.vertexShader,
    fragmentShader: SSRBlurShader.fragmentShader
  });
  this.blurMaterial.uniforms["tDiffuse"].value = this.ssrRenderTarget.texture;
  this.blurMaterial.uniforms["resolution"].value.set(this.width, this.height);
  this.blurMaterial2 = new ShaderMaterial({
    defines: Object.assign({}, SSRBlurShader.defines),
    uniforms: UniformsUtils.clone(SSRBlurShader.uniforms),
    vertexShader: SSRBlurShader.vertexShader,
    fragmentShader: SSRBlurShader.fragmentShader
  });
  this.blurMaterial2.uniforms["tDiffuse"].value = this.blurRenderTarget.texture;
  this.blurMaterial2.uniforms["resolution"].value.set(this.width, this.height);
  this.depthRenderMaterial = new ShaderMaterial({
    defines: Object.assign({}, SSRDepthShader.defines),
    uniforms: UniformsUtils.clone(SSRDepthShader.uniforms),
    vertexShader: SSRDepthShader.vertexShader,
    fragmentShader: SSRDepthShader.fragmentShader,
    blending: NoBlending
  });
  this.depthRenderMaterial.uniforms["tDepth"].value = this.beautyRenderTarget.depthTexture;
  this.depthRenderMaterial.uniforms["cameraNear"].value = this.camera.near;
  this.depthRenderMaterial.uniforms["cameraFar"].value = this.camera.far;
  this.copyMaterial = new ShaderMaterial({
    uniforms: UniformsUtils.clone(CopyShader.uniforms),
    vertexShader: CopyShader.vertexShader,
    fragmentShader: CopyShader.fragmentShader,
    transparent: true,
    depthTest: false,
    depthWrite: false,
    blendSrc: SrcAlphaFactor,
    blendDst: OneMinusSrcAlphaFactor,
    blendEquation: AddEquation,
    blendSrcAlpha: SrcAlphaFactor,
    blendDstAlpha: OneMinusSrcAlphaFactor,
    blendEquationAlpha: AddEquation
  });
  this.fsQuad = new FullScreenQuad(null);
  this.originalClearColor = new Color();
};
SSRPass.prototype = Object.assign(Object.create(Pass2.prototype), {
  constructor: SSRPass,
  dispose: function() {
    this.beautyRenderTarget.dispose();
    this.prevRenderTarget.dispose();
    this.normalRenderTarget.dispose();
    this.metalnessRenderTarget.dispose();
    this.ssrRenderTarget.dispose();
    this.blurRenderTarget.dispose();
    this.blurRenderTarget2.dispose();
    this.normalMaterial.dispose();
    this.metalnessOnMaterial.dispose();
    this.metalnessOffMaterial.dispose();
    this.blurMaterial.dispose();
    this.blurMaterial2.dispose();
    this.copyMaterial.dispose();
    this.depthRenderMaterial.dispose();
    this.fsQuad.dispose();
  },
  render: function(renderer, writeBuffer) {
    if (this.encoding)
      this.beautyRenderTarget.texture.encoding = this.encoding;
    renderer.setRenderTarget(this.beautyRenderTarget);
    renderer.clear();
    if (this.groundReflector) {
      this.groundReflector.doRender(this.renderer, this.scene, this.camera);
      this.groundReflector.visible = true;
    }
    renderer.render(this.scene, this.camera);
    if (this.groundReflector)
      this.groundReflector.visible = false;
    this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 0, 0);
    if (this.isSelective) {
      this.renderMetalness(renderer, this.metalnessOnMaterial, this.metalnessRenderTarget, 0, 0);
    }
    this.ssrMaterial.uniforms["opacity"].value = this.opacity;
    this.ssrMaterial.uniforms["maxDistance"].value = this.maxDistance;
    this.ssrMaterial.uniforms["surfDist"].value = this.surfDist;
    this.ssrMaterial.uniforms["thickTolerance"].value = this.thickTolerance;
    this.renderPass(renderer, this.ssrMaterial, this.ssrRenderTarget);
    if (this.isBlur) {
      this.renderPass(renderer, this.blurMaterial, this.blurRenderTarget);
      this.renderPass(renderer, this.blurMaterial2, this.blurRenderTarget2);
    }
    switch (this.output) {
      case SSRPass.OUTPUT.Default:
        if (this.isBouncing) {
          this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
          this.copyMaterial.blending = NoBlending;
          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);
          if (this.isBlur)
            this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget2.texture;
          else
            this.copyMaterial.uniforms["tDiffuse"].value = this.ssrRenderTarget.texture;
          this.copyMaterial.blending = NormalBlending;
          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);
          this.copyMaterial.uniforms["tDiffuse"].value = this.prevRenderTarget.texture;
          this.copyMaterial.blending = NoBlending;
          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        } else {
          this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
          this.copyMaterial.blending = NoBlending;
          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
          if (this.isBlur)
            this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget2.texture;
          else
            this.copyMaterial.uniforms["tDiffuse"].value = this.ssrRenderTarget.texture;
          this.copyMaterial.blending = NormalBlending;
          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        }
        break;
      case SSRPass.OUTPUT.SSR:
        if (this.isBlur)
          this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget2.texture;
        else
          this.copyMaterial.uniforms["tDiffuse"].value = this.ssrRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        if (this.isBouncing) {
          if (this.isBlur)
            this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget2.texture;
          else
            this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
          this.copyMaterial.blending = NoBlending;
          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);
          this.copyMaterial.uniforms["tDiffuse"].value = this.ssrRenderTarget.texture;
          this.copyMaterial.blending = NormalBlending;
          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);
        }
        break;
      case SSRPass.OUTPUT.Beauty:
        this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSRPass.OUTPUT.Depth:
        this.renderPass(renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSRPass.OUTPUT.Normal:
        this.copyMaterial.uniforms["tDiffuse"].value = this.normalRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSRPass.OUTPUT.Metalness:
        this.copyMaterial.uniforms["tDiffuse"].value = this.metalnessRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      default:
        console.warn("THREE.SSRPass: Unknown output type.");
    }
  },
  renderPass: function(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {
    this.originalClearColor.copy(renderer.getClearColor(this.tempColor));
    var originalClearAlpha = renderer.getClearAlpha(this.tempColor);
    var originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.fsQuad.material = passMaterial;
    this.fsQuad.render(renderer);
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  },
  renderOverride: function(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {
    this.originalClearColor.copy(renderer.getClearColor(this.tempColor));
    var originalClearAlpha = renderer.getClearAlpha(this.tempColor);
    var originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    clearColor = overrideMaterial.clearColor || clearColor;
    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.scene.overrideMaterial = overrideMaterial;
    renderer.render(this.scene, this.camera);
    this.scene.overrideMaterial = null;
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  },
  renderMetalness: function(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {
    this.originalClearColor.copy(renderer.getClearColor(this.tempColor));
    var originalClearAlpha = renderer.getClearAlpha(this.tempColor);
    var originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    clearColor = overrideMaterial.clearColor || clearColor;
    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.scene.traverseVisible((child) => {
      child._SSRPassMaterialBack = child.material;
      if (this._selects.includes(child)) {
        child.material = this.metalnessOnMaterial;
      } else {
        child.material = this.metalnessOffMaterial;
      }
    });
    renderer.render(this.scene, this.camera);
    this.scene.traverseVisible((child) => {
      child.material = child._SSRPassMaterialBack;
    });
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  },
  setSize: function(width, height) {
    this.width = width;
    this.height = height;
    this.ssrMaterial.defines.MAX_STEP = Math.sqrt(width * width + height * height);
    this.ssrMaterial.needsUpdate = true;
    this.beautyRenderTarget.setSize(width, height);
    this.prevRenderTarget.setSize(width, height);
    this.ssrRenderTarget.setSize(width, height);
    this.normalRenderTarget.setSize(width, height);
    this.metalnessRenderTarget.setSize(width, height);
    this.blurRenderTarget.setSize(width, height);
    this.blurRenderTarget2.setSize(width, height);
    this.ssrMaterial.uniforms["resolution"].value.set(width, height);
    this.ssrMaterial.uniforms["cameraProjectionMatrix"].value.copy(this.camera.projectionMatrix);
    this.ssrMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
    this.blurMaterial.uniforms["resolution"].value.set(width, height);
    this.blurMaterial2.uniforms["resolution"].value.set(width, height);
  }
});
SSRPass.OUTPUT = {
  Default: 0,
  SSR: 1,
  Beauty: 3,
  Depth: 4,
  Normal: 5,
  Metalness: 7
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/postprocessing/SSAARenderPass.js
var SSAARenderPass = function(scene, camera, clearColor, clearAlpha) {
  this.scene = scene;
  this.camera = camera;
  this.sampleLevel = 4;
  this.unbiased = true;
  this.clearColor = clearColor !== void 0 ? clearColor : 0;
  this.clearAlpha = clearAlpha !== void 0 ? clearAlpha : 0;
  this._oldClearColor = new Color();
  if (CopyShader === void 0)
    console.error("THREE.SSAARenderPass relies on CopyShader");
  var copyShader = CopyShader;
  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);
  this.copyMaterial = new ShaderMaterial({
    uniforms: this.copyUniforms,
    vertexShader: copyShader.vertexShader,
    fragmentShader: copyShader.fragmentShader,
    premultipliedAlpha: true,
    transparent: true,
    blending: AdditiveBlending,
    depthTest: false,
    depthWrite: false
  });
  this.fsQuad = new FullScreenQuad(this.copyMaterial);
};
SSAARenderPass.prototype = Object.assign(Object.create(Pass2.prototype), {
  constructor: SSAARenderPass,
  dispose: function() {
    if (this.sampleRenderTarget) {
      this.sampleRenderTarget.dispose();
      this.sampleRenderTarget = null;
    }
  },
  setSize: function(width, height) {
    if (this.sampleRenderTarget)
      this.sampleRenderTarget.setSize(width, height);
  },
  render: function(renderer, writeBuffer, readBuffer) {
    if (!this.sampleRenderTarget) {
      this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        format: RGBAFormat
      });
      this.sampleRenderTarget.texture.name = "SSAARenderPass.sample";
    }
    var jitterOffsets = SSAARenderPass.JitterVectors[Math.max(0, Math.min(this.sampleLevel, 5))];
    var autoClear = renderer.autoClear;
    renderer.autoClear = false;
    renderer.getClearColor(this._oldClearColor);
    var oldClearAlpha = renderer.getClearAlpha();
    var baseSampleWeight = 1 / jitterOffsets.length;
    var roundingRange = 1 / 32;
    this.copyUniforms["tDiffuse"].value = this.sampleRenderTarget.texture;
    var width = readBuffer.width, height = readBuffer.height;
    for (let i2 = 0; i2 < jitterOffsets.length; i2++) {
      var jitterOffset = jitterOffsets[i2];
      if (this.camera.setViewOffset) {
        this.camera.setViewOffset(
          width,
          height,
          jitterOffset[0] * 0.0625,
          jitterOffset[1] * 0.0625,
          width,
          height
        );
      }
      var sampleWeight = baseSampleWeight;
      if (this.unbiased) {
        var uniformCenteredDistribution = -0.5 + (i2 + 0.5) / jitterOffsets.length;
        sampleWeight += roundingRange * uniformCenteredDistribution;
      }
      this.copyUniforms["opacity"].value = sampleWeight;
      renderer.setClearColor(this.clearColor, this.clearAlpha);
      renderer.setRenderTarget(this.sampleRenderTarget);
      renderer.clear();
      renderer.render(this.scene, this.camera);
      renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
      if (i2 === 0) {
        renderer.setClearColor(0, 0);
        renderer.clear();
      }
      this.fsQuad.render(renderer);
    }
    if (this.camera.clearViewOffset)
      this.camera.clearViewOffset();
    renderer.autoClear = autoClear;
    renderer.setClearColor(this._oldClearColor, oldClearAlpha);
  }
});
SSAARenderPass.JitterVectors = [[[0, 0]], [[4, 4], [-4, -4]], [[-2, -6], [6, -2], [-6, 2], [2, 6]], [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]], [[1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5], [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]], [[-4, -7], [-7, -5], [-3, -5], [-5, -4], [-1, -4], [-2, -2], [-6, -1], [-4, 0], [-7, 1], [-1, 2], [-6, 3], [-3, 3], [-7, 6], [-3, 6], [-5, 7], [-1, 7], [5, -7], [1, -6], [6, -5], [4, -4], [2, -3], [7, -2], [1, -1], [4, -1], [2, 1], [6, 2], [0, 4], [4, 4], [2, 5], [7, 5], [5, 6], [3, 7]]];

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/postprocessing/TAARenderPass.js
var TAARenderPass = function(scene, camera, clearColor, clearAlpha) {
  if (SSAARenderPass === void 0) {
    console.error("THREE.TAARenderPass relies on SSAARenderPass");
  }
  SSAARenderPass.call(this, scene, camera, clearColor, clearAlpha);
  this.sampleLevel = 0;
  this.accumulate = false;
};
TAARenderPass.JitterVectors = SSAARenderPass.JitterVectors;
TAARenderPass.prototype = Object.assign(Object.create(SSAARenderPass.prototype), {
  constructor: TAARenderPass,
  render: function(renderer, writeBuffer, readBuffer, deltaTime) {
    if (!this.accumulate) {
      SSAARenderPass.prototype.render.call(this, renderer, writeBuffer, readBuffer, deltaTime);
      this.accumulateIndex = -1;
      return;
    }
    var jitterOffsets = TAARenderPass.JitterVectors[5];
    if (!this.sampleRenderTarget) {
      this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);
      this.sampleRenderTarget.texture.name = "TAARenderPass.sample";
    }
    if (!this.holdRenderTarget) {
      this.holdRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);
      this.holdRenderTarget.texture.name = "TAARenderPass.hold";
    }
    if (this.accumulate && this.accumulateIndex === -1) {
      SSAARenderPass.prototype.render.call(this, renderer, this.holdRenderTarget, readBuffer, deltaTime);
      this.accumulateIndex = 0;
    }
    var autoClear = renderer.autoClear;
    renderer.autoClear = false;
    var sampleWeight = 1 / jitterOffsets.length;
    if (this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length) {
      this.copyUniforms["opacity"].value = sampleWeight;
      this.copyUniforms["tDiffuse"].value = writeBuffer.texture;
      var numSamplesPerFrame = Math.pow(2, this.sampleLevel);
      for (let i2 = 0; i2 < numSamplesPerFrame; i2++) {
        var j2 = this.accumulateIndex;
        var jitterOffset = jitterOffsets[j2];
        if (this.camera.setViewOffset) {
          this.camera.setViewOffset(
            readBuffer.width,
            readBuffer.height,
            jitterOffset[0] * 0.0625,
            jitterOffset[1] * 0.0625,
            readBuffer.width,
            readBuffer.height
          );
        }
        renderer.setRenderTarget(writeBuffer);
        renderer.clear();
        renderer.render(this.scene, this.camera);
        renderer.setRenderTarget(this.sampleRenderTarget);
        if (this.accumulateIndex === 0)
          renderer.clear();
        this.fsQuad.render(renderer);
        this.accumulateIndex++;
        if (this.accumulateIndex >= jitterOffsets.length)
          break;
      }
      if (this.camera.clearViewOffset)
        this.camera.clearViewOffset();
    }
    var accumulationWeight = this.accumulateIndex * sampleWeight;
    if (accumulationWeight > 0) {
      this.copyUniforms["opacity"].value = 1;
      this.copyUniforms["tDiffuse"].value = this.sampleRenderTarget.texture;
      renderer.setRenderTarget(writeBuffer);
      renderer.clear();
      this.fsQuad.render(renderer);
    }
    if (accumulationWeight < 1) {
      this.copyUniforms["opacity"].value = 1 - accumulationWeight;
      this.copyUniforms["tDiffuse"].value = this.holdRenderTarget.texture;
      renderer.setRenderTarget(writeBuffer);
      if (accumulationWeight === 0)
        renderer.clear();
      this.fsQuad.render(renderer);
    }
    renderer.autoClear = autoClear;
  }
});

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/ConvolutionShader.js
var ConvolutionShader = {
  defines: {
    KERNEL_SIZE_FLOAT: "25.0",
    KERNEL_SIZE_INT: "25"
  },
  uniforms: {
    tDiffuse: {
      value: null
    },
    uImageIncrement: {
      value: new Vector2(1953125e-9, 0)
    },
    cKernel: {
      value: []
    }
  },
  vertexShader: ["uniform vec2 uImageIncrement;", "varying vec2 vUv;", "void main() {", "	vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float cKernel[ KERNEL_SIZE_INT ];", "uniform sampler2D tDiffuse;", "uniform vec2 uImageIncrement;", "varying vec2 vUv;", "void main() {", "	vec2 imageCoord = vUv;", "	vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );", "	for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {", "		sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];", "		imageCoord += uImageIncrement;", "	}", "	gl_FragColor = sum;", "}"].join("\n"),
  buildKernel: function(sigma) {
    function gauss(x, sigma2) {
      return Math.exp(-(x * x) / (2 * sigma2 * sigma2));
    }
    const kMaxKernelSize = 25;
    const kernelSize = Math.min(2 * Math.ceil(sigma * 3) + 1, kMaxKernelSize);
    const halfWidth = (kernelSize - 1) * 0.5;
    const values = new Array(kernelSize);
    let sum = 0;
    for (let i2 = 0; i2 < kernelSize; ++i2) {
      values[i2] = gauss(i2 - halfWidth, sigma);
      sum += values[i2];
    }
    for (let i2 = 0; i2 < kernelSize; ++i2)
      values[i2] /= sum;
    return values;
  }
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/loaders/GLTFLoader.js
var _q = new Quaternion();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/webxr/OculusHandPointerModel.js
var YAXIS = new Vector3(0, 1, 0);
var ZAXIS = new Vector3(0, 0, 1);

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/webxr/VRButton.js
var VRButton = class {
  static createButton(renderer, sessionInit = {}) {
    const button = document.createElement("button");
    function showEnterVR() {
      let currentSession = null;
      async function onSessionStarted(session) {
        session.addEventListener("end", onSessionEnded);
        await renderer.xr.setSession(session);
        button.textContent = "EXIT VR";
        currentSession = session;
      }
      function onSessionEnded() {
        currentSession.removeEventListener("end", onSessionEnded);
        button.textContent = "ENTER VR";
        currentSession = null;
      }
      button.style.display = "";
      button.style.cursor = "pointer";
      button.style.left = "calc(50% - 50px)";
      button.style.width = "100px";
      button.textContent = "ENTER VR";
      button.onmouseenter = () => {
        button.style.opacity = "1.0";
      };
      button.onmouseleave = () => {
        button.style.opacity = "0.5";
      };
      button.onclick = () => {
        if (currentSession === null) {
          var _xr;
          const optionalFeatures = [sessionInit.optionalFeatures, "local-floor", "bounded-floor", "hand-tracking"].flat().filter(Boolean);
          (_xr = navigator.xr) === null || _xr === void 0 ? void 0 : _xr.requestSession("immersive-vr", {
            ...sessionInit,
            optionalFeatures
          }).then(onSessionStarted);
        } else {
          currentSession.end();
        }
      };
    }
    function disableButton() {
      button.style.display = "";
      button.style.cursor = "auto";
      button.style.left = "calc(50% - 75px)";
      button.style.width = "150px";
      button.onmouseenter = null;
      button.onmouseleave = null;
      button.onclick = null;
    }
    function showWebXRNotFound() {
      disableButton();
      button.textContent = "VR NOT SUPPORTED";
    }
    function stylizeElement(element2) {
      element2.style.position = "absolute";
      element2.style.bottom = "20px";
      element2.style.padding = "12px 6px";
      element2.style.border = "1px solid #fff";
      element2.style.borderRadius = "4px";
      element2.style.background = "rgba(0,0,0,0.1)";
      element2.style.color = "#fff";
      element2.style.font = "normal 13px sans-serif";
      element2.style.textAlign = "center";
      element2.style.opacity = "0.5";
      element2.style.outline = "none";
      element2.style.zIndex = "999";
    }
    if ("xr" in navigator) {
      stylizeElement(button);
      button.id = "VRButton";
      button.style.display = "none";
      navigator.xr.isSessionSupported("immersive-vr").then((supported) => {
        supported ? showEnterVR() : showWebXRNotFound();
        if (supported && VRButton.xrSessionIsGranted) {
          button.click();
        }
      });
      return button;
    } else {
      const message = document.createElement("a");
      if (window.isSecureContext === false) {
        message.href = document.location.href.replace(/^http:/, "https:");
        message.innerHTML = "WEBXR NEEDS HTTPS";
      } else {
        message.href = "https://immersiveweb.dev/";
        message.innerHTML = "WEBXR NOT AVAILABLE";
      }
      message.style.left = "calc(50% - 90px)";
      message.style.width = "180px";
      message.style.textDecoration = "none";
      stylizeElement(message);
      return message;
    }
  }
  static registerSessionGrantedListener() {
    if ("xr" in navigator) {
      navigator.xr.addEventListener("sessiongranted", () => {
        VRButton.xrSessionIsGranted = true;
      });
    }
  }
};
_defineProperty(VRButton, "xrSessionIsGranted", false);

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/libs/MotionControllers.js
var MotionControllerConstants = {
  Handedness: Object.freeze({
    NONE: "none",
    LEFT: "left",
    RIGHT: "right"
  }),
  ComponentState: Object.freeze({
    DEFAULT: "default",
    TOUCHED: "touched",
    PRESSED: "pressed"
  }),
  ComponentProperty: Object.freeze({
    BUTTON: "button",
    X_AXIS: "xAxis",
    Y_AXIS: "yAxis",
    STATE: "state"
  }),
  ComponentType: Object.freeze({
    TRIGGER: "trigger",
    SQUEEZE: "squeeze",
    TOUCHPAD: "touchpad",
    THUMBSTICK: "thumbstick",
    BUTTON: "button"
  }),
  ButtonTouchThreshold: 0.05,
  AxisTouchThreshold: 0.1,
  VisualResponseProperty: Object.freeze({
    TRANSFORM: "transform",
    VISIBILITY: "visibility"
  })
};
var defaultComponentValues = {
  xAxis: 0,
  yAxis: 0,
  button: 0,
  state: MotionControllerConstants.ComponentState.DEFAULT
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/webxr/XRHandPrimitiveModel.js
var _matrix = new Matrix4();
var _vector = new Vector3();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/geometries/ParametricGeometry.js
var ParametricGeometry = class extends BufferGeometry {
  constructor(func = (u, v3, target) => target.set(u, v3, Math.cos(u) * Math.sin(v3)), slices = 8, stacks = 8) {
    super();
    this.type = "ParametricGeometry";
    this.parameters = {
      func,
      slices,
      stacks
    };
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const EPS = 1e-5;
    const normal = new Vector3();
    const p0 = new Vector3(), p1 = new Vector3();
    const pu = new Vector3(), pv = new Vector3();
    const sliceCount = slices + 1;
    for (let i2 = 0; i2 <= stacks; i2++) {
      const v3 = i2 / stacks;
      for (let j2 = 0; j2 <= slices; j2++) {
        const u = j2 / slices;
        func(u, v3, p0);
        vertices.push(p0.x, p0.y, p0.z);
        if (u - EPS >= 0) {
          func(u - EPS, v3, p1);
          pu.subVectors(p0, p1);
        } else {
          func(u + EPS, v3, p1);
          pu.subVectors(p1, p0);
        }
        if (v3 - EPS >= 0) {
          func(u, v3 - EPS, p1);
          pv.subVectors(p0, p1);
        } else {
          func(u, v3 + EPS, p1);
          pv.subVectors(p1, p0);
        }
        normal.crossVectors(pu, pv).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u, v3);
      }
    }
    for (let i2 = 0; i2 < stacks; i2++) {
      for (let j2 = 0; j2 < slices; j2++) {
        const a2 = i2 * sliceCount + j2;
        const b2 = i2 * sliceCount + j2 + 1;
        const c2 = (i2 + 1) * sliceCount + j2 + 1;
        const d = (i2 + 1) * sliceCount + j2;
        indices.push(a2, b2, d);
        indices.push(b2, c2, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/geometries/ParametricGeometries.js
var ParametricGeometries = {
  klein: function(v3, u, target) {
    u *= Math.PI;
    v3 *= 2 * Math.PI;
    u = u * 2;
    let x, z;
    if (u < Math.PI) {
      x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(u) * Math.cos(v3);
      z = -8 * Math.sin(u) - 2 * (1 - Math.cos(u) / 2) * Math.sin(u) * Math.cos(v3);
    } else {
      x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(v3 + Math.PI);
      z = -8 * Math.sin(u);
    }
    const y = -2 * (1 - Math.cos(u) / 2) * Math.sin(v3);
    target.set(x, y, z);
  },
  plane: function(width, height) {
    return function(u, v3, target) {
      const x = u * width;
      const y = 0;
      const z = v3 * height;
      target.set(x, y, z);
    };
  },
  mobius: function(u, t2, target) {
    u = u - 0.5;
    const v3 = 2 * Math.PI * t2;
    const a2 = 2;
    const x = Math.cos(v3) * (a2 + u * Math.cos(v3 / 2));
    const y = Math.sin(v3) * (a2 + u * Math.cos(v3 / 2));
    const z = u * Math.sin(v3 / 2);
    target.set(x, y, z);
  },
  mobius3d: function(u, t2, target) {
    u *= Math.PI;
    t2 *= 2 * Math.PI;
    u = u * 2;
    const phi = u / 2;
    const major = 2.25, a2 = 0.125, b2 = 0.65;
    let x = a2 * Math.cos(t2) * Math.cos(phi) - b2 * Math.sin(t2) * Math.sin(phi);
    const z = a2 * Math.cos(t2) * Math.sin(phi) + b2 * Math.sin(t2) * Math.cos(phi);
    const y = (major + x) * Math.sin(u);
    x = (major + x) * Math.cos(u);
    target.set(x, y, z);
  }
};
ParametricGeometries.TubeGeometry = class TubeGeometry extends ParametricGeometry {
  constructor(path, segments = 64, radius = 1, segmentsRadius = 8, closed = false) {
    const numpoints = segments + 1;
    const frames = path.computeFrenetFrames(segments, closed), tangents = frames.tangents, normals = frames.normals, binormals = frames.binormals;
    const position = new Vector3();
    function ParametricTube(u, v3, target) {
      v3 *= 2 * Math.PI;
      const i2 = Math.floor(u * (numpoints - 1));
      path.getPointAt(u, position);
      const normal = normals[i2];
      const binormal = binormals[i2];
      const cx = -radius * Math.cos(v3);
      const cy = radius * Math.sin(v3);
      position.x += cx * normal.x + cy * binormal.x;
      position.y += cx * normal.y + cy * binormal.y;
      position.z += cx * normal.z + cy * binormal.z;
      target.copy(position);
    }
    super(ParametricTube, segments, segmentsRadius);
    this.tangents = tangents;
    this.normals = normals;
    this.binormals = binormals;
    this.path = path;
    this.segments = segments;
    this.radius = radius;
    this.segmentsRadius = segmentsRadius;
    this.closed = closed;
  }
};
ParametricGeometries.TorusKnotGeometry = class TorusKnotGeometry extends ParametricGeometries.TubeGeometry {
  constructor(radius = 200, tube = 40, segmentsT = 64, segmentsR = 8, p = 2, q = 3) {
    class TorusKnotCurve extends Curve {
      getPoint(t2, optionalTarget = new Vector3()) {
        const point = optionalTarget;
        t2 *= Math.PI * 2;
        const r = 0.5;
        const x = (1 + r * Math.cos(q * t2)) * Math.cos(p * t2);
        const y = (1 + r * Math.cos(q * t2)) * Math.sin(p * t2);
        const z = r * Math.sin(q * t2);
        return point.set(x, y, z).multiplyScalar(radius);
      }
    }
    const segments = segmentsT;
    const radiusSegments = segmentsR;
    const extrudePath = new TorusKnotCurve();
    super(extrudePath, segments, tube, radiusSegments, true, false);
    this.radius = radius;
    this.tube = tube;
    this.segmentsT = segmentsT;
    this.segmentsR = segmentsR;
    this.p = p;
    this.q = q;
  }
};
ParametricGeometries.SphereGeometry = class SphereGeometry2 extends ParametricGeometry {
  constructor(size2, u, v3) {
    function sphere(u2, v4, target) {
      u2 *= Math.PI;
      v4 *= 2 * Math.PI;
      const x = size2 * Math.sin(u2) * Math.cos(v4);
      const y = size2 * Math.sin(u2) * Math.sin(v4);
      const z = size2 * Math.cos(u2);
      target.set(x, y, z);
    }
    super(sphere, u, v3);
  }
};
ParametricGeometries.PlaneGeometry = class PlaneGeometry2 extends ParametricGeometry {
  constructor(width, depth, segmentsWidth, segmentsDepth) {
    function plane(u, v3, target) {
      const x = u * width;
      const y = 0;
      const z = v3 * depth;
      target.set(x, y, z);
    }
    super(plane, segmentsWidth, segmentsDepth);
  }
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/geometries/RoundedBoxGeometry.js
var tempNormal = new Vector3();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/csm/CSMFrustum.js
var inverseProjectionMatrix = new Matrix4();
var CSMFrustum = class {
  constructor(data) {
    data = data || {};
    this.vertices = {
      near: [new Vector3(), new Vector3(), new Vector3(), new Vector3()],
      far: [new Vector3(), new Vector3(), new Vector3(), new Vector3()]
    };
    if (data.projectionMatrix !== void 0) {
      this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 1e4);
    }
  }
  setFromProjectionMatrix(projectionMatrix, maxFar) {
    const isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0;
    inverseProjectionMatrix.copy(projectionMatrix).invert();
    this.vertices.near[0].set(1, 1, -1);
    this.vertices.near[1].set(1, -1, -1);
    this.vertices.near[2].set(-1, -1, -1);
    this.vertices.near[3].set(-1, 1, -1);
    this.vertices.near.forEach(function(v3) {
      v3.applyMatrix4(inverseProjectionMatrix);
    });
    this.vertices.far[0].set(1, 1, 1);
    this.vertices.far[1].set(1, -1, 1);
    this.vertices.far[2].set(-1, -1, 1);
    this.vertices.far[3].set(-1, 1, 1);
    this.vertices.far.forEach(function(v3) {
      v3.applyMatrix4(inverseProjectionMatrix);
      const absZ = Math.abs(v3.z);
      if (isOrthographic) {
        v3.z *= Math.min(maxFar / absZ, 1);
      } else {
        v3.multiplyScalar(Math.min(maxFar / absZ, 1));
      }
    });
    return this.vertices;
  }
  split(breaks, target) {
    while (breaks.length > target.length) {
      target.push(new CSMFrustum());
    }
    target.length = breaks.length;
    for (let i2 = 0; i2 < breaks.length; i2++) {
      const cascade = target[i2];
      if (i2 === 0) {
        for (let j2 = 0; j2 < 4; j2++) {
          cascade.vertices.near[j2].copy(this.vertices.near[j2]);
        }
      } else {
        for (let j2 = 0; j2 < 4; j2++) {
          cascade.vertices.near[j2].lerpVectors(this.vertices.near[j2], this.vertices.far[j2], breaks[i2 - 1]);
        }
      }
      if (i2 === breaks.length - 1) {
        for (let j2 = 0; j2 < 4; j2++) {
          cascade.vertices.far[j2].copy(this.vertices.far[j2]);
        }
      } else {
        for (let j2 = 0; j2 < 4; j2++) {
          cascade.vertices.far[j2].lerpVectors(this.vertices.near[j2], this.vertices.far[j2], breaks[i2]);
        }
      }
    }
  }
  toSpace(cameraMatrix, target) {
    for (let i2 = 0; i2 < 4; i2++) {
      target.vertices.near[i2].copy(this.vertices.near[i2]).applyMatrix4(cameraMatrix);
      target.vertices.far[i2].copy(this.vertices.far[i2]).applyMatrix4(cameraMatrix);
    }
  }
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/csm/CSMShader.js
var CSMShader = {
  lights_fragment_begin: `
GeometricContext geometry;

geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

#ifdef CLEARCOAT

	geometry.clearcoatNormal = clearcoatNormal;

#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointLightInfo( pointLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotLightInfo( spotLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	float linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )
	vec2 cascade;
	float cascadeCenter;
	float closestEdge;
	float margin;
	float csmx;
	float csmy;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );

	  	#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
			// NOTE: Depth gets larger away from the camera.
			// cascade.x is closer, cascade.y is further
			cascade = CSM_cascades[ i ];
			cascadeCenter = ( cascade.x + cascade.y ) / 2.0;
			closestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;
			margin = 0.25 * pow( closestEdge, 2.0 );
			csmx = cascade.x - margin / 2.0;
			csmy = cascade.y + margin / 2.0;
			if( linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {

				float dist = min( linearDepth - csmx, csmy - linearDepth );
				float ratio = clamp( dist / margin, 0.0, 1.0 );

				vec3 prevColor = directLight.color;
				directionalLightShadow = directionalLightShadows[ i ];
				directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

				bool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;
				directLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );

				ReflectedLight prevLight = reflectedLight;
				RE_Direct( directLight, geometry, material, reflectedLight );

				bool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;
				float blendRatio = shouldBlend ? ratio : 1.0;

				reflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );
				reflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );
				reflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );
				reflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );

			}
	  	#endif

	}
	#pragma unroll_loop_end
	#else

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];
			getDirectionalLightInfo( directionalLight, geometry, directLight );

			#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )

			directionalLightShadow = directionalLightShadows[ i ];
			if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

			if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometry, material, reflectedLight );

			#endif

		}
		#pragma unroll_loop_end

	#endif

	#if ( NUM_DIR_LIGHTS > NUM_DIR_LIGHT_SHADOWS)
		// compute the lights not casting shadows (if any)

		#pragma unroll_loop_start
		for ( int i = NUM_DIR_LIGHT_SHADOWS; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];

			getDirectionalLightInfo( directionalLight, geometry, directLight );

			RE_Direct( directLight, geometry, material, reflectedLight );

		}
		#pragma unroll_loop_end

	#endif

#endif


#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalLightInfo( directionalLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`,
  lights_pars_begin: `
#if defined( USE_CSM ) && defined( CSM_CASCADES )
uniform vec2 CSM_cascades[CSM_CASCADES];
uniform float cameraNear;
uniform float shadowFar;
#endif
	` + ShaderChunk.lights_pars_begin
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/csm/CSM.js
var _cameraToLightMatrix = new Matrix4();
var _lightSpaceFrustum = new CSMFrustum();
var _center = new Vector3();
var _bbox = new Box3();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/ACESFilmicToneMappingShader.js
var ACESFilmicToneMappingShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    exposure: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "#define saturate(a) clamp( a, 0.0, 1.0 )",
    "uniform sampler2D tDiffuse;",
    "uniform float exposure;",
    "varying vec2 vUv;",
    "vec3 RRTAndODTFit( vec3 v ) {",
    "	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;",
    "	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;",
    "	return a / b;",
    "}",
    "vec3 ACESFilmicToneMapping( vec3 color ) {",
    "	const mat3 ACESInputMat = mat3(",
    "		vec3( 0.59719, 0.07600, 0.02840 ),",
    "		vec3( 0.35458, 0.90834, 0.13383 ),",
    "		vec3( 0.04823, 0.01566, 0.83777 )",
    "	);",
    "	const mat3 ACESOutputMat = mat3(",
    "		vec3(  1.60475, -0.10208, -0.00327 ),",
    "		vec3( -0.53108,  1.10813, -0.07276 ),",
    "		vec3( -0.07367, -0.00605,  1.07602 )",
    "	);",
    "	color = ACESInputMat * color;",
    "	color = RRTAndODTFit( color );",
    "	color = ACESOutputMat * color;",
    "	return saturate( color );",
    "}",
    "void main() {",
    "	vec4 tex = texture2D( tDiffuse, vUv );",
    "	tex.rgb *= exposure / 0.6;",
    "	gl_FragColor = vec4( ACESFilmicToneMapping( tex.rgb ), tex.a );",
    "}"
  ].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/BasicShader.js
var BasicShader = {
  uniforms: {},
  vertexShader: ["void main() {", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["void main() {", "	gl_FragColor = vec4( 1.0, 0.0, 0.0, 0.5 );", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/BleachBypassShader.js
var BleachBypassShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    opacity: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 base = texture2D( tDiffuse, vUv );", "	vec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );", "	float lum = dot( lumCoeff, base.rgb );", "	vec3 blend = vec3( lum );", "	float L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );", "	vec3 result1 = 2.0 * base.rgb * blend;", "	vec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );", "	vec3 newColor = mix( result1, result2, L );", "	float A2 = opacity * base.a;", "	vec3 mixRGB = A2 * newColor.rgb;", "	mixRGB += ( ( 1.0 - A2 ) * base.rgb );", "	gl_FragColor = vec4( mixRGB, base.a );", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/BlendShader.js
var BlendShader = {
  uniforms: {
    tDiffuse1: {
      value: null
    },
    tDiffuse2: {
      value: null
    },
    mixRatio: {
      value: 0.5
    },
    opacity: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float opacity;", "uniform float mixRatio;", "uniform sampler2D tDiffuse1;", "uniform sampler2D tDiffuse2;", "varying vec2 vUv;", "void main() {", "	vec4 texel1 = texture2D( tDiffuse1, vUv );", "	vec4 texel2 = texture2D( tDiffuse2, vUv );", "	gl_FragColor = opacity * mix( texel1, texel2, mixRatio );", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/BrightnessContrastShader.js
var BrightnessContrastShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    brightness: {
      value: 0
    },
    contrast: {
      value: 0
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float brightness;", "uniform float contrast;", "varying vec2 vUv;", "void main() {", "	gl_FragColor = texture2D( tDiffuse, vUv );", "	gl_FragColor.rgb += brightness;", "	if (contrast > 0.0) {", "		gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) / (1.0 - contrast) + 0.5;", "	} else {", "		gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) * (1.0 + contrast) + 0.5;", "	}", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/ColorCorrectionShader.js
var ColorCorrectionShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    powRGB: {
      value: new Vector3(2, 2, 2)
    },
    mulRGB: {
      value: new Vector3(1, 1, 1)
    },
    addRGB: {
      value: new Vector3(0, 0, 0)
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform vec3 powRGB;", "uniform vec3 mulRGB;", "uniform vec3 addRGB;", "varying vec2 vUv;", "void main() {", "	gl_FragColor = texture2D( tDiffuse, vUv );", "	gl_FragColor.rgb = mulRGB * pow( ( gl_FragColor.rgb + addRGB ), powRGB );", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/ColorifyShader.js
var ColorifyShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    color: {
      value: new Color(16777215)
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform vec3 color;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 texel = texture2D( tDiffuse, vUv );", "	vec3 luma = vec3( 0.299, 0.587, 0.114 );", "	float v = dot( texel.xyz, luma );", "	gl_FragColor = vec4( v * color, texel.w );", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/DOFMipMapShader.js
var DOFMipMapShader = {
  uniforms: {
    tColor: {
      value: null
    },
    tDepth: {
      value: null
    },
    focus: {
      value: 1
    },
    maxblur: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float focus;", "uniform float maxblur;", "uniform sampler2D tColor;", "uniform sampler2D tDepth;", "varying vec2 vUv;", "void main() {", "	vec4 depth = texture2D( tDepth, vUv );", "	float factor = depth.x - focus;", "	vec4 col = texture2D( tColor, vUv, 2.0 * maxblur * abs( focus - depth.x ) );", "	gl_FragColor = col;", "	gl_FragColor.a = 1.0;", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/FXAAShader.js
var FXAAShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    resolution: {
      value: new Vector2(1 / 1024, 1 / 512)
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["precision highp float;", "", "uniform sampler2D tDiffuse;", "", "uniform vec2 resolution;", "", "varying vec2 vUv;", "", "// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)", "", "//----------------------------------------------------------------------------------", "// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag", "// SDK Version: v3.00", "// Email:       gameworks@nvidia.com", "// Site:        http://developer.nvidia.com/", "//", "// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.", "//", "// Redistribution and use in source and binary forms, with or without", "// modification, are permitted provided that the following conditions", "// are met:", "//  * Redistributions of source code must retain the above copyright", "//    notice, this list of conditions and the following disclaimer.", "//  * Redistributions in binary form must reproduce the above copyright", "//    notice, this list of conditions and the following disclaimer in the", "//    documentation and/or other materials provided with the distribution.", "//  * Neither the name of NVIDIA CORPORATION nor the names of its", "//    contributors may be used to endorse or promote products derived", "//    from this software without specific prior written permission.", "//", "// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY", "// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", "// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR", "// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR", "// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,", "// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,", "// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR", "// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY", "// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT", "// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE", "// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.", "//", "//----------------------------------------------------------------------------------", "", "#define FXAA_PC 1", "#define FXAA_GLSL_100 1", "#define FXAA_QUALITY_PRESET 12", "", "#define FXAA_GREEN_AS_LUMA 1", "", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_PC_CONSOLE", "    //", "    // The console algorithm for PC is included", "    // for developers targeting really low spec machines.", "    // Likely better to just run FXAA_PC, and use a really low preset.", "    //", "    #define FXAA_PC_CONSOLE 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_GLSL_120", "    #define FXAA_GLSL_120 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_GLSL_130", "    #define FXAA_GLSL_130 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_HLSL_3", "    #define FXAA_HLSL_3 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_HLSL_4", "    #define FXAA_HLSL_4 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_HLSL_5", "    #define FXAA_HLSL_5 0", "#endif", "/*==========================================================================*/", "#ifndef FXAA_GREEN_AS_LUMA", "    //", "    // For those using non-linear color,", "    // and either not able to get luma in alpha, or not wanting to,", "    // this enables FXAA to run using green as a proxy for luma.", "    // So with this enabled, no need to pack luma in alpha.", "    //", "    // This will turn off AA on anything which lacks some amount of green.", "    // Pure red and blue or combination of only R and B, will get no AA.", "    //", "    // Might want to lower the settings for both,", "    //    fxaaConsoleEdgeThresholdMin", "    //    fxaaQualityEdgeThresholdMin", "    // In order to insure AA does not get turned off on colors", "    // which contain a minor amount of green.", "    //", "    // 1 = On.", "    // 0 = Off.", "    //", "    #define FXAA_GREEN_AS_LUMA 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_EARLY_EXIT", "    //", "    // Controls algorithm's early exit path.", "    // On PS3 turning this ON adds 2 cycles to the shader.", "    // On 360 turning this OFF adds 10ths of a millisecond to the shader.", "    // Turning this off on console will result in a more blurry image.", "    // So this defaults to on.", "    //", "    // 1 = On.", "    // 0 = Off.", "    //", "    #define FXAA_EARLY_EXIT 1", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_DISCARD", "    //", "    // Only valid for PC OpenGL currently.", "    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.", "    //", "    // 1 = Use discard on pixels which don't need AA.", "    //     For APIs which enable concurrent TEX+ROP from same surface.", "    // 0 = Return unchanged color on pixels which don't need AA.", "    //", "    #define FXAA_DISCARD 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_FAST_PIXEL_OFFSET", "    //", "    // Used for GLSL 120 only.", "    //", "    // 1 = GL API supports fast pixel offsets", "    // 0 = do not use fast pixel offsets", "    //", "    #ifdef GL_EXT_gpu_shader4", "        #define FXAA_FAST_PIXEL_OFFSET 1", "    #endif", "    #ifdef GL_NV_gpu_shader5", "        #define FXAA_FAST_PIXEL_OFFSET 1", "    #endif", "    #ifdef GL_ARB_gpu_shader5", "        #define FXAA_FAST_PIXEL_OFFSET 1", "    #endif", "    #ifndef FXAA_FAST_PIXEL_OFFSET", "        #define FXAA_FAST_PIXEL_OFFSET 0", "    #endif", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_GATHER4_ALPHA", "    //", "    // 1 = API supports gather4 on alpha channel.", "    // 0 = API does not support gather4 on alpha channel.", "    //", "    #if (FXAA_HLSL_5 == 1)", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifdef GL_ARB_gpu_shader5", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifdef GL_NV_gpu_shader5", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifndef FXAA_GATHER4_ALPHA", "        #define FXAA_GATHER4_ALPHA 0", "    #endif", "#endif", "", "", "/*============================================================================", "                        FXAA QUALITY - TUNING KNOBS", "------------------------------------------------------------------------------", "NOTE the other tuning knobs are now in the shader function inputs!", "============================================================================*/", "#ifndef FXAA_QUALITY_PRESET", "    //", "    // Choose the quality preset.", "    // This needs to be compiled into the shader as it effects code.", "    // Best option to include multiple presets is to", "    // in each shader define the preset, then include this file.", "    //", "    // OPTIONS", "    // -----------------------------------------------------------------------", "    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)", "    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)", "    // 39       - no dither, very expensive", "    //", "    // NOTES", "    // -----------------------------------------------------------------------", "    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)", "    // 13 = about same speed as FXAA 3.9 and better than 12", "    // 23 = closest to FXAA 3.9 visually and performance wise", "    //  _ = the lowest digit is directly related to performance", "    // _  = the highest digit is directly related to style", "    //", "    #define FXAA_QUALITY_PRESET 12", "#endif", "", "", "/*============================================================================", "", "                           FXAA QUALITY - PRESETS", "", "============================================================================*/", "", "/*============================================================================", "                     FXAA QUALITY - MEDIUM DITHER PRESETS", "============================================================================*/", "#if (FXAA_QUALITY_PRESET == 10)", "    #define FXAA_QUALITY_PS 3", "    #define FXAA_QUALITY_P0 1.5", "    #define FXAA_QUALITY_P1 3.0", "    #define FXAA_QUALITY_P2 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 11)", "    #define FXAA_QUALITY_PS 4", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 3.0", "    #define FXAA_QUALITY_P3 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 12)", "    #define FXAA_QUALITY_PS 5", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 4.0", "    #define FXAA_QUALITY_P4 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 13)", "    #define FXAA_QUALITY_PS 6", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 4.0", "    #define FXAA_QUALITY_P5 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 14)", "    #define FXAA_QUALITY_PS 7", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 4.0", "    #define FXAA_QUALITY_P6 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 15)", "    #define FXAA_QUALITY_PS 8", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 4.0", "    #define FXAA_QUALITY_P7 12.0", "#endif", "", "/*============================================================================", "                     FXAA QUALITY - LOW DITHER PRESETS", "============================================================================*/", "#if (FXAA_QUALITY_PRESET == 20)", "    #define FXAA_QUALITY_PS 3", "    #define FXAA_QUALITY_P0 1.5", "    #define FXAA_QUALITY_P1 2.0", "    #define FXAA_QUALITY_P2 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 21)", "    #define FXAA_QUALITY_PS 4", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 22)", "    #define FXAA_QUALITY_PS 5", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 23)", "    #define FXAA_QUALITY_PS 6", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 24)", "    #define FXAA_QUALITY_PS 7", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 3.0", "    #define FXAA_QUALITY_P6 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 25)", "    #define FXAA_QUALITY_PS 8", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 4.0", "    #define FXAA_QUALITY_P7 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 26)", "    #define FXAA_QUALITY_PS 9", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 4.0", "    #define FXAA_QUALITY_P8 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 27)", "    #define FXAA_QUALITY_PS 10", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 4.0", "    #define FXAA_QUALITY_P9 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 28)", "    #define FXAA_QUALITY_PS 11", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 4.0", "    #define FXAA_QUALITY_P10 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 29)", "    #define FXAA_QUALITY_PS 12", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 2.0", "    #define FXAA_QUALITY_P10 4.0", "    #define FXAA_QUALITY_P11 8.0", "#endif", "", "/*============================================================================", "                     FXAA QUALITY - EXTREME QUALITY", "============================================================================*/", "#if (FXAA_QUALITY_PRESET == 39)", "    #define FXAA_QUALITY_PS 12", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.0", "    #define FXAA_QUALITY_P2 1.0", "    #define FXAA_QUALITY_P3 1.0", "    #define FXAA_QUALITY_P4 1.0", "    #define FXAA_QUALITY_P5 1.5", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 2.0", "    #define FXAA_QUALITY_P10 4.0", "    #define FXAA_QUALITY_P11 8.0", "#endif", "", "", "", "/*============================================================================", "", "                                API PORTING", "", "============================================================================*/", "#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)", "    #define FxaaBool bool", "    #define FxaaDiscard discard", "    #define FxaaFloat float", "    #define FxaaFloat2 vec2", "    #define FxaaFloat3 vec3", "    #define FxaaFloat4 vec4", "    #define FxaaHalf float", "    #define FxaaHalf2 vec2", "    #define FxaaHalf3 vec3", "    #define FxaaHalf4 vec4", "    #define FxaaInt2 ivec2", "    #define FxaaSat(x) clamp(x, 0.0, 1.0)", "    #define FxaaTex sampler2D", "#else", "    #define FxaaBool bool", "    #define FxaaDiscard clip(-1)", "    #define FxaaFloat float", "    #define FxaaFloat2 float2", "    #define FxaaFloat3 float3", "    #define FxaaFloat4 float4", "    #define FxaaHalf half", "    #define FxaaHalf2 half2", "    #define FxaaHalf3 half3", "    #define FxaaHalf4 half4", "    #define FxaaSat(x) saturate(x)", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_GLSL_100 == 1)", "  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)", "  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_GLSL_120 == 1)", "    // Requires,", "    //  #version 120", "    // And at least,", "    //  #extension GL_EXT_gpu_shader4 : enable", "    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)", "    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)", "    #if (FXAA_FAST_PIXEL_OFFSET == 1)", "        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)", "    #else", "        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)", "    #endif", "    #if (FXAA_GATHER4_ALPHA == 1)", "        // use #extension GL_ARB_gpu_shader5 : enable", "        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)", "        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)", "        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)", "        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)", "    #endif", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_GLSL_130 == 1)", '    // Requires "#version 130" or better', "    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)", "    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)", "    #if (FXAA_GATHER4_ALPHA == 1)", "        // use #extension GL_ARB_gpu_shader5 : enable", "        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)", "        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)", "        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)", "        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)", "    #endif", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_HLSL_3 == 1)", "    #define FxaaInt2 float2", "    #define FxaaTex sampler2D", "    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))", "    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_HLSL_4 == 1)", "    #define FxaaInt2 int2", "    struct FxaaTex { SamplerState smpl; Texture2D tex; };", "    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)", "    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_HLSL_5 == 1)", "    #define FxaaInt2 int2", "    struct FxaaTex { SamplerState smpl; Texture2D tex; };", "    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)", "    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)", "    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)", "    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)", "    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)", "    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)", "#endif", "", "", "/*============================================================================", "                   GREEN AS LUMA OPTION SUPPORT FUNCTION", "============================================================================*/", "#if (FXAA_GREEN_AS_LUMA == 0)", "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }", "#else", "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }", "#endif", "", "", "", "", "/*============================================================================", "", "                             FXAA3 QUALITY - PC", "", "============================================================================*/", "#if (FXAA_PC == 1)", "/*--------------------------------------------------------------------------*/", "FxaaFloat4 FxaaPixelShader(", "    //", "    // Use noperspective interpolation here (turn off perspective interpolation).", "    // {xy} = center of pixel", "    FxaaFloat2 pos,", "    //", "    // Used only for FXAA Console, and not used on the 360 version.", "    // Use noperspective interpolation here (turn off perspective interpolation).", "    // {xy_} = upper left of pixel", "    // {_zw} = lower right of pixel", "    FxaaFloat4 fxaaConsolePosPos,", "    //", "    // Input color texture.", "    // {rgb_} = color in linear or perceptual color space", "    // if (FXAA_GREEN_AS_LUMA == 0)", "    //     {__a} = luma in perceptual color space (not linear)", "    FxaaTex tex,", "    //", "    // Only used on the optimized 360 version of FXAA Console.", '    // For everything but 360, just use the same input here as for "tex".', "    // For 360, same texture, just alias with a 2nd sampler.", "    // This sampler needs to have an exponent bias of -1.", "    FxaaTex fxaaConsole360TexExpBiasNegOne,", "    //", "    // Only used on the optimized 360 version of FXAA Console.", '    // For everything but 360, just use the same input here as for "tex".', "    // For 360, same texture, just alias with a 3nd sampler.", "    // This sampler needs to have an exponent bias of -2.", "    FxaaTex fxaaConsole360TexExpBiasNegTwo,", "    //", "    // Only used on FXAA Quality.", "    // This must be from a constant/uniform.", "    // {x_} = 1.0/screenWidthInPixels", "    // {_y} = 1.0/screenHeightInPixels", "    FxaaFloat2 fxaaQualityRcpFrame,", "    //", "    // Only used on FXAA Console.", "    // This must be from a constant/uniform.", "    // This effects sub-pixel AA quality and inversely sharpness.", "    //   Where N ranges between,", "    //     N = 0.50 (default)", "    //     N = 0.33 (sharper)", "    // {x__} = -N/screenWidthInPixels", "    // {_y_} = -N/screenHeightInPixels", "    // {_z_} =  N/screenWidthInPixels", "    // {__w} =  N/screenHeightInPixels", "    FxaaFloat4 fxaaConsoleRcpFrameOpt,", "    //", "    // Only used on FXAA Console.", "    // Not used on 360, but used on PS3 and PC.", "    // This must be from a constant/uniform.", "    // {x__} = -2.0/screenWidthInPixels", "    // {_y_} = -2.0/screenHeightInPixels", "    // {_z_} =  2.0/screenWidthInPixels", "    // {__w} =  2.0/screenHeightInPixels", "    FxaaFloat4 fxaaConsoleRcpFrameOpt2,", "    //", "    // Only used on FXAA Console.", "    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.", "    // This must be from a constant/uniform.", "    // {x__} =  8.0/screenWidthInPixels", "    // {_y_} =  8.0/screenHeightInPixels", "    // {_z_} = -4.0/screenWidthInPixels", "    // {__w} = -4.0/screenHeightInPixels", "    FxaaFloat4 fxaaConsole360RcpFrameOpt2,", "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_SUBPIX define.", "    // It is here now to allow easier tuning.", "    // Choose the amount of sub-pixel aliasing removal.", "    // This can effect sharpness.", "    //   1.00 - upper limit (softer)", "    //   0.75 - default amount of filtering", "    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)", "    //   0.25 - almost off", "    //   0.00 - completely off", "    FxaaFloat fxaaQualitySubpix,", "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.", "    // It is here now to allow easier tuning.", "    // The minimum amount of local contrast required to apply algorithm.", "    //   0.333 - too little (faster)", "    //   0.250 - low quality", "    //   0.166 - default", "    //   0.125 - high quality", "    //   0.063 - overkill (slower)", "    FxaaFloat fxaaQualityEdgeThreshold,", "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.", "    // It is here now to allow easier tuning.", "    // Trims the algorithm from processing darks.", "    //   0.0833 - upper limit (default, the start of visible unfiltered edges)", "    //   0.0625 - high quality (faster)", "    //   0.0312 - visible limit (slower)", "    // Special notes when using FXAA_GREEN_AS_LUMA,", "    //   Likely want to set this to zero.", "    //   As colors that are mostly not-green", "    //   will appear very dark in the green channel!", "    //   Tune by looking at mostly non-green content,", "    //   then start at zero and increase until aliasing is a problem.", "    FxaaFloat fxaaQualityEdgeThresholdMin,", "    //", "    // Only used on FXAA Console.", "    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.", "    // It is here now to allow easier tuning.", "    // This does not effect PS3, as this needs to be compiled in.", "    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.", "    //   Due to the PS3 being ALU bound,", "    //   there are only three safe values here: 2 and 4 and 8.", "    //   These options use the shaders ability to a free *|/ by 2|4|8.", "    // For all other platforms can be a non-power of two.", "    //   8.0 is sharper (default!!!)", "    //   4.0 is softer", "    //   2.0 is really soft (good only for vector graphics inputs)", "    FxaaFloat fxaaConsoleEdgeSharpness,", "    //", "    // Only used on FXAA Console.", "    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.", "    // It is here now to allow easier tuning.", "    // This does not effect PS3, as this needs to be compiled in.", "    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.", "    //   Due to the PS3 being ALU bound,", "    //   there are only two safe values here: 1/4 and 1/8.", "    //   These options use the shaders ability to a free *|/ by 2|4|8.", "    // The console setting has a different mapping than the quality setting.", "    // Other platforms can use other values.", "    //   0.125 leaves less aliasing, but is softer (default!!!)", "    //   0.25 leaves more aliasing, and is sharper", "    FxaaFloat fxaaConsoleEdgeThreshold,", "    //", "    // Only used on FXAA Console.", "    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.", "    // It is here now to allow easier tuning.", "    // Trims the algorithm from processing darks.", "    // The console setting has a different mapping than the quality setting.", "    // This only applies when FXAA_EARLY_EXIT is 1.", "    // This does not apply to PS3,", "    // PS3 was simplified to avoid more shader instructions.", "    //   0.06 - faster but more aliasing in darks", "    //   0.05 - default", "    //   0.04 - slower and less aliasing in darks", "    // Special notes when using FXAA_GREEN_AS_LUMA,", "    //   Likely want to set this to zero.", "    //   As colors that are mostly not-green", "    //   will appear very dark in the green channel!", "    //   Tune by looking at mostly non-green content,", "    //   then start at zero and increase until aliasing is a problem.", "    FxaaFloat fxaaConsoleEdgeThresholdMin,", "    //", "    // Extra constants for 360 FXAA Console only.", "    // Use zeros or anything else for other platforms.", "    // These must be in physical constant registers and NOT immediates.", "    // Immediates will result in compiler un-optimizing.", "    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)", "    FxaaFloat4 fxaaConsole360ConstDir", ") {", "/*--------------------------------------------------------------------------*/", "    FxaaFloat2 posM;", "    posM.x = pos.x;", "    posM.y = pos.y;", "    #if (FXAA_GATHER4_ALPHA == 1)", "        #if (FXAA_DISCARD == 0)", "            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);", "            #if (FXAA_GREEN_AS_LUMA == 0)", "                #define lumaM rgbyM.w", "            #else", "                #define lumaM rgbyM.y", "            #endif", "        #endif", "        #if (FXAA_GREEN_AS_LUMA == 0)", "            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);", "            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));", "        #else", "            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);", "            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));", "        #endif", "        #if (FXAA_DISCARD == 1)", "            #define lumaM luma4A.w", "        #endif", "        #define lumaE luma4A.z", "        #define lumaS luma4A.x", "        #define lumaSE luma4A.y", "        #define lumaNW luma4B.w", "        #define lumaN luma4B.z", "        #define lumaW luma4B.x", "    #else", "        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);", "        #if (FXAA_GREEN_AS_LUMA == 0)", "            #define lumaM rgbyM.w", "        #else", "            #define lumaM rgbyM.y", "        #endif", "        #if (FXAA_GLSL_100 == 1)", "          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));", "        #else", "          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));", "        #endif", "    #endif", "/*--------------------------------------------------------------------------*/", "    FxaaFloat maxSM = max(lumaS, lumaM);", "    FxaaFloat minSM = min(lumaS, lumaM);", "    FxaaFloat maxESM = max(lumaE, maxSM);", "    FxaaFloat minESM = min(lumaE, minSM);", "    FxaaFloat maxWN = max(lumaN, lumaW);", "    FxaaFloat minWN = min(lumaN, lumaW);", "    FxaaFloat rangeMax = max(maxWN, maxESM);", "    FxaaFloat rangeMin = min(minWN, minESM);", "    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;", "    FxaaFloat range = rangeMax - rangeMin;", "    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);", "    FxaaBool earlyExit = range < rangeMaxClamped;", "/*--------------------------------------------------------------------------*/", "    if(earlyExit)", "        #if (FXAA_DISCARD == 1)", "            FxaaDiscard;", "        #else", "            return rgbyM;", "        #endif", "/*--------------------------------------------------------------------------*/", "    #if (FXAA_GATHER4_ALPHA == 0)", "        #if (FXAA_GLSL_100 == 1)", "          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));", "        #else", "          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));", "        #endif", "    #else", "        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));", "        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));", "    #endif", "/*--------------------------------------------------------------------------*/", "    FxaaFloat lumaNS = lumaN + lumaS;", "    FxaaFloat lumaWE = lumaW + lumaE;", "    FxaaFloat subpixRcpRange = 1.0/range;", "    FxaaFloat subpixNSWE = lumaNS + lumaWE;", "    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;", "    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat lumaNESE = lumaNE + lumaSE;", "    FxaaFloat lumaNWNE = lumaNW + lumaNE;", "    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;", "    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat lumaNWSW = lumaNW + lumaSW;", "    FxaaFloat lumaSWSE = lumaSW + lumaSE;", "    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);", "    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);", "    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;", "    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;", "    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;", "    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;", "    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;", "    FxaaBool horzSpan = edgeHorz >= edgeVert;", "    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;", "/*--------------------------------------------------------------------------*/", "    if(!horzSpan) lumaN = lumaW;", "    if(!horzSpan) lumaS = lumaE;", "    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;", "    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat gradientN = lumaN - lumaM;", "    FxaaFloat gradientS = lumaS - lumaM;", "    FxaaFloat lumaNN = lumaN + lumaM;", "    FxaaFloat lumaSS = lumaS + lumaM;", "    FxaaBool pairN = abs(gradientN) >= abs(gradientS);", "    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));", "    if(pairN) lengthSign = -lengthSign;", "    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);", "/*--------------------------------------------------------------------------*/", "    FxaaFloat2 posB;", "    posB.x = posM.x;", "    posB.y = posM.y;", "    FxaaFloat2 offNP;", "    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;", "    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;", "    if(!horzSpan) posB.x += lengthSign * 0.5;", "    if( horzSpan) posB.y += lengthSign * 0.5;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat2 posN;", "    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;", "    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;", "    FxaaFloat2 posP;", "    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;", "    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;", "    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;", "    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));", "    FxaaFloat subpixE = subpixC * subpixC;", "    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));", "/*--------------------------------------------------------------------------*/", "    if(!pairN) lumaNN = lumaSS;", "    FxaaFloat gradientScaled = gradient * 1.0/4.0;", "    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;", "    FxaaFloat subpixF = subpixD * subpixE;", "    FxaaBool lumaMLTZero = lumaMM < 0.0;", "/*--------------------------------------------------------------------------*/", "    lumaEndN -= lumaNN * 0.5;", "    lumaEndP -= lumaNN * 0.5;", "    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;", "    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;", "    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;", "    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;", "    FxaaBool doneNP = (!doneN) || (!doneP);", "    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;", "    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;", "/*--------------------------------------------------------------------------*/", "    if(doneNP) {", "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "        doneN = abs(lumaEndN) >= gradientScaled;", "        doneP = abs(lumaEndP) >= gradientScaled;", "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;", "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;", "        doneNP = (!doneN) || (!doneP);", "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;", "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;", "/*--------------------------------------------------------------------------*/", "        #if (FXAA_QUALITY_PS > 3)", "        if(doneNP) {", "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "            doneN = abs(lumaEndN) >= gradientScaled;", "            doneP = abs(lumaEndP) >= gradientScaled;", "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;", "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;", "            doneNP = (!doneN) || (!doneP);", "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;", "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;", "/*--------------------------------------------------------------------------*/", "            #if (FXAA_QUALITY_PS > 4)", "            if(doneNP) {", "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                doneN = abs(lumaEndN) >= gradientScaled;", "                doneP = abs(lumaEndP) >= gradientScaled;", "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;", "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;", "                doneNP = (!doneN) || (!doneP);", "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;", "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;", "/*--------------------------------------------------------------------------*/", "                #if (FXAA_QUALITY_PS > 5)", "                if(doneNP) {", "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                    doneN = abs(lumaEndN) >= gradientScaled;", "                    doneP = abs(lumaEndP) >= gradientScaled;", "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;", "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;", "                    doneNP = (!doneN) || (!doneP);", "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;", "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;", "/*--------------------------------------------------------------------------*/", "                    #if (FXAA_QUALITY_PS > 6)", "                    if(doneNP) {", "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                        doneN = abs(lumaEndN) >= gradientScaled;", "                        doneP = abs(lumaEndP) >= gradientScaled;", "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;", "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;", "                        doneNP = (!doneN) || (!doneP);", "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;", "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;", "/*--------------------------------------------------------------------------*/", "                        #if (FXAA_QUALITY_PS > 7)", "                        if(doneNP) {", "                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                            doneN = abs(lumaEndN) >= gradientScaled;", "                            doneP = abs(lumaEndP) >= gradientScaled;", "                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;", "                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;", "                            doneNP = (!doneN) || (!doneP);", "                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;", "                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;", "/*--------------------------------------------------------------------------*/", "    #if (FXAA_QUALITY_PS > 8)", "    if(doneNP) {", "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "        doneN = abs(lumaEndN) >= gradientScaled;", "        doneP = abs(lumaEndP) >= gradientScaled;", "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;", "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;", "        doneNP = (!doneN) || (!doneP);", "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;", "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;", "/*--------------------------------------------------------------------------*/", "        #if (FXAA_QUALITY_PS > 9)", "        if(doneNP) {", "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "            doneN = abs(lumaEndN) >= gradientScaled;", "            doneP = abs(lumaEndP) >= gradientScaled;", "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;", "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;", "            doneNP = (!doneN) || (!doneP);", "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;", "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;", "/*--------------------------------------------------------------------------*/", "            #if (FXAA_QUALITY_PS > 10)", "            if(doneNP) {", "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                doneN = abs(lumaEndN) >= gradientScaled;", "                doneP = abs(lumaEndP) >= gradientScaled;", "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;", "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;", "                doneNP = (!doneN) || (!doneP);", "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;", "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;", "/*--------------------------------------------------------------------------*/", "                #if (FXAA_QUALITY_PS > 11)", "                if(doneNP) {", "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                    doneN = abs(lumaEndN) >= gradientScaled;", "                    doneP = abs(lumaEndP) >= gradientScaled;", "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;", "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;", "                    doneNP = (!doneN) || (!doneP);", "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;", "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;", "/*--------------------------------------------------------------------------*/", "                    #if (FXAA_QUALITY_PS > 12)", "                    if(doneNP) {", "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                        doneN = abs(lumaEndN) >= gradientScaled;", "                        doneP = abs(lumaEndP) >= gradientScaled;", "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;", "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;", "                        doneNP = (!doneN) || (!doneP);", "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;", "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;", "/*--------------------------------------------------------------------------*/", "                    }", "                    #endif", "/*--------------------------------------------------------------------------*/", "                }", "                #endif", "/*--------------------------------------------------------------------------*/", "            }", "            #endif", "/*--------------------------------------------------------------------------*/", "        }", "        #endif", "/*--------------------------------------------------------------------------*/", "    }", "    #endif", "/*--------------------------------------------------------------------------*/", "                        }", "                        #endif", "/*--------------------------------------------------------------------------*/", "                    }", "                    #endif", "/*--------------------------------------------------------------------------*/", "                }", "                #endif", "/*--------------------------------------------------------------------------*/", "            }", "            #endif", "/*--------------------------------------------------------------------------*/", "        }", "        #endif", "/*--------------------------------------------------------------------------*/", "    }", "/*--------------------------------------------------------------------------*/", "    FxaaFloat dstN = posM.x - posN.x;", "    FxaaFloat dstP = posP.x - posM.x;", "    if(!horzSpan) dstN = posM.y - posN.y;", "    if(!horzSpan) dstP = posP.y - posM.y;", "/*--------------------------------------------------------------------------*/", "    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;", "    FxaaFloat spanLength = (dstP + dstN);", "    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;", "    FxaaFloat spanLengthRcp = 1.0/spanLength;", "/*--------------------------------------------------------------------------*/", "    FxaaBool directionN = dstN < dstP;", "    FxaaFloat dst = min(dstN, dstP);", "    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;", "    FxaaFloat subpixG = subpixF * subpixF;", "    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;", "    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;", "    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);", "    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;", "    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;", "    #if (FXAA_DISCARD == 1)", "        return FxaaTexTop(tex, posM);", "    #else", "        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);", "    #endif", "}", "/*==========================================================================*/", "#endif", "", "void main() {", "  gl_FragColor = FxaaPixelShader(", "    vUv,", "    vec4(0.0),", "    tDiffuse,", "    tDiffuse,", "    tDiffuse,", "    resolution,", "    vec4(0.0),", "    vec4(0.0),", "    vec4(0.0),", "    0.75,", "    0.166,", "    0.0833,", "    0.0,", "    0.0,", "    0.0,", "    vec4(0.0)", "  );", "", "  // TODO avoid querying texture twice for same texel", "  gl_FragColor.a = texture2D(tDiffuse, vUv).a;", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/FocusShader.js
var FocusShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    screenWidth: {
      value: 1024
    },
    screenHeight: {
      value: 1024
    },
    sampleDistance: {
      value: 0.94
    },
    waveFactor: {
      value: 125e-5
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float screenWidth;", "uniform float screenHeight;", "uniform float sampleDistance;", "uniform float waveFactor;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 color, org, tmp, add;", "	float sample_dist, f;", "	vec2 vin;", "	vec2 uv = vUv;", "	add = color = org = texture2D( tDiffuse, uv );", "	vin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );", "	sample_dist = dot( vin, vin ) * 2.0;", "	f = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;", "	vec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );", "	add += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );", "	if( tmp.b < color.b ) color = tmp;", "	add += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );", "	if( tmp.b < color.b ) color = tmp;", "	add += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );", "	if( tmp.b < color.b ) color = tmp;", "	add += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );", "	if( tmp.b < color.b ) color = tmp;", "	add += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );", "	if( tmp.b < color.b ) color = tmp;", "	add += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );", "	if( tmp.b < color.b ) color = tmp;", "	add += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );", "	if( tmp.b < color.b ) color = tmp;", "	color = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );", "	color = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );", "	gl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/FreiChenShader.js
var FreiChenShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    aspect: {
      value: new Vector2(512, 512)
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "uniform vec2 aspect;",
    "vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);",
    "mat3 G[9];",
    "const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );",
    "const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );",
    "const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );",
    "const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );",
    "const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );",
    "const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );",
    "const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );",
    "const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );",
    "const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );",
    "void main(void)",
    "{",
    "	G[0] = g0,",
    "	G[1] = g1,",
    "	G[2] = g2,",
    "	G[3] = g3,",
    "	G[4] = g4,",
    "	G[5] = g5,",
    "	G[6] = g6,",
    "	G[7] = g7,",
    "	G[8] = g8;",
    "	mat3 I;",
    "	float cnv[9];",
    "	vec3 sample;",
    "	for (float i=0.0; i<3.0; i++) {",
    "		for (float j=0.0; j<3.0; j++) {",
    "			sample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;",
    "			I[int(i)][int(j)] = length(sample);",
    "		}",
    "	}",
    "	for (int i=0; i<9; i++) {",
    "		float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);",
    "		cnv[i] = dp3 * dp3;",
    "	}",
    "	float M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);",
    "	float S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);",
    "	gl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);",
    "}"
  ].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/FresnelShader.js
var FresnelShader = {
  uniforms: {
    mRefractionRatio: {
      value: 1.02
    },
    mFresnelBias: {
      value: 0.1
    },
    mFresnelPower: {
      value: 2
    },
    mFresnelScale: {
      value: 1
    },
    tCube: {
      value: null
    }
  },
  vertexShader: ["uniform float mRefractionRatio;", "uniform float mFresnelBias;", "uniform float mFresnelScale;", "uniform float mFresnelPower;", "varying vec3 vReflect;", "varying vec3 vRefract[3];", "varying float vReflectionFactor;", "void main() {", "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );", "	vec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );", "	vec3 I = worldPosition.xyz - cameraPosition;", "	vReflect = reflect( I, worldNormal );", "	vRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );", "	vRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );", "	vRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );", "	vReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );", "	gl_Position = projectionMatrix * mvPosition;", "}"].join("\n"),
  fragmentShader: ["uniform samplerCube tCube;", "varying vec3 vReflect;", "varying vec3 vRefract[3];", "varying float vReflectionFactor;", "void main() {", "	vec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );", "	vec4 refractedColor = vec4( 1.0 );", "	refractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;", "	refractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;", "	refractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;", "	gl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/GammaCorrectionShader.js
var GammaCorrectionShader = {
  uniforms: {
    tDiffuse: {
      value: null
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 tex = texture2D( tDiffuse, vUv );", "	gl_FragColor = LinearTosRGB( tex );", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/GodRaysShader.js
var GodRaysDepthMaskShader = {
  uniforms: {
    tInput: {
      value: null
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", " vUv = uv;", " gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["varying vec2 vUv;", "uniform sampler2D tInput;", "void main() {", "	gl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );", "}"].join("\n")
};
var GodRaysGenerateShader = {
  uniforms: {
    tInput: {
      value: null
    },
    fStepSize: {
      value: 1
    },
    vSunPositionScreenSpace: {
      value: new Vector3()
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", " vUv = uv;", " gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "#define TAPS_PER_PASS 6.0",
    "varying vec2 vUv;",
    "uniform sampler2D tInput;",
    "uniform vec3 vSunPositionScreenSpace;",
    "uniform float fStepSize;",
    "void main() {",
    "	vec2 delta = vSunPositionScreenSpace.xy - vUv;",
    "	float dist = length( delta );",
    "	vec2 stepv = fStepSize * delta / dist;",
    "	float iters = dist/fStepSize;",
    "	vec2 uv = vUv.xy;",
    "	float col = 0.0;",
    "	float f = min( 1.0, max( vSunPositionScreenSpace.z / 1000.0, 0.0 ) );",
    "	if ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;",
    "	uv += stepv;",
    "	if ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;",
    "	uv += stepv;",
    "	if ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;",
    "	uv += stepv;",
    "	if ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;",
    "	uv += stepv;",
    "	if ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;",
    "	uv += stepv;",
    "	if ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;",
    "	uv += stepv;",
    "	gl_FragColor = vec4( col/TAPS_PER_PASS );",
    "	gl_FragColor.a = 1.0;",
    "}"
  ].join("\n")
};
var GodRaysCombineShader = {
  uniforms: {
    tColors: {
      value: null
    },
    tGodRays: {
      value: null
    },
    fGodRayIntensity: {
      value: 0.69
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "varying vec2 vUv;",
    "uniform sampler2D tColors;",
    "uniform sampler2D tGodRays;",
    "uniform float fGodRayIntensity;",
    "void main() {",
    "	gl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );",
    "	gl_FragColor.a = 1.0;",
    "}"
  ].join("\n")
};
var GodRaysFakeSunShader = {
  uniforms: {
    vSunPositionScreenSpace: {
      value: new Vector3()
    },
    fAspect: {
      value: 1
    },
    sunColor: {
      value: new Color(16772608)
    },
    bgColor: {
      value: new Color(0)
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "varying vec2 vUv;",
    "uniform vec3 vSunPositionScreenSpace;",
    "uniform float fAspect;",
    "uniform vec3 sunColor;",
    "uniform vec3 bgColor;",
    "void main() {",
    "	vec2 diff = vUv - vSunPositionScreenSpace.xy;",
    "	diff.x *= fAspect;",
    "	float prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );",
    "	prop = 0.35 * pow( 1.0 - prop, 3.0 );",
    "	gl_FragColor.xyz = ( vSunPositionScreenSpace.z > 0.0 ) ? mix( sunColor, bgColor, 1.0 - prop ) : bgColor;",
    "	gl_FragColor.w = 1.0;",
    "}"
  ].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/HorizontalBlurShader.js
var HorizontalBlurShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    h: {
      value: 1 / 512
    }
  },
  vertexShader: `
      varying vec2 vUv;

      void main() {

        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
  `,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform float h;

    varying vec2 vUv;

    void main() {

    	vec4 sum = vec4( 0.0 );

    	sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

    	gl_FragColor = sum;

    }
  `
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/HorizontalTiltShiftShader.js
var HorizontalTiltShiftShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    h: {
      value: 1 / 512
    },
    r: {
      value: 0.35
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float h;", "uniform float r;", "varying vec2 vUv;", "void main() {", "	vec4 sum = vec4( 0.0 );", "	float hh = h * abs( r - vUv.y );", "	sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;", "	sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;", "	sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;", "	sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;", "	sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;", "	sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;", "	sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;", "	sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;", "	gl_FragColor = sum;", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/HueSaturationShader.js
var HueSaturationShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    hue: {
      value: 0
    },
    saturation: {
      value: 0
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform float hue;",
    "uniform float saturation;",
    "varying vec2 vUv;",
    "void main() {",
    "	gl_FragColor = texture2D( tDiffuse, vUv );",
    "	float angle = hue * 3.14159265;",
    "	float s = sin(angle), c = cos(angle);",
    "	vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;",
    "	float len = length(gl_FragColor.rgb);",
    "	gl_FragColor.rgb = vec3(",
    "		dot(gl_FragColor.rgb, weights.xyz),",
    "		dot(gl_FragColor.rgb, weights.zxy),",
    "		dot(gl_FragColor.rgb, weights.yzx)",
    "	);",
    "	float average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;",
    "	if (saturation > 0.0) {",
    "		gl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));",
    "	} else {",
    "		gl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);",
    "	}",
    "}"
  ].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/KaleidoShader.js
var KaleidoShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    sides: {
      value: 6
    },
    angle: {
      value: 0
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float sides;", "uniform float angle;", "varying vec2 vUv;", "void main() {", "	vec2 p = vUv - 0.5;", "	float r = length(p);", "	float a = atan(p.y, p.x) + angle;", "	float tau = 2. * 3.1416 ;", "	a = mod(a, tau/sides);", "	a = abs(a - tau/sides/2.) ;", "	p = r * vec2(cos(a), sin(a));", "	vec4 color = texture2D(tDiffuse, p + 0.5);", "	gl_FragColor = color;", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/MirrorShader.js
var MirrorShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    side: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform int side;", "varying vec2 vUv;", "void main() {", "	vec2 p = vUv;", "	if (side == 0){", "		if (p.x > 0.5) p.x = 1.0 - p.x;", "	}else if (side == 1){", "		if (p.x < 0.5) p.x = 1.0 - p.x;", "	}else if (side == 2){", "		if (p.y < 0.5) p.y = 1.0 - p.y;", "	}else if (side == 3){", "		if (p.y > 0.5) p.y = 1.0 - p.y;", "	} ", "	vec4 color = texture2D(tDiffuse, p);", "	gl_FragColor = color;", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/NormalMapShader.js
var NormalMapShader = {
  uniforms: {
    heightMap: {
      value: null
    },
    resolution: {
      value: new Vector2(512, 512)
    },
    scale: {
      value: new Vector2(1, 1)
    },
    height: {
      value: 0.05
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float height;", "uniform vec2 resolution;", "uniform sampler2D heightMap;", "varying vec2 vUv;", "void main() {", "	float val = texture2D( heightMap, vUv ).x;", "	float valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;", "	float valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;", "	gl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/ParallaxShader.js
var ParallaxShader = {
  modes: {
    none: "NO_PARALLAX",
    basic: "USE_BASIC_PARALLAX",
    steep: "USE_STEEP_PARALLAX",
    occlusion: "USE_OCLUSION_PARALLAX",
    relief: "USE_RELIEF_PARALLAX"
  },
  uniforms: {
    bumpMap: {
      value: null
    },
    map: {
      value: null
    },
    parallaxScale: {
      value: null
    },
    parallaxMinLayers: {
      value: null
    },
    parallaxMaxLayers: {
      value: null
    }
  },
  vertexShader: ["varying vec2 vUv;", "varying vec3 vViewPosition;", "varying vec3 vNormal;", "void main() {", "	vUv = uv;", "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "	vViewPosition = -mvPosition.xyz;", "	vNormal = normalize( normalMatrix * normal );", "	gl_Position = projectionMatrix * mvPosition;", "}"].join("\n"),
  fragmentShader: [
    "uniform sampler2D bumpMap;",
    "uniform sampler2D map;",
    "uniform float parallaxScale;",
    "uniform float parallaxMinLayers;",
    "uniform float parallaxMaxLayers;",
    "varying vec2 vUv;",
    "varying vec3 vViewPosition;",
    "varying vec3 vNormal;",
    "#ifdef USE_BASIC_PARALLAX",
    "	vec2 parallaxMap( in vec3 V ) {",
    "		float initialHeight = texture2D( bumpMap, vUv ).r;",
    "		vec2 texCoordOffset = parallaxScale * V.xy * initialHeight;",
    "		return vUv - texCoordOffset;",
    "	}",
    "#else",
    "	vec2 parallaxMap( in vec3 V ) {",
    "		float numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );",
    "		float layerHeight = 1.0 / numLayers;",
    "		float currentLayerHeight = 0.0;",
    "		vec2 dtex = parallaxScale * V.xy / V.z / numLayers;",
    "		vec2 currentTextureCoords = vUv;",
    "		float heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;",
    "		for ( int i = 0; i < 30; i += 1 ) {",
    "			if ( heightFromTexture <= currentLayerHeight ) {",
    "				break;",
    "			}",
    "			currentLayerHeight += layerHeight;",
    "			currentTextureCoords -= dtex;",
    "			heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;",
    "		}",
    "		#ifdef USE_STEEP_PARALLAX",
    "			return currentTextureCoords;",
    "		#elif defined( USE_RELIEF_PARALLAX )",
    "			vec2 deltaTexCoord = dtex / 2.0;",
    "			float deltaHeight = layerHeight / 2.0;",
    "			currentTextureCoords += deltaTexCoord;",
    "			currentLayerHeight -= deltaHeight;",
    "			const int numSearches = 5;",
    "			for ( int i = 0; i < numSearches; i += 1 ) {",
    "				deltaTexCoord /= 2.0;",
    "				deltaHeight /= 2.0;",
    "				heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;",
    "				if( heightFromTexture > currentLayerHeight ) {",
    "					currentTextureCoords -= deltaTexCoord;",
    "					currentLayerHeight += deltaHeight;",
    "				} else {",
    "					currentTextureCoords += deltaTexCoord;",
    "					currentLayerHeight -= deltaHeight;",
    "				}",
    "			}",
    "			return currentTextureCoords;",
    "		#elif defined( USE_OCLUSION_PARALLAX )",
    "			vec2 prevTCoords = currentTextureCoords + dtex;",
    "			float nextH = heightFromTexture - currentLayerHeight;",
    "			float prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;",
    "			float weight = nextH / ( nextH - prevH );",
    "			return prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );",
    "		#else",
    "			return vUv;",
    "		#endif",
    "	}",
    "#endif",
    "vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {",
    "	vec2 texDx = dFdx( vUv );",
    "	vec2 texDy = dFdy( vUv );",
    "	vec3 vSigmaX = dFdx( surfPosition );",
    "	vec3 vSigmaY = dFdy( surfPosition );",
    "	vec3 vR1 = cross( vSigmaY, surfNormal );",
    "	vec3 vR2 = cross( surfNormal, vSigmaX );",
    "	float fDet = dot( vSigmaX, vR1 );",
    "	vec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );",
    "	vec3 vProjVtex;",
    "	vProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;",
    "	vProjVtex.z = dot( surfNormal, viewPosition );",
    "	return parallaxMap( vProjVtex );",
    "}",
    "void main() {",
    "	vec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );",
    "	gl_FragColor = texture2D( map, mapUv );",
    "}"
  ].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/PixelShader.js
var PixelShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    resolution: {
      value: null
    },
    pixelSize: {
      value: 1
    }
  },
  vertexShader: ["varying highp vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float pixelSize;", "uniform vec2 resolution;", "varying highp vec2 vUv;", "void main(){", "vec2 dxy = pixelSize / resolution;", "vec2 coord = dxy * floor( vUv / dxy );", "gl_FragColor = texture2D(tDiffuse, coord);", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/RGBShiftShader.js
var RGBShiftShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    amount: {
      value: 5e-3
    },
    angle: {
      value: 0
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float amount;", "uniform float angle;", "varying vec2 vUv;", "void main() {", "	vec2 offset = amount * vec2( cos(angle), sin(angle));", "	vec4 cr = texture2D(tDiffuse, vUv + offset);", "	vec4 cga = texture2D(tDiffuse, vUv);", "	vec4 cb = texture2D(tDiffuse, vUv - offset);", "	gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/SepiaShader.js
var SepiaShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    amount: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float amount;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 color = texture2D( tDiffuse, vUv );", "	vec3 c = color.rgb;", "	color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );", "	color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );", "	color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );", "	gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/SobelOperatorShader.js
var SobelOperatorShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    resolution: {
      value: new Vector2()
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform vec2 resolution;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );",
    "	const mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 );",
    "	const mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 );",
    "	float tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;",
    "	float tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;",
    "	float tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;",
    "	float tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;",
    "	float tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;",
    "	float tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;",
    "	float tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;",
    "	float tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;",
    "	float tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;",
    "	float valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + ",
    "		Gx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + ",
    "		Gx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; ",
    "	float valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + ",
    "		Gy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + ",
    "		Gy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; ",
    "	float G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );",
    "	gl_FragColor = vec4( vec3( G ), 1 );",
    "}"
  ].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/SubsurfaceScatteringShader.js
function replaceAll(string, find, replace) {
  return string.split(find).join(replace);
}
var meshphong_frag_head = ShaderChunk["meshphong_frag"].slice(0, ShaderChunk["meshphong_frag"].indexOf("void main() {"));
var meshphong_frag_body = ShaderChunk["meshphong_frag"].slice(ShaderChunk["meshphong_frag"].indexOf("void main() {"));
var SubsurfaceScatteringShader = {
  uniforms: UniformsUtils.merge([ShaderLib["phong"].uniforms, {
    thicknessMap: {
      value: null
    },
    thicknessColor: {
      value: new Color(16777215)
    },
    thicknessDistortion: {
      value: 0.1
    },
    thicknessAmbient: {
      value: 0
    },
    thicknessAttenuation: {
      value: 0.1
    },
    thicknessPower: {
      value: 2
    },
    thicknessScale: {
      value: 10
    }
  }]),
  vertexShader: ["#define USE_UV", ShaderChunk["meshphong_vert"]].join("\n"),
  fragmentShader: ["#define USE_UV", "#define SUBSURFACE", meshphong_frag_head, "uniform sampler2D thicknessMap;", "uniform float thicknessPower;", "uniform float thicknessScale;", "uniform float thicknessDistortion;", "uniform float thicknessAmbient;", "uniform float thicknessAttenuation;", "uniform vec3 thicknessColor;", "void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {", "	vec3 thickness = thicknessColor * texture2D(thicknessMap, uv).r;", "	vec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));", "	float scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;", "	vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;", "	reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;", "}", meshphong_frag_body.replace("#include <lights_fragment_begin>", replaceAll(ShaderChunk["lights_fragment_begin"], "RE_Direct( directLight, geometry, material, reflectedLight );", ["RE_Direct( directLight, geometry, material, reflectedLight );", "#if defined( SUBSURFACE ) && defined( USE_UV )", " RE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);", "#endif"].join("\n")))].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/TechnicolorShader.js
var TechnicolorShader = {
  uniforms: {
    tDiffuse: {
      value: null
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );", "	vec4 newTex = vec4(tex.r, (tex.g + tex.b) * .5, (tex.g + tex.b) * .5, 1.0);", "	gl_FragColor = newTex;", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/ToonShader.js
var ToonShader1 = {
  uniforms: {
    uDirLightPos: {
      value: new Vector3()
    },
    uDirLightColor: {
      value: new Color(15658734)
    },
    uAmbientLightColor: {
      value: new Color(328965)
    },
    uBaseColor: {
      value: new Color(16777215)
    }
  },
  vertexShader: ["varying vec3 vNormal;", "varying vec3 vRefract;", "void main() {", "	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );", "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "	vec3 worldNormal = normalize ( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );", "	vNormal = normalize( normalMatrix * normal );", "	vec3 I = worldPosition.xyz - cameraPosition;", "	vRefract = refract( normalize( I ), worldNormal, 1.02 );", "	gl_Position = projectionMatrix * mvPosition;", "}"].join("\n"),
  fragmentShader: ["uniform vec3 uBaseColor;", "uniform vec3 uDirLightPos;", "uniform vec3 uDirLightColor;", "uniform vec3 uAmbientLightColor;", "varying vec3 vNormal;", "varying vec3 vRefract;", "void main() {", "	float directionalLightWeighting = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);", "	vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;", "	float intensity = smoothstep( - 0.5, 1.0, pow( length(lightWeighting), 20.0 ) );", "	intensity += length(lightWeighting) * 0.2;", "	float cameraWeighting = dot( normalize( vNormal ), vRefract );", "	intensity += pow( 1.0 - length( cameraWeighting ), 6.0 );", "	intensity = intensity * 0.2 + 0.3;", "	if ( intensity < 0.50 ) {", "		gl_FragColor = vec4( 2.0 * intensity * uBaseColor, 1.0 );", "	} else {", "		gl_FragColor = vec4( 1.0 - 2.0 * ( 1.0 - intensity ) * ( 1.0 - uBaseColor ), 1.0 );", "}", "}"].join("\n")
};
var ToonShader2 = {
  uniforms: {
    uDirLightPos: {
      value: new Vector3()
    },
    uDirLightColor: {
      value: new Color(15658734)
    },
    uAmbientLightColor: {
      value: new Color(328965)
    },
    uBaseColor: {
      value: new Color(15658734)
    },
    uLineColor1: {
      value: new Color(8421504)
    },
    uLineColor2: {
      value: new Color(0)
    },
    uLineColor3: {
      value: new Color(0)
    },
    uLineColor4: {
      value: new Color(0)
    }
  },
  vertexShader: ["varying vec3 vNormal;", "void main() {", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "	vNormal = normalize( normalMatrix * normal );", "}"].join("\n"),
  fragmentShader: ["uniform vec3 uBaseColor;", "uniform vec3 uLineColor1;", "uniform vec3 uLineColor2;", "uniform vec3 uLineColor3;", "uniform vec3 uLineColor4;", "uniform vec3 uDirLightPos;", "uniform vec3 uDirLightColor;", "uniform vec3 uAmbientLightColor;", "varying vec3 vNormal;", "void main() {", "	float camera = max( dot( normalize( vNormal ), vec3( 0.0, 0.0, 1.0 ) ), 0.4);", "	float light = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);", "	gl_FragColor = vec4( uBaseColor, 1.0 );", "	if ( length(uAmbientLightColor + uDirLightColor * light) < 1.00 ) {", "		gl_FragColor *= vec4( uLineColor1, 1.0 );", "	}", "	if ( length(uAmbientLightColor + uDirLightColor * camera) < 0.50 ) {", "		gl_FragColor *= vec4( uLineColor2, 1.0 );", "	}", "}"].join("\n")
};
var ToonShaderHatching = {
  uniforms: {
    uDirLightPos: {
      value: new Vector3()
    },
    uDirLightColor: {
      value: new Color(15658734)
    },
    uAmbientLightColor: {
      value: new Color(328965)
    },
    uBaseColor: {
      value: new Color(16777215)
    },
    uLineColor1: {
      value: new Color(0)
    },
    uLineColor2: {
      value: new Color(0)
    },
    uLineColor3: {
      value: new Color(0)
    },
    uLineColor4: {
      value: new Color(0)
    }
  },
  vertexShader: ["varying vec3 vNormal;", "void main() {", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "	vNormal = normalize( normalMatrix * normal );", "}"].join("\n"),
  fragmentShader: ["uniform vec3 uBaseColor;", "uniform vec3 uLineColor1;", "uniform vec3 uLineColor2;", "uniform vec3 uLineColor3;", "uniform vec3 uLineColor4;", "uniform vec3 uDirLightPos;", "uniform vec3 uDirLightColor;", "uniform vec3 uAmbientLightColor;", "varying vec3 vNormal;", "void main() {", "	float directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);", "	vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;", "	gl_FragColor = vec4( uBaseColor, 1.0 );", "	if ( length(lightWeighting) < 1.00 ) {", "		if ( mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) {", "			gl_FragColor = vec4( uLineColor1, 1.0 );", "		}", "	}", "	if ( length(lightWeighting) < 0.75 ) {", "		if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) {", "			gl_FragColor = vec4( uLineColor2, 1.0 );", "		}", "	}", "	if ( length(lightWeighting) < 0.50 ) {", "		if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0) {", "			gl_FragColor = vec4( uLineColor3, 1.0 );", "		}", "	}", "	if ( length(lightWeighting) < 0.3465 ) {", "		if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0) {", "			gl_FragColor = vec4( uLineColor4, 1.0 );", "	}", "	}", "}"].join("\n")
};
var ToonShaderDotted = {
  uniforms: {
    uDirLightPos: {
      value: new Vector3()
    },
    uDirLightColor: {
      value: new Color(15658734)
    },
    uAmbientLightColor: {
      value: new Color(328965)
    },
    uBaseColor: {
      value: new Color(16777215)
    },
    uLineColor1: {
      value: new Color(0)
    }
  },
  vertexShader: ["varying vec3 vNormal;", "void main() {", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "	vNormal = normalize( normalMatrix * normal );", "}"].join("\n"),
  fragmentShader: ["uniform vec3 uBaseColor;", "uniform vec3 uLineColor1;", "uniform vec3 uLineColor2;", "uniform vec3 uLineColor3;", "uniform vec3 uLineColor4;", "uniform vec3 uDirLightPos;", "uniform vec3 uDirLightColor;", "uniform vec3 uAmbientLightColor;", "varying vec3 vNormal;", "void main() {", "float directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);", "vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;", "gl_FragColor = vec4( uBaseColor, 1.0 );", "if ( length(lightWeighting) < 1.00 ) {", "		if ( ( mod(gl_FragCoord.x, 4.001) + mod(gl_FragCoord.y, 4.0) ) > 6.00 ) {", "			gl_FragColor = vec4( uLineColor1, 1.0 );", "		}", "	}", "	if ( length(lightWeighting) < 0.50 ) {", "		if ( ( mod(gl_FragCoord.x + 2.0, 4.001) + mod(gl_FragCoord.y + 2.0, 4.0) ) > 6.00 ) {", "			gl_FragColor = vec4( uLineColor1, 1.0 );", "		}", "	}", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/TriangleBlurShader.js
var TriangleBlurShader = {
  uniforms: {
    texture: {
      value: null
    },
    delta: {
      value: new Vector2(1, 1)
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "#include <common>",
    "#define ITERATIONS 10.0",
    "uniform sampler2D texture;",
    "uniform vec2 delta;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec4 color = vec4( 0.0 );",
    "	float total = 0.0;",
    "	float offset = rand( vUv );",
    "	for ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {",
    "		float percent = ( t + offset - 0.5 ) / ITERATIONS;",
    "		float weight = 1.0 - abs( percent );",
    "		color += texture2D( texture, vUv + delta * percent ) * weight;",
    "		total += weight;",
    "	}",
    "	gl_FragColor = color / total;",
    "}"
  ].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/VerticalBlurShader.js
var VerticalBlurShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    v: {
      value: 1 / 512
    }
  },
  vertexShader: `
    varying vec2 vUv;

    void main() {

      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }
  `,
  fragmentShader: `

  uniform sampler2D tDiffuse;
  uniform float v;

  varying vec2 vUv;

  void main() {

    vec4 sum = vec4( 0.0 );

    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

    gl_FragColor = sum;

  }
  `
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/VerticalTiltShiftShader.js
var VerticalTiltShiftShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    v: {
      value: 1 / 512
    },
    r: {
      value: 0.35
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float v;", "uniform float r;", "varying vec2 vUv;", "void main() {", "	vec4 sum = vec4( 0.0 );", "	float vv = v * abs( r - vUv.y );", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * vv ) ) * 0.051;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * vv ) ) * 0.0918;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * vv ) ) * 0.12245;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * vv ) ) * 0.1531;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * vv ) ) * 0.1531;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * vv ) ) * 0.12245;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * vv ) ) * 0.0918;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * vv ) ) * 0.051;", "	gl_FragColor = sum;", "}"].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/VignetteShader.js
var VignetteShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    offset: {
      value: 1
    },
    darkness: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "uniform float offset;",
    "uniform float darkness;",
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec4 texel = texture2D( tDiffuse, vUv );",
    "	vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );",
    "	gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );",
    "}"
  ].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/VolumeShader.js
var VolumeRenderShader1 = {
  uniforms: {
    u_size: {
      value: new Vector3(1, 1, 1)
    },
    u_renderstyle: {
      value: 0
    },
    u_renderthreshold: {
      value: 0.5
    },
    u_clim: {
      value: new Vector2(1, 1)
    },
    u_data: {
      value: null
    },
    u_cmdata: {
      value: null
    }
  },
  vertexShader: [
    "		varying vec4 v_nearpos;",
    "		varying vec4 v_farpos;",
    "		varying vec3 v_position;",
    "		void main() {",
    "				mat4 viewtransformf = modelViewMatrix;",
    "				mat4 viewtransformi = inverse(modelViewMatrix);",
    "				vec4 position4 = vec4(position, 1.0);",
    "				vec4 pos_in_cam = viewtransformf * position4;",
    "				pos_in_cam.z = -pos_in_cam.w;",
    "				v_nearpos = viewtransformi * pos_in_cam;",
    "				pos_in_cam.z = pos_in_cam.w;",
    "				v_farpos = viewtransformi * pos_in_cam;",
    "				v_position = position;",
    "				gl_Position = projectionMatrix * viewMatrix * modelMatrix * position4;",
    "		}"
  ].join("\n"),
  fragmentShader: [
    "		precision highp float;",
    "		precision mediump sampler3D;",
    "		uniform vec3 u_size;",
    "		uniform int u_renderstyle;",
    "		uniform float u_renderthreshold;",
    "		uniform vec2 u_clim;",
    "		uniform sampler3D u_data;",
    "		uniform sampler2D u_cmdata;",
    "		varying vec3 v_position;",
    "		varying vec4 v_nearpos;",
    "		varying vec4 v_farpos;",
    "		const int MAX_STEPS = 887;	// 887 for 512^3, 1774 for 1024^3",
    "		const int REFINEMENT_STEPS = 4;",
    "		const float relative_step_size = 1.0;",
    "		const vec4 ambient_color = vec4(0.2, 0.4, 0.2, 1.0);",
    "		const vec4 diffuse_color = vec4(0.8, 0.2, 0.2, 1.0);",
    "		const vec4 specular_color = vec4(1.0, 1.0, 1.0, 1.0);",
    "		const float shininess = 40.0;",
    "		void cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);",
    "		void cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);",
    "		float sample1(vec3 texcoords);",
    "		vec4 apply_colormap(float val);",
    "		vec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray);",
    "		void main() {",
    "				vec3 farpos = v_farpos.xyz / v_farpos.w;",
    "				vec3 nearpos = v_nearpos.xyz / v_nearpos.w;",
    "				vec3 view_ray = normalize(nearpos.xyz - farpos.xyz);",
    "				float distance = dot(nearpos - v_position, view_ray);",
    "				distance = max(distance, min((-0.5 - v_position.x) / view_ray.x,",
    "																		(u_size.x - 0.5 - v_position.x) / view_ray.x));",
    "				distance = max(distance, min((-0.5 - v_position.y) / view_ray.y,",
    "																		(u_size.y - 0.5 - v_position.y) / view_ray.y));",
    "				distance = max(distance, min((-0.5 - v_position.z) / view_ray.z,",
    "																		(u_size.z - 0.5 - v_position.z) / view_ray.z));",
    "				vec3 front = v_position + view_ray * distance;",
    "				int nsteps = int(-distance / relative_step_size + 0.5);",
    "				if ( nsteps < 1 )",
    "						discard;",
    "				vec3 step = ((v_position - front) / u_size) / float(nsteps);",
    "				vec3 start_loc = front / u_size;",
    "				if (u_renderstyle == 0)",
    "						cast_mip(start_loc, step, nsteps, view_ray);",
    "				else if (u_renderstyle == 1)",
    "						cast_iso(start_loc, step, nsteps, view_ray);",
    "				if (gl_FragColor.a < 0.05)",
    "						discard;",
    "		}",
    "		float sample1(vec3 texcoords) {",
    "				/* Sample float value from a 3D texture. Assumes intensity data. */",
    "				return texture(u_data, texcoords.xyz).r;",
    "		}",
    "		vec4 apply_colormap(float val) {",
    "				val = (val - u_clim[0]) / (u_clim[1] - u_clim[0]);",
    "				return texture2D(u_cmdata, vec2(val, 0.5));",
    "		}",
    "		void cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {",
    "				float max_val = -1e6;",
    "				int max_i = 100;",
    "				vec3 loc = start_loc;",
    "				for (int iter=0; iter<MAX_STEPS; iter++) {",
    "						if (iter >= nsteps)",
    "								break;",
    "						float val = sample1(loc);",
    "						if (val > max_val) {",
    "								max_val = val;",
    "								max_i = iter;",
    "						}",
    "						loc += step;",
    "				}",
    "				vec3 iloc = start_loc + step * (float(max_i) - 0.5);",
    "				vec3 istep = step / float(REFINEMENT_STEPS);",
    "				for (int i=0; i<REFINEMENT_STEPS; i++) {",
    "						max_val = max(max_val, sample1(iloc));",
    "						iloc += istep;",
    "				}",
    "				gl_FragColor = apply_colormap(max_val);",
    "		}",
    "		void cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {",
    "				gl_FragColor = vec4(0.0);	// init transparent",
    "				vec4 color3 = vec4(0.0);	// final color",
    "				vec3 dstep = 1.5 / u_size;	// step to sample derivative",
    "				vec3 loc = start_loc;",
    "				float low_threshold = u_renderthreshold - 0.02 * (u_clim[1] - u_clim[0]);",
    "				for (int iter=0; iter<MAX_STEPS; iter++) {",
    "						if (iter >= nsteps)",
    "								break;",
    "						float val = sample1(loc);",
    "						if (val > low_threshold) {",
    "								vec3 iloc = loc - 0.5 * step;",
    "								vec3 istep = step / float(REFINEMENT_STEPS);",
    "								for (int i=0; i<REFINEMENT_STEPS; i++) {",
    "										val = sample1(iloc);",
    "										if (val > u_renderthreshold) {",
    "												gl_FragColor = add_lighting(val, iloc, dstep, view_ray);",
    "												return;",
    "										}",
    "										iloc += istep;",
    "								}",
    "						}",
    "						loc += step;",
    "				}",
    "		}",
    "		vec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray)",
    "		{",
    "				vec3 V = normalize(view_ray);",
    "				vec3 N;",
    "				float val1, val2;",
    "				val1 = sample1(loc + vec3(-step[0], 0.0, 0.0));",
    "				val2 = sample1(loc + vec3(+step[0], 0.0, 0.0));",
    "				N[0] = val1 - val2;",
    "				val = max(max(val1, val2), val);",
    "				val1 = sample1(loc + vec3(0.0, -step[1], 0.0));",
    "				val2 = sample1(loc + vec3(0.0, +step[1], 0.0));",
    "				N[1] = val1 - val2;",
    "				val = max(max(val1, val2), val);",
    "				val1 = sample1(loc + vec3(0.0, 0.0, -step[2]));",
    "				val2 = sample1(loc + vec3(0.0, 0.0, +step[2]));",
    "				N[2] = val1 - val2;",
    "				val = max(max(val1, val2), val);",
    "				float gm = length(N); // gradient magnitude",
    "				N = normalize(N);",
    "				float Nselect = float(dot(N, V) > 0.0);",
    "				N = (2.0 * Nselect - 1.0) * N;	// ==	Nselect * N - (1.0-Nselect)*N;",
    "				vec4 ambient_color = vec4(0.0, 0.0, 0.0, 0.0);",
    "				vec4 diffuse_color = vec4(0.0, 0.0, 0.0, 0.0);",
    "				vec4 specular_color = vec4(0.0, 0.0, 0.0, 0.0);",
    "				for (int i=0; i<1; i++)",
    "				{",
    "						vec3 L = normalize(view_ray);	//lightDirs[i];",
    "						float lightEnabled = float( length(L) > 0.0 );",
    "						L = normalize(L + (1.0 - lightEnabled));",
    "						float lambertTerm = clamp(dot(N, L), 0.0, 1.0);",
    "						vec3 H = normalize(L+V); // Halfway vector",
    "						float specularTerm = pow(max(dot(H, N), 0.0), shininess);",
    "						float mask1 = lightEnabled;",
    "						ambient_color +=	mask1 * ambient_color;	// * gl_LightSource[i].ambient;",
    "						diffuse_color +=	mask1 * lambertTerm;",
    "						specular_color += mask1 * specularTerm * specular_color;",
    "				}",
    "				vec4 final_color;",
    "				vec4 color = apply_colormap(val);",
    "				final_color = color * (ambient_color + diffuse_color) + specular_color;",
    "				final_color.a = color.a;",
    "				return final_color;",
    "		}"
  ].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/shaders/WaterRefractionShader.js
var WaterRefractionShader = {
  uniforms: {
    color: {
      value: null
    },
    time: {
      value: 0
    },
    tDiffuse: {
      value: null
    },
    tDudv: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: ["uniform mat4 textureMatrix;", "varying vec2 vUv;", "varying vec4 vUvRefraction;", "void main() {", "	vUv = uv;", "	vUvRefraction = textureMatrix * vec4( position, 1.0 );", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "uniform vec3 color;",
    "uniform float time;",
    "uniform sampler2D tDiffuse;",
    "uniform sampler2D tDudv;",
    "varying vec2 vUv;",
    "varying vec4 vUvRefraction;",
    "float blendOverlay( float base, float blend ) {",
    "	return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );",
    "}",
    "vec3 blendOverlay( vec3 base, vec3 blend ) {",
    "	return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ),blendOverlay( base.b, blend.b ) );",
    "}",
    "void main() {",
    " float waveStrength = 0.1;",
    " float waveSpeed = 0.03;",
    "	vec2 distortedUv = texture2D( tDudv, vec2( vUv.x + time * waveSpeed, vUv.y ) ).rg * waveStrength;",
    "	distortedUv = vUv.xy + vec2( distortedUv.x, distortedUv.y + time * waveSpeed );",
    "	vec2 distortion = ( texture2D( tDudv, distortedUv ).rg * 2.0 - 1.0 ) * waveStrength;",
    " vec4 uv = vec4( vUvRefraction );",
    " uv.xy += distortion;",
    "	vec4 base = texture2DProj( tDiffuse, uv );",
    "	gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );",
    "}"
  ].join("\n")
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/interactive/InteractiveGroup.js
var _pointer = new Vector2();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/interactive/SelectionHelper.js
var SelectionHelper = (() => {
  class SelectionHelper2 {
    constructor(selectionBox, renderer, cssClassName) {
      this.element = document.createElement("div");
      this.element.classList.add(cssClassName);
      this.element.style.pointerEvents = "none";
      this.renderer = renderer;
      this.startPoint = new Vector2();
      this.pointTopLeft = new Vector2();
      this.pointBottomRight = new Vector2();
      this.isDown = false;
      this.renderer.domElement.addEventListener("pointerdown", (event) => {
        this.isDown = true;
        this.onSelectStart(event);
      });
      this.renderer.domElement.addEventListener("pointermove", (event) => {
        if (this.isDown) {
          this.onSelectMove(event);
        }
      });
      this.renderer.domElement.addEventListener("pointerup", (event) => {
        this.isDown = false;
        this.onSelectOver(event);
      });
    }
    onSelectStart(event) {
      this.renderer.domElement.parentElement.appendChild(this.element);
      this.element.style.left = `${event.clientX}px`;
      this.element.style.top = `${event.clientY}px`;
      this.element.style.width = "0px";
      this.element.style.height = "0px";
      this.startPoint.x = event.clientX;
      this.startPoint.y = event.clientY;
    }
    onSelectMove(event) {
      this.pointBottomRight.x = Math.max(this.startPoint.x, event.clientX);
      this.pointBottomRight.y = Math.max(this.startPoint.y, event.clientY);
      this.pointTopLeft.x = Math.min(this.startPoint.x, event.clientX);
      this.pointTopLeft.y = Math.min(this.startPoint.y, event.clientY);
      this.element.style.left = `${this.pointTopLeft.x}px`;
      this.element.style.top = `${this.pointTopLeft.y}px`;
      this.element.style.width = `${this.pointBottomRight.x - this.pointTopLeft.x}px`;
      this.element.style.height = `${this.pointBottomRight.y - this.pointTopLeft.y}px`;
    }
    onSelectOver() {
      this.element.parentElement.removeChild(this.element);
    }
  }
  return SelectionHelper2;
})();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/interactive/SelectionBox.js
var SelectionBox = (() => {
  const frustum = new Frustum();
  const center = new Vector3();
  const tmpPoint = new Vector3();
  const vecNear = new Vector3();
  const vecTopLeft = new Vector3();
  const vecTopRight = new Vector3();
  const vecDownRight = new Vector3();
  const vecDownLeft = new Vector3();
  const vecFarTopLeft = new Vector3();
  const vecFarTopRight = new Vector3();
  const vecFarDownRight = new Vector3();
  const vecFarDownLeft = new Vector3();
  const vectemp1 = new Vector3();
  const vectemp2 = new Vector3();
  const vectemp3 = new Vector3();
  class SelectionBox2 {
    constructor(camera, scene, deep) {
      this.camera = camera;
      this.scene = scene;
      this.startPoint = new Vector3();
      this.endPoint = new Vector3();
      this.collection = [];
      this.deep = deep || Number.MAX_VALUE;
    }
    select(startPoint, endPoint) {
      this.startPoint = startPoint || this.startPoint;
      this.endPoint = endPoint || this.endPoint;
      this.collection = [];
      this.updateFrustum(this.startPoint, this.endPoint);
      this.searchChildInFrustum(frustum, this.scene);
      return this.collection;
    }
    updateFrustum(startPoint, endPoint) {
      startPoint = startPoint || this.startPoint;
      endPoint = endPoint || this.endPoint;
      if (startPoint.x === endPoint.x) {
        endPoint.x += Number.EPSILON;
      }
      if (startPoint.y === endPoint.y) {
        endPoint.y += Number.EPSILON;
      }
      this.camera.updateProjectionMatrix();
      this.camera.updateMatrixWorld();
      if (this.camera.isPerspectiveCamera) {
        tmpPoint.copy(startPoint);
        tmpPoint.x = Math.min(startPoint.x, endPoint.x);
        tmpPoint.y = Math.max(startPoint.y, endPoint.y);
        endPoint.x = Math.max(startPoint.x, endPoint.x);
        endPoint.y = Math.min(startPoint.y, endPoint.y);
        vecNear.setFromMatrixPosition(this.camera.matrixWorld);
        vecTopLeft.copy(tmpPoint);
        vecTopRight.set(endPoint.x, tmpPoint.y, 0);
        vecDownRight.copy(endPoint);
        vecDownLeft.set(tmpPoint.x, endPoint.y, 0);
        vecTopLeft.unproject(this.camera);
        vecTopRight.unproject(this.camera);
        vecDownRight.unproject(this.camera);
        vecDownLeft.unproject(this.camera);
        vectemp1.copy(vecTopLeft).sub(vecNear);
        vectemp2.copy(vecTopRight).sub(vecNear);
        vectemp3.copy(vecDownRight).sub(vecNear);
        vectemp1.normalize();
        vectemp2.normalize();
        vectemp3.normalize();
        vectemp1.multiplyScalar(this.deep);
        vectemp2.multiplyScalar(this.deep);
        vectemp3.multiplyScalar(this.deep);
        vectemp1.add(vecNear);
        vectemp2.add(vecNear);
        vectemp3.add(vecNear);
        var planes = frustum.planes;
        planes[0].setFromCoplanarPoints(vecNear, vecTopLeft, vecTopRight);
        planes[1].setFromCoplanarPoints(vecNear, vecTopRight, vecDownRight);
        planes[2].setFromCoplanarPoints(vecDownRight, vecDownLeft, vecNear);
        planes[3].setFromCoplanarPoints(vecDownLeft, vecTopLeft, vecNear);
        planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);
        planes[5].setFromCoplanarPoints(vectemp3, vectemp2, vectemp1);
        planes[5].normal.multiplyScalar(-1);
      } else if (this.camera.isOrthographicCamera) {
        const left = Math.min(startPoint.x, endPoint.x);
        const top = Math.max(startPoint.y, endPoint.y);
        const right = Math.max(startPoint.x, endPoint.x);
        const down = Math.min(startPoint.y, endPoint.y);
        vecTopLeft.set(left, top, -1);
        vecTopRight.set(right, top, -1);
        vecDownRight.set(right, down, -1);
        vecDownLeft.set(left, down, -1);
        vecFarTopLeft.set(left, top, 1);
        vecFarTopRight.set(right, top, 1);
        vecFarDownRight.set(right, down, 1);
        vecFarDownLeft.set(left, down, 1);
        vecTopLeft.unproject(this.camera);
        vecTopRight.unproject(this.camera);
        vecDownRight.unproject(this.camera);
        vecDownLeft.unproject(this.camera);
        vecFarTopLeft.unproject(this.camera);
        vecFarTopRight.unproject(this.camera);
        vecFarDownRight.unproject(this.camera);
        vecFarDownLeft.unproject(this.camera);
        var planes = frustum.planes;
        planes[0].setFromCoplanarPoints(vecTopLeft, vecFarTopLeft, vecFarTopRight);
        planes[1].setFromCoplanarPoints(vecTopRight, vecFarTopRight, vecFarDownRight);
        planes[2].setFromCoplanarPoints(vecFarDownRight, vecFarDownLeft, vecDownLeft);
        planes[3].setFromCoplanarPoints(vecFarDownLeft, vecFarTopLeft, vecTopLeft);
        planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);
        planes[5].setFromCoplanarPoints(vecFarDownRight, vecFarTopRight, vecFarTopLeft);
        planes[5].normal.multiplyScalar(-1);
      } else {
        console.error("THREE.SelectionBox: Unsupported camera type.");
      }
    }
    searchChildInFrustum(frustum2, object) {
      if (object.isMesh || object.isLine || object.isPoints) {
        if (object.material !== void 0) {
          if (object.geometry.boundingSphere === null)
            object.geometry.computeBoundingSphere();
          center.copy(object.geometry.boundingSphere.center);
          center.applyMatrix4(object.matrixWorld);
          if (frustum2.containsPoint(center)) {
            this.collection.push(object);
          }
        }
      }
      if (object.children.length > 0) {
        for (let x = 0; x < object.children.length; x++) {
          this.searchChildInFrustum(frustum2, object.children[x]);
        }
      }
    }
  }
  return SelectionBox2;
})();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/loaders/FBXLoader.js
var tempEuler = new Euler();
var tempVec = new Vector3();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/loaders/FontLoader.js
var Font = class {
  constructor(data) {
    _defineProperty(this, "data", void 0);
    this.data = data;
  }
  generateShapes(text, size2 = 100, _options) {
    const shapes = [];
    const options = {
      letterSpacing: 0,
      lineHeight: 1,
      ..._options
    };
    const paths = createPaths(text, size2, this.data, options);
    for (let p = 0, pl = paths.length; p < pl; p++) {
      Array.prototype.push.apply(shapes, paths[p].toShapes(false));
    }
    return shapes;
  }
};
_defineProperty(Font, "isFont", void 0);
_defineProperty(Font, "type", void 0);
function createPaths(text, size2, data, options) {
  const chars = Array.from(text);
  const scale = size2 / data.resolution;
  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
  const paths = [];
  let offsetX = 0, offsetY = 0;
  for (let i2 = 0; i2 < chars.length; i2++) {
    const char = chars[i2];
    if (char === "\n") {
      offsetX = 0;
      offsetY -= line_height * options.lineHeight;
    } else {
      const ret = createPath(char, scale, offsetX, offsetY, data);
      if (ret) {
        offsetX += ret.offsetX + options.letterSpacing;
        paths.push(ret.path);
      }
    }
  }
  return paths;
}
function createPath(char, scale, offsetX, offsetY, data) {
  const glyph = data.glyphs[char] || data.glyphs["?"];
  if (!glyph) {
    console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + ".");
    return;
  }
  const path = new ShapePath();
  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
  if (glyph.o) {
    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
    for (let i2 = 0, l = outline.length; i2 < l; ) {
      const action = outline[i2++];
      switch (action) {
        case "m":
          x = parseInt(outline[i2++]) * scale + offsetX;
          y = parseInt(outline[i2++]) * scale + offsetY;
          path.moveTo(x, y);
          break;
        case "l":
          x = parseInt(outline[i2++]) * scale + offsetX;
          y = parseInt(outline[i2++]) * scale + offsetY;
          path.lineTo(x, y);
          break;
        case "q":
          cpx = parseInt(outline[i2++]) * scale + offsetX;
          cpy = parseInt(outline[i2++]) * scale + offsetY;
          cpx1 = parseInt(outline[i2++]) * scale + offsetX;
          cpy1 = parseInt(outline[i2++]) * scale + offsetY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;
        case "b":
          cpx = parseInt(outline[i2++]) * scale + offsetX;
          cpy = parseInt(outline[i2++]) * scale + offsetY;
          cpx1 = parseInt(outline[i2++]) * scale + offsetX;
          cpy1 = parseInt(outline[i2++]) * scale + offsetY;
          cpx2 = parseInt(outline[i2++]) * scale + offsetX;
          cpy2 = parseInt(outline[i2++]) * scale + offsetY;
          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
      }
    }
  }
  return {
    offsetX: glyph.ha * scale,
    path
  };
}

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/loaders/XLoader.js
var XLoader = function() {
  var classCallCheck = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  var createClass = function() {
    function defineProperties(target, props) {
      for (let i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var XboneInf = function XboneInf2() {
    classCallCheck(this, XboneInf2);
    this.boneName = "";
    this.BoneIndex = 0;
    this.Indeces = [];
    this.Weights = [];
    this.initMatrix = null;
    this.OffsetMatrix = null;
  };
  var XAnimationInfo = function XAnimationInfo2() {
    classCallCheck(this, XAnimationInfo2);
    this.animeName = "";
    this.boneName = "";
    this.targetBone = null;
    this.keyType = 4;
    this.frameStartLv = 0;
    this.keyFrames = [];
    this.InverseMx = null;
  };
  var XAnimationObj = function() {
    function XAnimationObj2(_flags) {
      classCallCheck(this, XAnimationObj2);
      this.fps = 30;
      this.name = "xanimation";
      this.length = 0;
      this.hierarchy = [];
      this.putFlags = _flags;
      if (this.putFlags.putPos === void 0) {
        this.putFlags.putPos = true;
      }
      if (this.putFlags.putRot === void 0) {
        this.putFlags.putRot = true;
      }
      if (this.putFlags.putScl === void 0) {
        this.putFlags.putScl = true;
      }
    }
    createClass(XAnimationObj2, [{
      key: "make",
      value: function make(XAnimationInfoArray) {
        for (let i2 = 0; i2 < XAnimationInfoArray.length; i2++) {
          this.hierarchy.push(this.makeBonekeys(XAnimationInfoArray[i2]));
        }
        this.length = this.hierarchy[0].keys[this.hierarchy[0].keys.length - 1].time;
      }
    }, {
      key: "clone",
      value: function clone() {
        return Object.assign({}, this);
      }
    }, {
      key: "makeBonekeys",
      value: function makeBonekeys(XAnimationInfo2) {
        var refObj = {};
        refObj.name = XAnimationInfo2.boneName;
        refObj.parent = "";
        refObj.keys = this.keyFrameRefactor(XAnimationInfo2);
        refObj.copy = function() {
          return Object.assign({}, this);
        };
        return refObj;
      }
    }, {
      key: "keyFrameRefactor",
      value: function keyFrameRefactor(XAnimationInfo2) {
        var keys = [];
        for (let i2 = 0; i2 < XAnimationInfo2.keyFrames.length; i2++) {
          var keyframe = {};
          keyframe.time = XAnimationInfo2.keyFrames[i2].time * this.fps;
          if (XAnimationInfo2.keyFrames[i2].pos && this.putFlags.putPos) {
            keyframe.pos = XAnimationInfo2.keyFrames[i2].pos;
          }
          if (XAnimationInfo2.keyFrames[i2].rot && this.putFlags.putRot) {
            keyframe.rot = XAnimationInfo2.keyFrames[i2].rot;
          }
          if (XAnimationInfo2.keyFrames[i2].scl && this.putFlags.putScl) {
            keyframe.scl = XAnimationInfo2.keyFrames[i2].scl;
          }
          if (XAnimationInfo2.keyFrames[i2].matrix) {
            keyframe.matrix = XAnimationInfo2.keyFrames[i2].matrix;
            if (this.putFlags.putPos) {
              keyframe.pos = new Vector3().setFromMatrixPosition(keyframe.matrix);
            }
            if (this.putFlags.putRot) {
              keyframe.rot = new Quaternion().setFromRotationMatrix(keyframe.matrix);
            }
            if (this.putFlags.putScl) {
              keyframe.scl = new Vector3().setFromMatrixScale(keyframe.matrix);
            }
          }
          keys.push(keyframe);
        }
        return keys;
      }
    }]);
    return XAnimationObj2;
  }();
  var XKeyFrameInfo = function XKeyFrameInfo2() {
    classCallCheck(this, XKeyFrameInfo2);
    this.index = 0;
    this.Frame = 0;
    this.time = 0;
    this.matrix = null;
  };
  var XLoader2 = function() {
    function XLoader3(manager) {
      Loader.call(this, manager);
      classCallCheck(this, XLoader3);
      this.debug = false;
      this.texloader = new TextureLoader(this.manager);
      this.url = "";
      this._putMatLength = 0;
      this._nowMat = null;
      this._nowFrameName = "";
      this.frameHierarchie = [];
      this.Hierarchies = {};
      this.HieStack = [];
      this._currentObject = {};
      this._currentFrame = {};
      this._data = null;
      this.onLoad = null;
      this.IsUvYReverse = true;
      this.Meshes = [];
      this.animations = [];
      this.animTicksPerSecond = 30;
      this._currentGeo = null;
      this._currentAnime = null;
      this._currentAnimeFrames = null;
    }
    createClass(XLoader3, [{
      key: "_setArgOption",
      value: function _setArgOption(_arg) {
        var _start3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        if (!_arg) {
          return;
        }
        for (let i2 = _start3; i2 < _arg.length; i2++) {
          switch (i2) {
            case 0:
              this.url = _arg[i2];
              break;
            case 1:
              this.options = _arg[i2];
              break;
          }
        }
        if (this.options === void 0) {
          this.options = {};
        }
      }
    }, {
      key: "load",
      value: function load(_arg, onLoad, onProgress, onError) {
        var _this = this;
        this._setArgOption(_arg);
        var loader = new FileLoader2(this.manager);
        loader.setPath(this.path);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(this.url, function(response) {
          try {
            _this.parse(response, onLoad);
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            _this.manager.itemError(_this.url);
          }
        }, onProgress, onError);
      }
    }, {
      key: "_readLine",
      value: function _readLine(line) {
        var readed = 0;
        while (true) {
          var find = -1;
          find = line.indexOf("//", readed);
          if (find === -1) {
            find = line.indexOf("#", readed);
          }
          if (find > -1 && find < 2) {
            var foundNewLine = -1;
            foundNewLine = line.indexOf("\r\n", readed);
            if (foundNewLine > 0) {
              readed = foundNewLine + 2;
            } else {
              foundNewLine = line.indexOf("\r", readed);
              if (foundNewLine > 0) {
                readed = foundNewLine + 1;
              } else {
                readed = line.indexOf("\n", readed) + 1;
              }
            }
          } else {
            break;
          }
        }
        return line.substr(readed);
      }
    }, {
      key: "_readLine",
      value: function _readLine(line) {
        var readed = 0;
        while (true) {
          var find = -1;
          find = line.indexOf("//", readed);
          if (find === -1) {
            find = line.indexOf("#", readed);
          }
          if (find > -1 && find < 2) {
            var foundNewLine = -1;
            foundNewLine = line.indexOf("\r\n", readed);
            if (foundNewLine > 0) {
              readed = foundNewLine + 2;
            } else {
              foundNewLine = line.indexOf("\r", readed);
              if (foundNewLine > 0) {
                readed = foundNewLine + 1;
              } else {
                readed = line.indexOf("\n", readed) + 1;
              }
            }
          } else {
            break;
          }
        }
        return line.substr(readed);
      }
    }, {
      key: "_isBinary",
      value: function _isBinary(binData) {
        var reader = new DataView(binData);
        var face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;
        var n_faces = reader.getUint32(80, true);
        var expect = 80 + 32 / 8 + n_faces * face_size;
        if (expect === reader.byteLength) {
          return true;
        }
        var fileLength = reader.byteLength;
        for (let index = 0; index < fileLength; index++) {
          if (reader.getUint8(index, false) > 127) {
            return true;
          }
        }
        return false;
      }
    }, {
      key: "_ensureBinary",
      value: function _ensureBinary(buf) {
        if (typeof buf === "string") {
          var array_buffer = new Uint8Array(buf.length);
          for (let i2 = 0; i2 < buf.length; i2++) {
            array_buffer[i2] = buf.charCodeAt(i2) & 255;
          }
          return array_buffer.buffer || array_buffer;
        } else {
          return buf;
        }
      }
    }, {
      key: "_ensureString",
      value: function _ensureString(buf) {
        if (typeof buf !== "string") {
          return LoaderUtils.decodeText(new Uint8Array(buf));
        } else {
          return buf;
        }
      }
    }, {
      key: "parse",
      value: function _parse(data, onLoad) {
        var binData = this._ensureBinary(data);
        this._data = this._ensureString(data);
        this.onLoad = onLoad;
        return this._isBinary(binData) ? this._parseBinary(binData) : this._parseASCII();
      }
    }, {
      key: "_parseBinary",
      value: function _parseBinary(data) {
        return this._parseASCII(LoaderUtils.decodeText(new Uint8Array(data)));
      }
    }, {
      key: "_parseASCII",
      value: function _parseASCII() {
        var path;
        if (this.resourcePath !== "") {
          path = this.resourcePath;
        } else if (this.path !== "") {
          path = this.path;
        } else {
          path = LoaderUtils.extractUrlBase(this.url);
        }
        this.texloader.setPath(path).setCrossOrigin(this.crossOrigin);
        var endRead = 16;
        this.Hierarchies.children = [];
        this._hierarchieParse(this.Hierarchies, endRead);
        this._changeRoot();
        this._currentObject = this.Hierarchies.children.shift();
        this._mainloop();
      }
    }, {
      key: "_hierarchieParse",
      value: function _hierarchieParse(_parent, _end3) {
        var endRead = _end3;
        while (true) {
          var find1 = this._data.indexOf("{", endRead) + 1;
          var findEnd = this._data.indexOf("}", endRead);
          var findNext = this._data.indexOf("{", find1) + 1;
          if (find1 > 0 && findEnd > find1) {
            var _currentObject = {};
            _currentObject.children = [];
            var nameData = this._readLine(this._data.substr(endRead, find1 - endRead - 1)).trim();
            var word = nameData.split(/ /g);
            if (word.length > 0) {
              _currentObject.type = word[0];
              if (word.length >= 2) {
                _currentObject.name = word[1];
              } else {
                _currentObject.name = word[0] + this.Hierarchies.children.length;
              }
            } else {
              _currentObject.name = nameData;
              _currentObject.type = "";
            }
            if (_currentObject.type === "Animation") {
              _currentObject.data = this._data.substr(findNext, findEnd - findNext).trim();
              var refs = this._hierarchieParse(_currentObject, findEnd + 1);
              endRead = refs.end;
              _currentObject.children = refs.parent.children;
            } else {
              var DataEnder = this._data.lastIndexOf(";", findNext > 0 ? Math.min(findNext, findEnd) : findEnd);
              _currentObject.data = this._data.substr(find1, DataEnder - find1).trim();
              if (findNext <= 0 || findEnd < findNext) {
                endRead = findEnd + 1;
              } else {
                var nextStart = Math.max(DataEnder + 1, find1);
                var _refs = this._hierarchieParse(_currentObject, nextStart);
                endRead = _refs.end;
                _currentObject.children = _refs.parent.children;
              }
            }
            _currentObject.parent = _parent;
            if (_currentObject.type != "template") {
              _parent.children.push(_currentObject);
            }
          } else {
            endRead = find1 === -1 ? this._data.length : findEnd + 1;
            break;
          }
        }
        return {
          parent: _parent,
          end: endRead
        };
      }
    }, {
      key: "_mainloop",
      value: function _mainloop() {
        var _this2 = this;
        this._mainProc();
        if (this._currentObject.parent || this._currentObject.children.length > 0 || !this._currentObject.worked) {
          setTimeout(function() {
            _this2._mainloop();
          }, 1);
        } else {
          setTimeout(function() {
            _this2.onLoad({
              models: _this2.Meshes,
              animations: _this2.animations
            });
          }, 1);
        }
      }
    }, {
      key: "_mainProc",
      value: function _mainProc() {
        var breakFlag = false;
        while (true) {
          if (!this._currentObject.worked) {
            switch (this._currentObject.type) {
              case "template":
                break;
              case "AnimTicksPerSecond":
                this.animTicksPerSecond = parseInt(this._currentObject.data);
                break;
              case "Frame":
                this._setFrame();
                break;
              case "FrameTransformMatrix":
                this._setFrameTransformMatrix();
                break;
              case "Mesh":
                this._changeRoot();
                this._currentGeo = {};
                this._currentGeo.name = this._currentObject.name.trim();
                this._currentGeo.parentName = this._getParentName(this._currentObject).trim();
                this._currentGeo.VertexSetedBoneCount = [];
                this._currentGeo.GeometryData = {
                  vertices: [],
                  normals: [],
                  uvs: [],
                  skinIndices: [],
                  skinWeights: [],
                  indices: [],
                  materialIndices: []
                };
                this._currentGeo.Materials = [];
                this._currentGeo.normalVectors = [];
                this._currentGeo.BoneInfs = [];
                this._currentGeo.baseFrame = this._currentFrame;
                this._makeBoneFrom_CurrentFrame();
                this._readVertexDatas();
                breakFlag = true;
                break;
              case "MeshNormals":
                this._readVertexDatas();
                break;
              case "MeshTextureCoords":
                this._setMeshTextureCoords();
                break;
              case "VertexDuplicationIndices":
                break;
              case "MeshMaterialList":
                this._setMeshMaterialList();
                break;
              case "Material":
                this._setMaterial();
                break;
              case "SkinWeights":
                this._setSkinWeights();
                break;
              case "AnimationSet":
                this._changeRoot();
                this._currentAnime = {};
                this._currentAnime.name = this._currentObject.name.trim();
                this._currentAnime.AnimeFrames = [];
                break;
              case "Animation":
                if (this._currentAnimeFrames) {
                  this._currentAnime.AnimeFrames.push(this._currentAnimeFrames);
                }
                this._currentAnimeFrames = new XAnimationInfo();
                this._currentAnimeFrames.boneName = this._currentObject.data.trim();
                break;
              case "AnimationKey":
                this._readAnimationKey();
                breakFlag = true;
                break;
            }
            this._currentObject.worked = true;
          }
          if (this._currentObject.children.length > 0) {
            this._currentObject = this._currentObject.children.shift();
            if (this.debug) {
              console.log("processing " + this._currentObject.name);
            }
            if (breakFlag)
              break;
          } else {
            if (this._currentObject.worked) {
              if (this._currentObject.parent && !this._currentObject.parent.parent) {
                this._changeRoot();
              }
            }
            if (this._currentObject.parent) {
              this._currentObject = this._currentObject.parent;
            } else {
              breakFlag = true;
            }
            if (breakFlag)
              break;
          }
        }
        return;
      }
    }, {
      key: "_changeRoot",
      value: function _changeRoot() {
        if (this._currentGeo != null && this._currentGeo.name) {
          this._makeOutputGeometry();
        }
        this._currentGeo = {};
        if (this._currentAnime != null && this._currentAnime.name) {
          if (this._currentAnimeFrames) {
            this._currentAnime.AnimeFrames.push(this._currentAnimeFrames);
            this._currentAnimeFrames = null;
          }
          this._makeOutputAnimation();
        }
        this._currentAnime = {};
      }
    }, {
      key: "_getParentName",
      value: function _getParentName(_obj2) {
        if (_obj2.parent) {
          if (_obj2.parent.name) {
            return _obj2.parent.name;
          } else {
            return this._getParentName(_obj2.parent);
          }
        } else {
          return "";
        }
      }
    }, {
      key: "_setFrame",
      value: function _setFrame() {
        this._nowFrameName = this._currentObject.name.trim();
        this._currentFrame = {};
        this._currentFrame.name = this._nowFrameName;
        this._currentFrame.children = [];
        if (this._currentObject.parent && this._currentObject.parent.name) {
          this._currentFrame.parentName = this._currentObject.parent.name;
        }
        this.frameHierarchie.push(this._nowFrameName);
        this.HieStack[this._nowFrameName] = this._currentFrame;
      }
    }, {
      key: "_setFrameTransformMatrix",
      value: function _setFrameTransformMatrix() {
        this._currentFrame.FrameTransformMatrix = new Matrix4();
        var data = this._currentObject.data.split(",");
        this._ParseMatrixData(this._currentFrame.FrameTransformMatrix, data);
        this._makeBoneFrom_CurrentFrame();
      }
    }, {
      key: "_makeBoneFrom_CurrentFrame",
      value: function _makeBoneFrom_CurrentFrame() {
        if (!this._currentFrame.FrameTransformMatrix) {
          return;
        }
        var b2 = new Bone();
        b2.name = this._currentFrame.name;
        b2.applyMatrix4(this._currentFrame.FrameTransformMatrix);
        b2.matrixWorld = b2.matrix;
        b2.FrameTransformMatrix = this._currentFrame.FrameTransformMatrix;
        this._currentFrame.putBone = b2;
        if (this._currentFrame.parentName) {
          for (let frame in this.HieStack) {
            if (this.HieStack[frame].name === this._currentFrame.parentName) {
              this.HieStack[frame].putBone.add(this._currentFrame.putBone);
            }
          }
        }
      }
    }, {
      key: "_readVertexDatas",
      value: function _readVertexDatas() {
        var endRead = 0;
        var mode = 0;
        var mode_local = 0;
        var maxLength = 0;
        while (true) {
          var changeMode = false;
          if (mode_local === 0) {
            var refO = this._readInt1(endRead);
            endRead = refO.endRead;
            mode_local = 1;
            maxLength = this._currentObject.data.indexOf(";;", endRead) + 1;
            if (maxLength <= 0) {
              maxLength = this._currentObject.data.length;
            }
          } else {
            var find = 0;
            switch (mode) {
              case 0:
                find = this._currentObject.data.indexOf(",", endRead) + 1;
                break;
              case 1:
                find = this._currentObject.data.indexOf(";,", endRead) + 1;
                break;
            }
            if (find === 0 || find > maxLength) {
              find = maxLength;
              mode_local = 0;
              changeMode = true;
            }
            switch (this._currentObject.type) {
              case "Mesh":
                switch (mode) {
                  case 0:
                    this._readVertex1(this._currentObject.data.substr(endRead, find - endRead));
                    break;
                  case 1:
                    this._readFace1(this._currentObject.data.substr(endRead, find - endRead));
                    break;
                }
                break;
              case "MeshNormals":
                switch (mode) {
                  case 0:
                    this._readNormalVector1(this._currentObject.data.substr(endRead, find - endRead));
                    break;
                }
                break;
            }
            endRead = find + 1;
            if (changeMode) {
              mode++;
            }
          }
          if (endRead >= this._currentObject.data.length) {
            break;
          }
        }
      }
    }, {
      key: "_readInt1",
      value: function _readInt1(start) {
        var find = this._currentObject.data.indexOf(";", start);
        return {
          refI: parseInt(this._currentObject.data.substr(start, find - start)),
          endRead: find + 1
        };
      }
    }, {
      key: "_readVertex1",
      value: function _readVertex1(line) {
        var data = this._readLine(line.trim()).substr(0, line.length - 2).split(";");
        this._currentGeo.GeometryData.vertices.push(parseFloat(data[0]), parseFloat(data[1]), parseFloat(data[2]));
        this._currentGeo.GeometryData.skinIndices.push(0, 0, 0, 0);
        this._currentGeo.GeometryData.skinWeights.push(1, 0, 0, 0);
        this._currentGeo.VertexSetedBoneCount.push(0);
      }
    }, {
      key: "_readFace1",
      value: function _readFace1(line) {
        var data = this._readLine(line.trim()).substr(2, line.length - 4).split(",");
        this._currentGeo.GeometryData.indices.push(parseInt(data[0], 10), parseInt(data[1], 10), parseInt(data[2], 10));
      }
    }, {
      key: "_readNormalVector1",
      value: function _readNormalVector1(line) {
        var data = this._readLine(line.trim()).substr(0, line.length - 2).split(";");
        this._currentGeo.GeometryData.normals.push(parseFloat(data[0]), parseFloat(data[1]), parseFloat(data[2]));
      }
    }, {
      key: "_buildGeometry",
      value: function _buildGeometry() {
        var bufferGeometry = new BufferGeometry();
        var position = [];
        var normals = [];
        var uvs = [];
        var skinIndices = [];
        var skinWeights = [];
        var data = this._currentGeo.GeometryData;
        for (let i2 = 0, l = data.indices.length; i2 < l; i2++) {
          var stride2 = data.indices[i2] * 2;
          var stride3 = data.indices[i2] * 3;
          var stride4 = data.indices[i2] * 4;
          position.push(data.vertices[stride3], data.vertices[stride3 + 1], data.vertices[stride3 + 2]);
          normals.push(data.normals[stride3], data.normals[stride3 + 1], data.normals[stride3 + 2]);
          skinIndices.push(data.skinIndices[stride4], data.skinIndices[stride4 + 1], data.skinIndices[stride4 + 2], data.skinIndices[stride4 + 3]);
          skinWeights.push(data.skinWeights[stride4], data.skinWeights[stride4 + 1], data.skinWeights[stride4 + 2], data.skinWeights[stride4 + 3]);
          uvs.push(data.uvs[stride2], data.uvs[stride2 + 1]);
        }
        bufferGeometry.setAttribute("position", new Float32BufferAttribute(position, 3));
        bufferGeometry.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        bufferGeometry.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        bufferGeometry.setAttribute("skinIndex", new Uint16BufferAttribute(skinIndices, 4));
        bufferGeometry.setAttribute("skinWeight", new Float32BufferAttribute(skinWeights, 4));
        this._computeGroups(bufferGeometry, data.materialIndices);
        return bufferGeometry;
      }
    }, {
      key: "_computeGroups",
      value: function _computeGroups(bufferGeometry, materialIndices) {
        var group;
        var groups = [];
        var materialIndex = void 0;
        for (let i2 = 0; i2 < materialIndices.length; i2++) {
          var currentMaterialIndex = materialIndices[i2];
          if (currentMaterialIndex !== materialIndex) {
            materialIndex = currentMaterialIndex;
            if (group !== void 0) {
              group.count = i2 * 3 - group.start;
              groups.push(group);
            }
            group = {
              start: i2 * 3,
              materialIndex
            };
          }
        }
        if (group !== void 0) {
          group.count = i * 3 - group.start;
          groups.push(group);
        }
        bufferGeometry.groups = groups;
      }
    }, {
      key: "_setMeshTextureCoords",
      value: function _setMeshTextureCoords() {
        var endRead = 0;
        var mode = 0;
        var mode_local = 0;
        while (true) {
          switch (mode) {
            case 0:
              if (mode_local === 0) {
                var refO = this._readInt1(0);
                endRead = refO.endRead;
                mode_local = 1;
              } else {
                var find = this._currentObject.data.indexOf(",", endRead) + 1;
                if (find === 0) {
                  find = this._currentObject.data.length;
                  mode = 2;
                  mode_local = 0;
                }
                var line = this._currentObject.data.substr(endRead, find - endRead);
                var data = this._readLine(line.trim()).split(";");
                if (this.IsUvYReverse) {
                  this._currentGeo.GeometryData.uvs.push(parseFloat(data[0]), 1 - parseFloat(data[1]));
                } else {
                  this._currentGeo.GeometryData.uvs.push(parseFloat(data[0]), parseFloat(data[1]));
                }
                endRead = find + 1;
              }
              break;
          }
          if (endRead >= this._currentObject.data.length) {
            break;
          }
        }
      }
    }, {
      key: "_setMeshMaterialList",
      value: function _setMeshMaterialList() {
        var endRead = 0;
        var mode = 0;
        var mode_local = 0;
        while (true) {
          if (mode_local < 2) {
            var refO = this._readInt1(endRead);
            endRead = refO.endRead;
            mode_local++;
          } else {
            var find = this._currentObject.data.indexOf(";", endRead);
            if (find === -1) {
              find = this._currentObject.data.length;
              mode = 3;
              mode_local = 0;
            }
            var line = this._currentObject.data.substr(endRead, find - endRead);
            var data = this._readLine(line.trim()).split(",");
            for (let i2 = 0; i2 < data.length; i2++) {
              this._currentGeo.GeometryData.materialIndices[i2] = parseInt(data[i2]);
            }
            endRead = this._currentObject.data.length;
          }
          if (endRead >= this._currentObject.data.length || mode >= 3) {
            break;
          }
        }
      }
    }, {
      key: "_setMaterial",
      value: function _setMaterial() {
        var _nowMat = new MeshPhongMaterial({
          color: Math.random() * 16777215
        });
        _nowMat.side = FrontSide;
        _nowMat.name = this._currentObject.name;
        var endRead = 0;
        var find = this._currentObject.data.indexOf(";;", endRead);
        var line = this._currentObject.data.substr(endRead, find - endRead);
        var data = this._readLine(line.trim()).split(";");
        _nowMat.color.r = parseFloat(data[0]);
        _nowMat.color.g = parseFloat(data[1]);
        _nowMat.color.b = parseFloat(data[2]);
        endRead = find + 2;
        find = this._currentObject.data.indexOf(";", endRead);
        line = this._currentObject.data.substr(endRead, find - endRead);
        _nowMat.shininess = parseFloat(this._readLine(line));
        endRead = find + 1;
        find = this._currentObject.data.indexOf(";;", endRead);
        line = this._currentObject.data.substr(endRead, find - endRead);
        var data2 = this._readLine(line.trim()).split(";");
        _nowMat.specular.r = parseFloat(data2[0]);
        _nowMat.specular.g = parseFloat(data2[1]);
        _nowMat.specular.b = parseFloat(data2[2]);
        endRead = find + 2;
        find = this._currentObject.data.indexOf(";;", endRead);
        if (find === -1) {
          find = this._currentObject.data.length;
        }
        line = this._currentObject.data.substr(endRead, find - endRead);
        var data3 = this._readLine(line.trim()).split(";");
        _nowMat.emissive.r = parseFloat(data3[0]);
        _nowMat.emissive.g = parseFloat(data3[1]);
        _nowMat.emissive.b = parseFloat(data3[2]);
        var localObject = null;
        while (true) {
          if (this._currentObject.children.length > 0) {
            localObject = this._currentObject.children.shift();
            if (this.debug) {
              console.log("processing " + localObject.name);
            }
            var fileName = localObject.data.substr(1, localObject.data.length - 2);
            switch (localObject.type) {
              case "TextureFilename":
                _nowMat.map = this.texloader.load(fileName);
                break;
              case "BumpMapFilename":
                _nowMat.bumpMap = this.texloader.load(fileName);
                _nowMat.bumpScale = 0.05;
                break;
              case "NormalMapFilename":
                _nowMat.normalMap = this.texloader.load(fileName);
                _nowMat.normalScale = new Vector2(2, 2);
                break;
              case "EmissiveMapFilename":
                _nowMat.emissiveMap = this.texloader.load(fileName);
                break;
              case "LightMapFilename":
                _nowMat.lightMap = this.texloader.load(fileName);
                break;
            }
          } else {
            break;
          }
        }
        this._currentGeo.Materials.push(_nowMat);
      }
    }, {
      key: "_setSkinWeights",
      value: function _setSkinWeights() {
        var boneInf = new XboneInf();
        var endRead = 0;
        var find = this._currentObject.data.indexOf(";", endRead);
        var line = this._currentObject.data.substr(endRead, find - endRead);
        endRead = find + 1;
        boneInf.boneName = line.substr(1, line.length - 2);
        boneInf.BoneIndex = this._currentGeo.BoneInfs.length;
        find = this._currentObject.data.indexOf(";", endRead);
        endRead = find + 1;
        find = this._currentObject.data.indexOf(";", endRead);
        line = this._currentObject.data.substr(endRead, find - endRead);
        var data = this._readLine(line.trim()).split(",");
        for (let i2 = 0; i2 < data.length; i2++) {
          boneInf.Indeces.push(parseInt(data[i2]));
        }
        endRead = find + 1;
        find = this._currentObject.data.indexOf(";", endRead);
        line = this._currentObject.data.substr(endRead, find - endRead);
        var data2 = this._readLine(line.trim()).split(",");
        for (let _i = 0; _i < data2.length; _i++) {
          boneInf.Weights.push(parseFloat(data2[_i]));
        }
        endRead = find + 1;
        find = this._currentObject.data.indexOf(";", endRead);
        if (find <= 0) {
          find = this._currentObject.data.length;
        }
        line = this._currentObject.data.substr(endRead, find - endRead);
        var data3 = this._readLine(line.trim()).split(",");
        boneInf.OffsetMatrix = new Matrix4();
        this._ParseMatrixData(boneInf.OffsetMatrix, data3);
        this._currentGeo.BoneInfs.push(boneInf);
      }
    }, {
      key: "_makePutBoneList",
      value: function _makePutBoneList(_RootName, _bones) {
        var putting = false;
        for (let frame in this.HieStack) {
          if (this.HieStack[frame].name === _RootName || putting) {
            putting = true;
            var b2 = new Bone();
            b2.name = this.HieStack[frame].name;
            b2.applyMatrix4(this.HieStack[frame].FrameTransformMatrix);
            b2.matrixWorld = b2.matrix;
            b2.FrameTransformMatrix = this.HieStack[frame].FrameTransformMatrix;
            b2.pos = new Vector3().setFromMatrixPosition(b2.FrameTransformMatrix).toArray();
            b2.rotq = new Quaternion().setFromRotationMatrix(b2.FrameTransformMatrix).toArray();
            b2.scl = new Vector3().setFromMatrixScale(b2.FrameTransformMatrix).toArray();
            if (this.HieStack[frame].parentName && this.HieStack[frame].parentName.length > 0) {
              for (let i2 = 0; i2 < _bones.length; i2++) {
                if (this.HieStack[frame].parentName === _bones[i2].name) {
                  _bones[i2].add(b2);
                  b2.parent = i2;
                  break;
                }
              }
            }
            _bones.push(b2);
          }
        }
      }
    }, {
      key: "_makeOutputGeometry",
      value: function _makeOutputGeometry() {
        var mesh = null;
        if (this._currentGeo.BoneInfs.length > 0) {
          var putBones = [];
          this._makePutBoneList(this._currentGeo.baseFrame.parentName, putBones);
          for (let bi = 0; bi < this._currentGeo.BoneInfs.length; bi++) {
            var boneIndex = 0;
            for (let bb = 0; bb < putBones.length; bb++) {
              if (putBones[bb].name === this._currentGeo.BoneInfs[bi].boneName) {
                boneIndex = bb;
                putBones[bb].OffsetMatrix = new Matrix4();
                putBones[bb].OffsetMatrix.copy(this._currentGeo.BoneInfs[bi].OffsetMatrix);
                break;
              }
            }
            for (let vi = 0; vi < this._currentGeo.BoneInfs[bi].Indeces.length; vi++) {
              var nowVertexID = this._currentGeo.BoneInfs[bi].Indeces[vi];
              var nowVal = this._currentGeo.BoneInfs[bi].Weights[vi];
              var stride = nowVertexID * 4;
              switch (this._currentGeo.VertexSetedBoneCount[nowVertexID]) {
                case 0:
                  this._currentGeo.GeometryData.skinIndices[stride] = boneIndex;
                  this._currentGeo.GeometryData.skinWeights[stride] = nowVal;
                  break;
                case 1:
                  this._currentGeo.GeometryData.skinIndices[stride + 1] = boneIndex;
                  this._currentGeo.GeometryData.skinWeights[stride + 1] = nowVal;
                  break;
                case 2:
                  this._currentGeo.GeometryData.skinIndices[stride + 2] = boneIndex;
                  this._currentGeo.GeometryData.skinWeights[stride + 2] = nowVal;
                  break;
                case 3:
                  this._currentGeo.GeometryData.skinIndices[stride + 3] = boneIndex;
                  this._currentGeo.GeometryData.skinWeights[stride + 3] = nowVal;
                  break;
              }
              this._currentGeo.VertexSetedBoneCount[nowVertexID]++;
              if (this._currentGeo.VertexSetedBoneCount[nowVertexID] > 4) {
                console.log("warn! over 4 bone weight! :" + nowVertexID);
              }
            }
          }
          for (let sk = 0; sk < this._currentGeo.Materials.length; sk++) {
            this._currentGeo.Materials[sk].skinning = true;
          }
          var offsetList = [];
          for (let _bi = 0; _bi < putBones.length; _bi++) {
            if (putBones[_bi].OffsetMatrix) {
              offsetList.push(putBones[_bi].OffsetMatrix);
            } else {
              offsetList.push(new Matrix4());
            }
          }
          var bufferGeometry = this._buildGeometry();
          mesh = new SkinnedMesh(bufferGeometry, this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[0] : this._currentGeo.Materials);
          this._initSkeleton(mesh, putBones, offsetList);
        } else {
          var _bufferGeometry = this._buildGeometry();
          mesh = new Mesh(_bufferGeometry, this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[0] : this._currentGeo.Materials);
        }
        mesh.name = this._currentGeo.name;
        var worldBaseMx = new Matrix4();
        var currentMxFrame = this._currentGeo.baseFrame.putBone;
        if (currentMxFrame && currentMxFrame.parent) {
          while (true) {
            currentMxFrame = currentMxFrame.parent;
            if (currentMxFrame) {
              worldBaseMx.multiply(currentMxFrame.FrameTransformMatrix);
            } else {
              break;
            }
          }
          mesh.applyMatrix4(worldBaseMx);
        }
        this.Meshes.push(mesh);
      }
    }, {
      key: "_initSkeleton",
      value: function _initSkeleton(mesh, boneList, boneInverses) {
        var bones = [], bone, gbone;
        var i2, il;
        for (i2 = 0, il = boneList.length; i2 < il; i2++) {
          gbone = boneList[i2];
          bone = new Bone();
          bones.push(bone);
          bone.name = gbone.name;
          bone.position.fromArray(gbone.pos);
          bone.quaternion.fromArray(gbone.rotq);
          if (gbone.scl !== void 0)
            bone.scale.fromArray(gbone.scl);
        }
        for (i2 = 0, il = boneList.length; i2 < il; i2++) {
          gbone = boneList[i2];
          if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== void 0) {
            bones[gbone.parent].add(bones[i2]);
          } else {
            mesh.add(bones[i2]);
          }
        }
        mesh.updateMatrixWorld(true);
        var skeleton = new Skeleton(bones, boneInverses);
        mesh.bind(skeleton, mesh.matrixWorld);
      }
    }, {
      key: "_readAnimationKey",
      value: function _readAnimationKey() {
        var endRead = 0;
        var find = this._currentObject.data.indexOf(";", endRead);
        var line = this._currentObject.data.substr(endRead, find - endRead);
        endRead = find + 1;
        var nowKeyType = parseInt(this._readLine(line));
        find = this._currentObject.data.indexOf(";", endRead);
        endRead = find + 1;
        line = this._currentObject.data.substr(endRead);
        var data = this._readLine(line.trim()).split(";;,");
        for (let i2 = 0; i2 < data.length; i2++) {
          var data2 = data[i2].split(";");
          var keyInfo = new XKeyFrameInfo();
          keyInfo.type = nowKeyType;
          keyInfo.Frame = parseInt(data2[0]);
          keyInfo.index = this._currentAnimeFrames.keyFrames.length;
          keyInfo.time = keyInfo.Frame;
          if (nowKeyType != 4) {
            var frameFound = false;
            for (let mm = 0; mm < this._currentAnimeFrames.keyFrames.length; mm++) {
              if (this._currentAnimeFrames.keyFrames[mm].Frame === keyInfo.Frame) {
                keyInfo = this._currentAnimeFrames.keyFrames[mm];
                frameFound = true;
                break;
              }
            }
            var frameValue = data2[2].split(",");
            switch (nowKeyType) {
              case 0:
                keyInfo.rot = new Quaternion(parseFloat(frameValue[1]), parseFloat(frameValue[2]), parseFloat(frameValue[3]), parseFloat(frameValue[0]) * -1);
                break;
              case 1:
                keyInfo.scl = new Vector3(parseFloat(frameValue[0]), parseFloat(frameValue[1]), parseFloat(frameValue[2]));
                break;
              case 2:
                keyInfo.pos = new Vector3(parseFloat(frameValue[0]), parseFloat(frameValue[1]), parseFloat(frameValue[2]));
                break;
            }
            if (!frameFound) {
              this._currentAnimeFrames.keyFrames.push(keyInfo);
            }
          } else {
            keyInfo.matrix = new Matrix4();
            this._ParseMatrixData(keyInfo.matrix, data2[2].split(","));
            this._currentAnimeFrames.keyFrames.push(keyInfo);
          }
        }
      }
    }, {
      key: "_makeOutputAnimation",
      value: function _makeOutputAnimation() {
        var animationObj = new XAnimationObj(this.options);
        animationObj.fps = this.animTicksPerSecond;
        animationObj.name = this._currentAnime.name;
        animationObj.make(this._currentAnime.AnimeFrames);
        this.animations.push(animationObj);
      }
    }, {
      key: "assignAnimation",
      value: function assignAnimation(_model, _animation) {
        var model = _model;
        var animation = _animation;
        if (!model) {
          model = this.Meshes[0];
        }
        if (!animation) {
          animation = this.animations[0];
        }
        if (!model || !animation) {
          return null;
        }
        var put = {};
        put.fps = animation.fps;
        put.name = animation.name;
        put.length = animation.length;
        put.hierarchy = [];
        for (let b2 = 0; b2 < model.skeleton.bones.length; b2++) {
          var findAnimation = false;
          for (let i2 = 0; i2 < animation.hierarchy.length; i2++) {
            if (model.skeleton.bones[b2].name === animation.hierarchy[i2].name) {
              findAnimation = true;
              var c_key = animation.hierarchy[i2].copy();
              c_key.parent = -1;
              if (model.skeleton.bones[b2].parent && model.skeleton.bones[b2].parent.type === "Bone") {
                for (let bb = 0; bb < put.hierarchy.length; bb++) {
                  if (put.hierarchy[bb].name === model.skeleton.bones[b2].parent.name) {
                    c_key.parent = bb;
                    c_key.parentName = model.skeleton.bones[b2].parent.name;
                  }
                }
              }
              put.hierarchy.push(c_key);
              break;
            }
          }
          if (!findAnimation) {
            var _c_key = animation.hierarchy[0].copy();
            _c_key.name = model.skeleton.bones[b2].name;
            _c_key.parent = -1;
            for (let k = 0; k < _c_key.keys.length; k++) {
              if (_c_key.keys[k].pos) {
                _c_key.keys[k].pos.set(0, 0, 0);
              }
              if (_c_key.keys[k].scl) {
                _c_key.keys[k].scl.set(1, 1, 1);
              }
              if (_c_key.keys[k].rot) {
                _c_key.keys[k].rot.set(0, 0, 0, 1);
              }
            }
            put.hierarchy.push(_c_key);
          }
        }
        if (!model.geometry.animations) {
          model.geometry.animations = [];
        }
        model.geometry.animations.push(AnimationClip.parseAnimation(put, model.skeleton.bones));
        if (!model.animationMixer) {
          model.animationMixer = new AnimationMixer(model);
        }
        return put;
      }
    }, {
      key: "_ParseMatrixData",
      value: function _ParseMatrixData(targetMatrix, data) {
        targetMatrix.set(parseFloat(data[0]), parseFloat(data[4]), parseFloat(data[8]), parseFloat(data[12]), parseFloat(data[1]), parseFloat(data[5]), parseFloat(data[9]), parseFloat(data[13]), parseFloat(data[2]), parseFloat(data[6]), parseFloat(data[10]), parseFloat(data[14]), parseFloat(data[3]), parseFloat(data[7]), parseFloat(data[11]), parseFloat(data[15]));
      }
    }]);
    return XLoader3;
  }();
  return XLoader2;
}();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/utils/WorkerPool.js
var WorkerPool = class {
  constructor(pool = 4) {
    this.pool = pool;
    this.queue = [];
    this.workers = [];
    this.workersResolve = [];
    this.workerStatus = 0;
  }
  _initWorker(workerId) {
    if (!this.workers[workerId]) {
      const worker = this.workerCreator();
      worker.addEventListener("message", this._onMessage.bind(this, workerId));
      this.workers[workerId] = worker;
    }
  }
  _getIdleWorker() {
    for (let i2 = 0; i2 < this.pool; i2++)
      if (!(this.workerStatus & 1 << i2))
        return i2;
    return -1;
  }
  _onMessage(workerId, msg) {
    const resolve = this.workersResolve[workerId];
    resolve && resolve(msg);
    if (this.queue.length) {
      const {
        resolve: resolve2,
        msg: msg2,
        transfer
      } = this.queue.shift();
      this.workersResolve[workerId] = resolve2;
      this.workers[workerId].postMessage(msg2, transfer);
    } else {
      this.workerStatus ^= 1 << workerId;
    }
  }
  setWorkerCreator(workerCreator) {
    this.workerCreator = workerCreator;
  }
  setWorkerLimit(pool) {
    this.pool = pool;
  }
  postMessage(msg, transfer) {
    return new Promise((resolve) => {
      const workerId = this._getIdleWorker();
      if (workerId !== -1) {
        this._initWorker(workerId);
        this.workerStatus |= 1 << workerId;
        this.workersResolve[workerId] = resolve;
        this.workers[workerId].postMessage(msg, transfer);
      } else {
        this.queue.push({
          resolve,
          msg,
          transfer
        });
      }
    });
  }
  dispose() {
    this.workers.forEach((worker) => worker.terminate());
    this.workersResolve.length = 0;
    this.workers.length = 0;
    this.queue.length = 0;
    this.workerStatus = 0;
  }
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/loaders/KTX2Loader.js
var _taskCache = /* @__PURE__ */ new WeakMap();
var _activeLoaders = 0;
var _zstd;
var KTX2Loader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.transcoderPath = "";
    this.transcoderBinary = null;
    this.transcoderPending = null;
    this.workerPool = new WorkerPool();
    this.workerSourceURL = "";
    this.workerConfig = null;
    if (typeof MSC_TRANSCODER !== "undefined") {
      console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.');
    }
  }
  setTranscoderPath(path) {
    this.transcoderPath = path;
    return this;
  }
  setWorkerLimit(num) {
    this.workerPool.setWorkerLimit(num);
    return this;
  }
  detectSupport(renderer) {
    this.workerConfig = {
      astcSupported: renderer.extensions.has("WEBGL_compressed_texture_astc"),
      etc1Supported: renderer.extensions.has("WEBGL_compressed_texture_etc1"),
      etc2Supported: renderer.extensions.has("WEBGL_compressed_texture_etc"),
      dxtSupported: renderer.extensions.has("WEBGL_compressed_texture_s3tc"),
      bptcSupported: renderer.extensions.has("EXT_texture_compression_bptc"),
      pvrtcSupported: renderer.extensions.has("WEBGL_compressed_texture_pvrtc") || renderer.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
    };
    if (renderer.capabilities.isWebGL2) {
      this.workerConfig.etc1Supported = false;
    }
    return this;
  }
  init() {
    if (!this.transcoderPending) {
      const jsLoader = new FileLoader2(this.manager);
      jsLoader.setPath(this.transcoderPath);
      jsLoader.setWithCredentials(this.withCredentials);
      const jsContent = jsLoader.loadAsync("basis_transcoder.js");
      const binaryLoader = new FileLoader2(this.manager);
      binaryLoader.setPath(this.transcoderPath);
      binaryLoader.setResponseType("arraybuffer");
      binaryLoader.setWithCredentials(this.withCredentials);
      const binaryContent = binaryLoader.loadAsync("basis_transcoder.wasm");
      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {
        const fn = KTX2Loader.BasisWorker.toString();
        const body = ["/* constants */", "let _EngineFormat = " + JSON.stringify(KTX2Loader.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(KTX2Loader.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(KTX2Loader.BasisFormat), "/* basis_transcoder.js */", jsContent2, "/* worker */", fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))].join("\n");
        this.workerSourceURL = URL.createObjectURL(new Blob([body]));
        this.transcoderBinary = binaryContent2;
        this.workerPool.setWorkerCreator(() => {
          const worker = new Worker(this.workerSourceURL);
          const transcoderBinary = this.transcoderBinary.slice(0);
          worker.postMessage({
            type: "init",
            config: this.workerConfig,
            transcoderBinary
          }, [transcoderBinary]);
          return worker;
        });
      });
      if (_activeLoaders > 0) {
        console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances.");
      }
      _activeLoaders++;
    }
    return this.transcoderPending;
  }
  load(url, onLoad, onProgress, onError) {
    if (this.workerConfig === null) {
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    }
    const loader = new FileLoader2(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, (buffer2) => {
      if (_taskCache.has(buffer2)) {
        const cachedTask = _taskCache.get(buffer2);
        return cachedTask.promise.then(onLoad).catch(onError);
      }
      this._createTexture(buffer2).then((texture2) => onLoad ? onLoad(texture2) : null).catch(onError);
    }, onProgress, onError);
  }
  _createTextureFrom(transcodeResult) {
    const {
      mipmaps,
      width,
      height,
      format,
      type: type2,
      error,
      dfdTransferFn,
      dfdFlags
    } = transcodeResult;
    if (type2 === "error")
      return Promise.reject(error);
    const texture2 = new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);
    texture2.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;
    texture2.magFilter = LinearFilter;
    texture2.generateMipmaps = false;
    texture2.needsUpdate = true;
    texture2.encoding = dfdTransferFn === KHR_DF_TRANSFER_SRGB ? sRGBEncoding : LinearEncoding;
    texture2.premultiplyAlpha = !!(dfdFlags & KHR_DF_FLAG_ALPHA_PREMULTIPLIED);
    return texture2;
  }
  _createTexture(buffer2, config = {}) {
    const container = read(new Uint8Array(buffer2));
    if (container.vkFormat !== VK_FORMAT_UNDEFINED) {
      return createDataTexture(container);
    }
    const taskConfig = config;
    const texturePending = this.init().then(() => {
      return this.workerPool.postMessage({
        type: "transcode",
        buffer: buffer2,
        taskConfig
      }, [buffer2]);
    }).then((e) => this._createTextureFrom(e.data));
    _taskCache.set(buffer2, {
      promise: texturePending
    });
    return texturePending;
  }
  dispose() {
    this.workerPool.dispose();
    if (this.workerSourceURL)
      URL.revokeObjectURL(this.workerSourceURL);
    _activeLoaders--;
    return this;
  }
};
KTX2Loader.BasisFormat = {
  ETC1S: 0,
  UASTC_4x4: 1
};
KTX2Loader.TranscoderFormat = {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16
};
KTX2Loader.EngineFormat = {
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format
};
KTX2Loader.BasisWorker = function() {
  let config;
  let transcoderPending;
  let BasisModule;
  const EngineFormat = _EngineFormat;
  const TranscoderFormat = _TranscoderFormat;
  const BasisFormat = _BasisFormat;
  self.addEventListener("message", function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        config = message.config;
        init(message.transcoderBinary);
        break;
      case "transcode":
        transcoderPending.then(() => {
          try {
            const {
              width,
              height,
              hasAlpha,
              mipmaps,
              format,
              dfdTransferFn,
              dfdFlags
            } = transcode(message.buffer);
            const buffers = [];
            for (let i2 = 0; i2 < mipmaps.length; ++i2) {
              buffers.push(mipmaps[i2].data.buffer);
            }
            self.postMessage({
              type: "transcode",
              id: message.id,
              width,
              height,
              hasAlpha,
              mipmaps,
              format,
              dfdTransferFn,
              dfdFlags
            }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({
              type: "error",
              id: message.id,
              error: error.message
            });
          }
        });
        break;
    }
  });
  function init(wasmBinary) {
    transcoderPending = new Promise((resolve) => {
      BasisModule = {
        wasmBinary,
        onRuntimeInitialized: resolve
      };
      BASIS(BasisModule);
    }).then(() => {
      BasisModule.initializeBasis();
      if (BasisModule.KTX2File === void 0) {
        console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
      }
    });
  }
  function transcode(buffer2) {
    const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer2));
    function cleanup() {
      ktx2File.close();
      ktx2File.delete();
    }
    if (!ktx2File.isValid()) {
      cleanup();
      throw new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
    }
    const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;
    const width = ktx2File.getWidth();
    const height = ktx2File.getHeight();
    const levels = ktx2File.getLevels();
    const hasAlpha = ktx2File.getHasAlpha();
    const dfdTransferFn = ktx2File.getDFDTransferFunc();
    const dfdFlags = ktx2File.getDFDFlags();
    const {
      transcoderFormat,
      engineFormat
    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);
    if (!width || !height || !levels) {
      cleanup();
      throw new Error("THREE.KTX2Loader:	Invalid texture");
    }
    if (!ktx2File.startTranscoding()) {
      cleanup();
      throw new Error("THREE.KTX2Loader: .startTranscoding failed");
    }
    const mipmaps = [];
    for (let mip = 0; mip < levels; mip++) {
      const levelInfo = ktx2File.getImageLevelInfo(mip, 0, 0);
      const mipWidth = levelInfo.origWidth;
      const mipHeight = levelInfo.origHeight;
      const dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, 0, 0, transcoderFormat));
      const status = ktx2File.transcodeImage(dst, mip, 0, 0, transcoderFormat, 0, -1, -1);
      if (!status) {
        cleanup();
        throw new Error("THREE.KTX2Loader: .transcodeImage failed.");
      }
      mipmaps.push({
        data: dst,
        width: mipWidth,
        height: mipHeight
      });
    }
    cleanup();
    return {
      width,
      height,
      hasAlpha,
      mipmaps,
      format: engineFormat,
      dfdTransferFn,
      dfdFlags
    };
  }
  const FORMAT_OPTIONS = [{
    if: "astcSupported",
    basisFormat: [BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],
    engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],
    priorityETC1S: Infinity,
    priorityUASTC: 1,
    needsPowerOfTwo: false
  }, {
    if: "bptcSupported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],
    engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],
    priorityETC1S: 3,
    priorityUASTC: 2,
    needsPowerOfTwo: false
  }, {
    if: "dxtSupported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],
    engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],
    priorityETC1S: 4,
    priorityUASTC: 5,
    needsPowerOfTwo: false
  }, {
    if: "etc2Supported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],
    engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],
    priorityETC1S: 1,
    priorityUASTC: 3,
    needsPowerOfTwo: false
  }, {
    if: "etc1Supported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.ETC1],
    engineFormat: [EngineFormat.RGB_ETC1_Format],
    priorityETC1S: 2,
    priorityUASTC: 4,
    needsPowerOfTwo: false
  }, {
    if: "pvrtcSupported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],
    engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],
    priorityETC1S: 5,
    priorityUASTC: 6,
    needsPowerOfTwo: true
  }];
  const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function(a2, b2) {
    return a2.priorityETC1S - b2.priorityETC1S;
  });
  const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function(a2, b2) {
    return a2.priorityUASTC - b2.priorityUASTC;
  });
  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {
    let transcoderFormat;
    let engineFormat;
    const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;
    for (let i2 = 0; i2 < options.length; i2++) {
      const opt = options[i2];
      if (!config[opt.if])
        continue;
      if (!opt.basisFormat.includes(basisFormat))
        continue;
      if (hasAlpha && opt.transcoderFormat.length < 2)
        continue;
      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height)))
        continue;
      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];
      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];
      return {
        transcoderFormat,
        engineFormat
      };
    }
    console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.");
    transcoderFormat = TranscoderFormat.RGBA32;
    engineFormat = EngineFormat.RGBAFormat;
    return {
      transcoderFormat,
      engineFormat
    };
  }
  function isPowerOfTwo(value) {
    if (value <= 2)
      return true;
    return (value & value - 1) === 0 && value !== 0;
  }
};
var FORMAT_MAP = {
  [VK_FORMAT_R32G32B32A32_SFLOAT]: RGBAFormat,
  [VK_FORMAT_R16G16B16A16_SFLOAT]: RGBAFormat,
  [VK_FORMAT_R8G8B8A8_UNORM]: RGBAFormat,
  [VK_FORMAT_R8G8B8A8_SRGB]: RGBAFormat,
  [VK_FORMAT_R32G32_SFLOAT]: RGFormat,
  [VK_FORMAT_R16G16_SFLOAT]: RGFormat,
  [VK_FORMAT_R8G8_UNORM]: RGFormat,
  [VK_FORMAT_R8G8_SRGB]: RGFormat,
  [VK_FORMAT_R32_SFLOAT]: RedFormat,
  [VK_FORMAT_R16_SFLOAT]: RedFormat,
  [VK_FORMAT_R8_SRGB]: RedFormat,
  [VK_FORMAT_R8_UNORM]: RedFormat
};
var TYPE_MAP = {
  [VK_FORMAT_R32G32B32A32_SFLOAT]: FloatType,
  [VK_FORMAT_R16G16B16A16_SFLOAT]: HalfFloatType,
  [VK_FORMAT_R8G8B8A8_UNORM]: UnsignedByteType,
  [VK_FORMAT_R8G8B8A8_SRGB]: UnsignedByteType,
  [VK_FORMAT_R32G32_SFLOAT]: FloatType,
  [VK_FORMAT_R16G16_SFLOAT]: HalfFloatType,
  [VK_FORMAT_R8G8_UNORM]: UnsignedByteType,
  [VK_FORMAT_R8G8_SRGB]: UnsignedByteType,
  [VK_FORMAT_R32_SFLOAT]: FloatType,
  [VK_FORMAT_R16_SFLOAT]: HalfFloatType,
  [VK_FORMAT_R8_SRGB]: UnsignedByteType,
  [VK_FORMAT_R8_UNORM]: UnsignedByteType
};
var ENCODING_MAP = {
  [VK_FORMAT_R8G8B8A8_SRGB]: sRGBEncoding,
  [VK_FORMAT_R8G8_SRGB]: sRGBEncoding,
  [VK_FORMAT_R8_SRGB]: sRGBEncoding
};
async function createDataTexture(container) {
  const {
    vkFormat,
    pixelWidth,
    pixelHeight,
    pixelDepth
  } = container;
  if (FORMAT_MAP[vkFormat] === void 0) {
    throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
  }
  const level = container.levels[0];
  let levelData;
  let view;
  if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_NONE) {
    levelData = level.levelData;
  } else if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD) {
    if (!_zstd) {
      _zstd = new Promise(async (resolve) => {
        const zstd = new Q();
        await zstd.init();
        resolve(zstd);
      });
    }
    levelData = (await _zstd).decode(level.levelData, level.uncompressedByteLength);
  } else {
    throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
  }
  if (TYPE_MAP[vkFormat] === FloatType) {
    view = new Float32Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Float32Array.BYTES_PER_ELEMENT);
  } else if (TYPE_MAP[vkFormat] === HalfFloatType) {
    view = new Uint16Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT);
  } else {
    view = levelData;
  }
  const texture2 = pixelDepth === 0 ? new DataTexture(view, pixelWidth, pixelHeight) : new Data3DTexture(view, pixelWidth, pixelHeight, pixelDepth);
  texture2.type = TYPE_MAP[vkFormat];
  texture2.format = FORMAT_MAP[vkFormat];
  texture2.encoding = ENCODING_MAP[vkFormat] || LinearEncoding;
  texture2.needsUpdate = true;
  return Promise.resolve(texture2);
}

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/loaders/AssimpLoader.js
var AssimpLoader = function(manager) {
  Loader.call(this, manager);
};
AssimpLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: AssimpLoader,
  load: function(url, onLoad, onProgress, onError) {
    var scope = this;
    var path = scope.path === "" ? LoaderUtils.extractUrlBase(url) : scope.path;
    var loader = new FileLoader2(scope.manager);
    loader.setPath(scope.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(buffer2) {
      try {
        onLoad(scope.parse(buffer2, path));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  },
  parse: function(buffer2, path) {
    var textureLoader = new TextureLoader(this.manager);
    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
    var Virtulous = {};
    Virtulous.KeyFrame = function(time, matrix3) {
      this.time = time;
      this.matrix = matrix3.clone();
      this.position = new Vector3();
      this.quaternion = new Quaternion();
      this.scale = new Vector3(1, 1, 1);
      this.matrix.decompose(this.position, this.quaternion, this.scale);
      this.clone = function() {
        var n = new Virtulous.KeyFrame(this.time, this.matrix);
        return n;
      };
      this.lerp = function(nextKey, time2) {
        time2 -= this.time;
        var dist = nextKey.time - this.time;
        var l = time2 / dist;
        var l2 = 1 - l;
        var keypos = this.position;
        var keyrot = this.quaternion;
        var key2pos = nextKey.position;
        var key2rot = nextKey.quaternion;
        Virtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l;
        Virtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l;
        Virtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l;
        Virtulous.KeyFrame.tempAniQuat.set(keyrot.x, keyrot.y, keyrot.z, keyrot.w);
        Virtulous.KeyFrame.tempAniQuat.slerp(key2rot, l);
        return Virtulous.KeyFrame.tempAniMatrix.compose(Virtulous.KeyFrame.tempAniPos, Virtulous.KeyFrame.tempAniQuat, Virtulous.KeyFrame.tempAniScale);
      };
    };
    Virtulous.KeyFrame.tempAniPos = new Vector3();
    Virtulous.KeyFrame.tempAniQuat = new Quaternion();
    Virtulous.KeyFrame.tempAniScale = new Vector3(1, 1, 1);
    Virtulous.KeyFrame.tempAniMatrix = new Matrix4();
    Virtulous.KeyFrameTrack = function() {
      this.keys = [];
      this.target = null;
      this.time = 0;
      this.length = 0;
      this._accelTable = {};
      this.fps = 20;
      this.addKey = function(key) {
        this.keys.push(key);
      };
      this.init = function() {
        this.sortKeys();
        if (this.keys.length > 0)
          this.length = this.keys[this.keys.length - 1].time;
        else
          this.length = 0;
        if (!this.fps)
          return;
        for (let j2 = 0; j2 < this.length * this.fps; j2++) {
          for (let i2 = 0; i2 < this.keys.length; i2++) {
            if (this.keys[i2].time == j2) {
              this._accelTable[j2] = i2;
              break;
            } else if (this.keys[i2].time < j2 / this.fps && this.keys[i2 + 1] && this.keys[i2 + 1].time >= j2 / this.fps) {
              this._accelTable[j2] = i2;
              break;
            }
          }
        }
      };
      this.parseFromThree = function(data) {
        var fps = data.fps;
        this.target = data.node;
        var track = data.hierarchy[0].keys;
        for (let i2 = 0; i2 < track.length; i2++) {
          this.addKey(new Virtulous.KeyFrame(i2 / fps || track[i2].time, track[i2].targets[0].data));
        }
        this.init();
      };
      this.parseFromCollada = function(data) {
        var track = data.keys;
        var fps = this.fps;
        for (let i2 = 0; i2 < track.length; i2++) {
          this.addKey(new Virtulous.KeyFrame(i2 / fps || track[i2].time, track[i2].matrix));
        }
        this.init();
      };
      this.sortKeys = function() {
        this.keys.sort(this.keySortFunc);
      };
      this.keySortFunc = function(a2, b2) {
        return a2.time - b2.time;
      };
      this.clone = function() {
        var t2 = new Virtulous.KeyFrameTrack();
        t2.target = this.target;
        t2.time = this.time;
        t2.length = this.length;
        for (let i2 = 0; i2 < this.keys.length; i2++) {
          t2.addKey(this.keys[i2].clone());
        }
        t2.init();
        return t2;
      };
      this.reTarget = function(root, compareitor) {
        if (!compareitor)
          compareitor = Virtulous.TrackTargetNodeNameCompare;
        this.target = compareitor(root, this.target);
      };
      this.keySearchAccel = function(time) {
        time *= this.fps;
        time = Math.floor(time);
        return this._accelTable[time] || 0;
      };
      this.setTime = function(time) {
        time = Math.abs(time);
        if (this.length)
          time = time % this.length + 0.05;
        var key0 = null;
        var key1 = null;
        for (let i2 = this.keySearchAccel(time); i2 < this.keys.length; i2++) {
          if (this.keys[i2].time == time) {
            key0 = this.keys[i2];
            key1 = this.keys[i2];
            break;
          } else if (this.keys[i2].time < time && this.keys[i2 + 1] && this.keys[i2 + 1].time > time) {
            key0 = this.keys[i2];
            key1 = this.keys[i2 + 1];
            break;
          } else if (this.keys[i2].time < time && i2 == this.keys.length - 1) {
            key0 = this.keys[i2];
            key1 = this.keys[0].clone();
            key1.time += this.length + 0.05;
            break;
          }
        }
        if (key0 && key1 && key0 !== key1) {
          this.target.matrixAutoUpdate = false;
          this.target.matrix.copy(key0.lerp(key1, time));
          this.target.matrixWorldNeedsUpdate = true;
          return;
        }
        if (key0 && key1 && key0 == key1) {
          this.target.matrixAutoUpdate = false;
          this.target.matrix.copy(key0.matrix);
          this.target.matrixWorldNeedsUpdate = true;
          return;
        }
      };
    };
    Virtulous.TrackTargetNodeNameCompare = function(root, target) {
      function find(node, name) {
        if (node.name == name)
          return node;
        for (let i2 = 0; i2 < node.children.length; i2++) {
          var r = find(node.children[i2], name);
          if (r)
            return r;
        }
        return null;
      }
      return find(root, target.name);
    };
    Virtulous.Animation = function() {
      this.tracks = [];
      this.length = 0;
      this.addTrack = function(track) {
        this.tracks.push(track);
        this.length = Math.max(track.length, this.length);
      };
      this.setTime = function(time) {
        this.time = time;
        for (let i2 = 0; i2 < this.tracks.length; i2++)
          this.tracks[i2].setTime(time);
      };
      this.clone = function(target, compareitor) {
        if (!compareitor)
          compareitor = Virtulous.TrackTargetNodeNameCompare;
        var n = new Virtulous.Animation();
        n.target = target;
        for (let i2 = 0; i2 < this.tracks.length; i2++) {
          var track = this.tracks[i2].clone();
          track.reTarget(target, compareitor);
          n.addTrack(track);
        }
        return n;
      };
    };
    var ASSBIN_CHUNK_AICAMERA = 4660;
    var ASSBIN_CHUNK_AILIGHT = 4661;
    var ASSBIN_CHUNK_AITEXTURE = 4662;
    var ASSBIN_CHUNK_AIMESH = 4663;
    var ASSBIN_CHUNK_AINODEANIM = 4664;
    var ASSBIN_CHUNK_AISCENE = 4665;
    var ASSBIN_CHUNK_AIBONE = 4666;
    var ASSBIN_CHUNK_AIANIMATION = 4667;
    var ASSBIN_CHUNK_AINODE = 4668;
    var ASSBIN_CHUNK_AIMATERIAL = 4669;
    var ASSBIN_CHUNK_AIMATERIALPROPERTY = 4670;
    var ASSBIN_MESH_HAS_POSITIONS = 1;
    var ASSBIN_MESH_HAS_NORMALS = 2;
    var ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 4;
    var ASSBIN_MESH_HAS_TEXCOORD_BASE = 256;
    var ASSBIN_MESH_HAS_COLOR_BASE = 65536;
    var AI_MAX_NUMBER_OF_COLOR_SETS = 1;
    var AI_MAX_NUMBER_OF_TEXTURECOORDS = 4;
    var aiLightSource_DIRECTIONAL = 1;
    var aiLightSource_SPOT = 3;
    var aiTextureType_DIFFUSE = 1;
    var aiTextureType_NORMALS = 6;
    var aiTextureType_OPACITY = 8;
    var aiTextureType_LIGHTMAP = 10;
    var BONESPERVERT = 4;
    function ASSBIN_MESH_HAS_TEXCOORD(n) {
      return ASSBIN_MESH_HAS_TEXCOORD_BASE << n;
    }
    function ASSBIN_MESH_HAS_COLOR(n) {
      return ASSBIN_MESH_HAS_COLOR_BASE << n;
    }
    function markBones(scene) {
      for (let i2 in scene.mMeshes) {
        var mesh = scene.mMeshes[i2];
        for (let k in mesh.mBones) {
          var boneNode = scene.findNode(mesh.mBones[k].mName);
          if (boneNode)
            boneNode.isBone = true;
        }
      }
    }
    function cloneTreeToBones(root, scene) {
      var rootBone = new Bone();
      rootBone.matrix.copy(root.matrix);
      rootBone.matrixWorld.copy(root.matrixWorld);
      rootBone.position.copy(root.position);
      rootBone.quaternion.copy(root.quaternion);
      rootBone.scale.copy(root.scale);
      scene.nodeCount++;
      rootBone.name = "bone_" + root.name + scene.nodeCount.toString();
      if (!scene.nodeToBoneMap[root.name])
        scene.nodeToBoneMap[root.name] = [];
      scene.nodeToBoneMap[root.name].push(rootBone);
      for (let i2 in root.children) {
        var child = cloneTreeToBones(root.children[i2], scene);
        rootBone.add(child);
      }
      return rootBone;
    }
    function sortWeights(indexes, weights) {
      var pairs = [];
      for (let i2 = 0; i2 < indexes.length; i2++) {
        pairs.push({
          i: indexes[i2],
          w: weights[i2]
        });
      }
      pairs.sort(function(a2, b2) {
        return b2.w - a2.w;
      });
      while (pairs.length < 4) {
        pairs.push({
          i: 0,
          w: 0
        });
      }
      if (pairs.length > 4)
        pairs.length = 4;
      var sum = 0;
      for (let i2 = 0; i2 < 4; i2++) {
        sum += pairs[i2].w * pairs[i2].w;
      }
      sum = Math.sqrt(sum);
      for (let i2 = 0; i2 < 4; i2++) {
        pairs[i2].w = pairs[i2].w / sum;
        indexes[i2] = pairs[i2].i;
        weights[i2] = pairs[i2].w;
      }
    }
    function findMatchingBone(root, name) {
      if (root.name.indexOf("bone_" + name) == 0)
        return root;
      for (let i2 in root.children) {
        var ret = findMatchingBone(root.children[i2], name);
        if (ret)
          return ret;
      }
      return void 0;
    }
    function aiMesh() {
      this.mPrimitiveTypes = 0;
      this.mNumVertices = 0;
      this.mNumFaces = 0;
      this.mNumBones = 0;
      this.mMaterialIndex = 0;
      this.mVertices = [];
      this.mNormals = [];
      this.mTangents = [];
      this.mBitangents = [];
      this.mColors = [[]];
      this.mTextureCoords = [[]];
      this.mFaces = [];
      this.mBones = [];
      this.hookupSkeletons = function(scene) {
        if (this.mBones.length == 0)
          return;
        var allBones = [];
        var offsetMatrix = [];
        var skeletonRoot = scene.findNode(this.mBones[0].mName);
        while (skeletonRoot.mParent && skeletonRoot.mParent.isBone) {
          skeletonRoot = skeletonRoot.mParent;
        }
        var threeSkeletonRoot = skeletonRoot.toTHREE(scene);
        var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);
        this.threeNode.add(threeSkeletonRootBone);
        for (let i2 = 0; i2 < this.mBones.length; i2++) {
          var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i2].mName);
          if (bone) {
            var tbone = bone;
            allBones.push(tbone);
            offsetMatrix.push(this.mBones[i2].mOffsetMatrix.toTHREE());
          } else {
            var skeletonRoot = scene.findNode(this.mBones[i2].mName);
            if (!skeletonRoot)
              return;
            var threeSkeletonRoot = skeletonRoot.toTHREE(scene);
            var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);
            this.threeNode.add(threeSkeletonRootBone);
            var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i2].mName);
            var tbone = bone;
            allBones.push(tbone);
            offsetMatrix.push(this.mBones[i2].mOffsetMatrix.toTHREE());
          }
        }
        var skeleton = new Skeleton(allBones, offsetMatrix);
        this.threeNode.bind(skeleton, new Matrix4());
        this.threeNode.material.skinning = true;
      };
      this.toTHREE = function(scene) {
        if (this.threeNode)
          return this.threeNode;
        var geometry2 = new BufferGeometry();
        var mat;
        if (scene.mMaterials[this.mMaterialIndex])
          mat = scene.mMaterials[this.mMaterialIndex].toTHREE(scene);
        else
          mat = new MeshLambertMaterial();
        geometry2.setIndex(new BufferAttribute(new Uint32Array(this.mIndexArray), 1));
        geometry2.setAttribute("position", new BufferAttribute(this.mVertexBuffer, 3));
        if (this.mNormalBuffer && this.mNormalBuffer.length > 0) {
          geometry2.setAttribute("normal", new BufferAttribute(this.mNormalBuffer, 3));
        }
        if (this.mColorBuffer && this.mColorBuffer.length > 0) {
          geometry2.setAttribute("color", new BufferAttribute(this.mColorBuffer, 4));
        }
        if (this.mTexCoordsBuffers[0] && this.mTexCoordsBuffers[0].length > 0) {
          geometry2.setAttribute("uv", new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[0]), 2));
        }
        if (this.mTexCoordsBuffers[1] && this.mTexCoordsBuffers[1].length > 0) {
          geometry2.setAttribute("uv1", new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[1]), 2));
        }
        if (this.mTangentBuffer && this.mTangentBuffer.length > 0) {
          geometry2.setAttribute("tangents", new BufferAttribute(this.mTangentBuffer, 3));
        }
        if (this.mBitangentBuffer && this.mBitangentBuffer.length > 0) {
          geometry2.setAttribute("bitangents", new BufferAttribute(this.mBitangentBuffer, 3));
        }
        if (this.mBones.length > 0) {
          var weights = [];
          var bones = [];
          for (let i2 = 0; i2 < this.mBones.length; i2++) {
            for (let j2 = 0; j2 < this.mBones[i2].mWeights.length; j2++) {
              var weight = this.mBones[i2].mWeights[j2];
              if (weight) {
                if (!weights[weight.mVertexId])
                  weights[weight.mVertexId] = [];
                if (!bones[weight.mVertexId])
                  bones[weight.mVertexId] = [];
                weights[weight.mVertexId].push(weight.mWeight);
                bones[weight.mVertexId].push(parseInt(i2));
              }
            }
          }
          for (let i2 in bones) {
            sortWeights(bones[i2], weights[i2]);
          }
          var _weights = [];
          var _bones = [];
          for (let i2 = 0; i2 < weights.length; i2++) {
            for (let j2 = 0; j2 < 4; j2++) {
              if (weights[i2] && bones[i2]) {
                _weights.push(weights[i2][j2]);
                _bones.push(bones[i2][j2]);
              } else {
                _weights.push(0);
                _bones.push(0);
              }
            }
          }
          geometry2.setAttribute("skinWeight", new BufferAttribute(new Float32Array(_weights), BONESPERVERT));
          geometry2.setAttribute("skinIndex", new BufferAttribute(new Float32Array(_bones), BONESPERVERT));
        }
        var mesh;
        if (this.mBones.length == 0)
          mesh = new Mesh(geometry2, mat);
        if (this.mBones.length > 0) {
          mesh = new SkinnedMesh(geometry2, mat);
          mesh.normalizeSkinWeights();
        }
        this.threeNode = mesh;
        return mesh;
      };
    }
    function aiFace() {
      this.mNumIndices = 0;
      this.mIndices = [];
    }
    function aiVector3D() {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.toTHREE = function() {
        return new Vector3(this.x, this.y, this.z);
      };
    }
    function aiColor3D() {
      this.r = 0;
      this.g = 0;
      this.b = 0;
      this.a = 0;
      this.toTHREE = function() {
        return new Color(this.r, this.g, this.b);
      };
    }
    function aiQuaternion() {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 0;
      this.toTHREE = function() {
        return new Quaternion(this.x, this.y, this.z, this.w);
      };
    }
    function aiVertexWeight() {
      this.mVertexId = 0;
      this.mWeight = 0;
    }
    function aiString() {
      this.data = [];
      this.toString = function() {
        var str = "";
        this.data.forEach(function(i2) {
          str += String.fromCharCode(i2);
        });
        return str.replace(/[^\x20-\x7E]+/g, "");
      };
    }
    function aiVectorKey() {
      this.mTime = 0;
      this.mValue = null;
    }
    function aiQuatKey() {
      this.mTime = 0;
      this.mValue = null;
    }
    function aiNode() {
      this.mName = "";
      this.mTransformation = [];
      this.mNumChildren = 0;
      this.mNumMeshes = 0;
      this.mMeshes = [];
      this.mChildren = [];
      this.toTHREE = function(scene) {
        if (this.threeNode)
          return this.threeNode;
        var o = new Object3D();
        o.name = this.mName;
        o.matrix = this.mTransformation.toTHREE();
        for (let i2 = 0; i2 < this.mChildren.length; i2++) {
          o.add(this.mChildren[i2].toTHREE(scene));
        }
        for (let i2 = 0; i2 < this.mMeshes.length; i2++) {
          o.add(scene.mMeshes[this.mMeshes[i2]].toTHREE(scene));
        }
        this.threeNode = o;
        o.matrix.decompose(o.position, o.quaternion, o.scale);
        return o;
      };
    }
    function aiBone() {
      this.mName = "";
      this.mNumWeights = 0;
      this.mOffsetMatrix = 0;
    }
    function aiMaterialProperty() {
      this.mKey = "";
      this.mSemantic = 0;
      this.mIndex = 0;
      this.mData = [];
      this.mDataLength = 0;
      this.mType = 0;
      this.dataAsColor = function() {
        var array = new Uint8Array(this.mData).buffer;
        var reader = new DataView(array);
        var r = reader.getFloat32(0, true);
        var g = reader.getFloat32(4, true);
        var b2 = reader.getFloat32(8, true);
        return new Color(r, g, b2);
      };
      this.dataAsFloat = function() {
        var array = new Uint8Array(this.mData).buffer;
        var reader = new DataView(array);
        var r = reader.getFloat32(0, true);
        return r;
      };
      this.dataAsBool = function() {
        var array = new Uint8Array(this.mData).buffer;
        var reader = new DataView(array);
        var r = reader.getFloat32(0, true);
        return !!r;
      };
      this.dataAsString = function() {
        var s = new aiString();
        s.data = this.mData;
        return s.toString();
      };
      this.dataAsMap = function() {
        var s = new aiString();
        s.data = this.mData;
        var path2 = s.toString();
        path2 = path2.replace(/\\/g, "/");
        if (path2.indexOf("/") != -1) {
          path2 = path2.substr(path2.lastIndexOf("/") + 1);
        }
        return textureLoader.load(path2);
      };
    }
    var namePropMapping = {
      "?mat.name": "name",
      "$mat.shadingm": "shading",
      "$mat.twosided": "twoSided",
      "$mat.wireframe": "wireframe",
      "$clr.ambient": "ambient",
      "$clr.diffuse": "color",
      "$clr.specular": "specular",
      "$clr.emissive": "emissive",
      "$clr.transparent": "transparent",
      "$clr.reflective": "reflect",
      "$mat.shininess": "shininess",
      "$mat.reflectivity": "reflectivity",
      "$mat.refracti": "refraction",
      "$tex.file": "map"
    };
    var nameTypeMapping = {
      "?mat.name": "string",
      "$mat.shadingm": "bool",
      "$mat.twosided": "bool",
      "$mat.wireframe": "bool",
      "$clr.ambient": "color",
      "$clr.diffuse": "color",
      "$clr.specular": "color",
      "$clr.emissive": "color",
      "$clr.transparent": "color",
      "$clr.reflective": "color",
      "$mat.shininess": "float",
      "$mat.reflectivity": "float",
      "$mat.refracti": "float",
      "$tex.file": "map"
    };
    function aiMaterial() {
      this.mNumAllocated = 0;
      this.mNumProperties = 0;
      this.mProperties = [];
      this.toTHREE = function() {
        var mat = new MeshPhongMaterial();
        for (let i2 = 0; i2 < this.mProperties.length; i2++) {
          if (nameTypeMapping[this.mProperties[i2].mKey] == "float") {
            mat[namePropMapping[this.mProperties[i2].mKey]] = this.mProperties[i2].dataAsFloat();
          }
          if (nameTypeMapping[this.mProperties[i2].mKey] == "color") {
            mat[namePropMapping[this.mProperties[i2].mKey]] = this.mProperties[i2].dataAsColor();
          }
          if (nameTypeMapping[this.mProperties[i2].mKey] == "bool") {
            mat[namePropMapping[this.mProperties[i2].mKey]] = this.mProperties[i2].dataAsBool();
          }
          if (nameTypeMapping[this.mProperties[i2].mKey] == "string") {
            mat[namePropMapping[this.mProperties[i2].mKey]] = this.mProperties[i2].dataAsString();
          }
          if (nameTypeMapping[this.mProperties[i2].mKey] == "map") {
            var prop = this.mProperties[i2];
            if (prop.mSemantic == aiTextureType_DIFFUSE)
              mat.map = this.mProperties[i2].dataAsMap();
            if (prop.mSemantic == aiTextureType_NORMALS)
              mat.normalMap = this.mProperties[i2].dataAsMap();
            if (prop.mSemantic == aiTextureType_LIGHTMAP)
              mat.lightMap = this.mProperties[i2].dataAsMap();
            if (prop.mSemantic == aiTextureType_OPACITY)
              mat.alphaMap = this.mProperties[i2].dataAsMap();
          }
        }
        mat.ambient.r = 0.53;
        mat.ambient.g = 0.53;
        mat.ambient.b = 0.53;
        mat.color.r = 1;
        mat.color.g = 1;
        mat.color.b = 1;
        return mat;
      };
    }
    function veclerp(v12, v22, l) {
      var v3 = new Vector3();
      var lm1 = 1 - l;
      v3.x = v12.x * l + v22.x * lm1;
      v3.y = v12.y * l + v22.y * lm1;
      v3.z = v12.z * l + v22.z * lm1;
      return v3;
    }
    function quatlerp(q1, q2, l) {
      return q1.clone().slerp(q2, 1 - l);
    }
    function sampleTrack(keys, time, lne, lerp) {
      if (keys.length == 1)
        return keys[0].mValue.toTHREE();
      var dist = Infinity;
      var key = null;
      var nextKey = null;
      for (let i2 = 0; i2 < keys.length; i2++) {
        var timeDist = Math.abs(keys[i2].mTime - time);
        if (timeDist < dist && keys[i2].mTime <= time) {
          dist = timeDist;
          key = keys[i2];
          nextKey = keys[i2 + 1];
        }
      }
      if (!key) {
        return null;
      } else if (nextKey) {
        var dT = nextKey.mTime - key.mTime;
        var T2 = key.mTime - time;
        var l = T2 / dT;
        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);
      } else {
        nextKey = keys[0].clone();
        nextKey.mTime += lne;
        var dT = nextKey.mTime - key.mTime;
        var T2 = key.mTime - time;
        var l = T2 / dT;
        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);
      }
    }
    function aiNodeAnim() {
      this.mNodeName = "";
      this.mNumPositionKeys = 0;
      this.mNumRotationKeys = 0;
      this.mNumScalingKeys = 0;
      this.mPositionKeys = [];
      this.mRotationKeys = [];
      this.mScalingKeys = [];
      this.mPreState = "";
      this.mPostState = "";
      this.init = function(tps) {
        if (!tps)
          tps = 1;
        function t2(t3) {
          t3.mTime /= tps;
        }
        this.mPositionKeys.forEach(t2);
        this.mRotationKeys.forEach(t2);
        this.mScalingKeys.forEach(t2);
      };
      this.sortKeys = function() {
        function comp(a2, b2) {
          return a2.mTime - b2.mTime;
        }
        this.mPositionKeys.sort(comp);
        this.mRotationKeys.sort(comp);
        this.mScalingKeys.sort(comp);
      };
      this.getLength = function() {
        return Math.max(Math.max.apply(null, this.mPositionKeys.map(function(a2) {
          return a2.mTime;
        })), Math.max.apply(null, this.mRotationKeys.map(function(a2) {
          return a2.mTime;
        })), Math.max.apply(null, this.mScalingKeys.map(function(a2) {
          return a2.mTime;
        })));
      };
      this.toTHREE = function(o) {
        this.sortKeys();
        var length2 = this.getLength();
        var track = new Virtulous.KeyFrameTrack();
        for (let i2 = 0; i2 < length2; i2 += 0.05) {
          var matrix3 = new Matrix4();
          var time = i2;
          var pos = sampleTrack(this.mPositionKeys, time, length2, veclerp);
          var scale = sampleTrack(this.mScalingKeys, time, length2, veclerp);
          var rotation = sampleTrack(this.mRotationKeys, time, length2, quatlerp);
          matrix3.compose(pos, rotation, scale);
          var key = new Virtulous.KeyFrame(time, matrix3);
          track.addKey(key);
        }
        track.target = o.findNode(this.mNodeName).toTHREE();
        var tracks = [track];
        if (o.nodeToBoneMap[this.mNodeName]) {
          for (let i2 = 0; i2 < o.nodeToBoneMap[this.mNodeName].length; i2++) {
            var t2 = track.clone();
            t2.target = o.nodeToBoneMap[this.mNodeName][i2];
            tracks.push(t2);
          }
        }
        return tracks;
      };
    }
    function aiAnimation() {
      this.mName = "";
      this.mDuration = 0;
      this.mTicksPerSecond = 0;
      this.mNumChannels = 0;
      this.mChannels = [];
      this.toTHREE = function(root) {
        var animationHandle = new Virtulous.Animation();
        for (let i2 in this.mChannels) {
          this.mChannels[i2].init(this.mTicksPerSecond);
          var tracks = this.mChannels[i2].toTHREE(root);
          for (let j2 in tracks) {
            tracks[j2].init();
            animationHandle.addTrack(tracks[j2]);
          }
        }
        animationHandle.length = Math.max.apply(null, animationHandle.tracks.map(function(e) {
          return e.length;
        }));
        return animationHandle;
      };
    }
    function aiTexture() {
      this.mWidth = 0;
      this.mHeight = 0;
      this.texAchFormatHint = [];
      this.pcData = [];
    }
    function aiLight() {
      this.mName = "";
      this.mType = 0;
      this.mAttenuationConstant = 0;
      this.mAttenuationLinear = 0;
      this.mAttenuationQuadratic = 0;
      this.mAngleInnerCone = 0;
      this.mAngleOuterCone = 0;
      this.mColorDiffuse = null;
      this.mColorSpecular = null;
      this.mColorAmbient = null;
    }
    function aiCamera() {
      this.mName = "";
      this.mPosition = null;
      this.mLookAt = null;
      this.mUp = null;
      this.mHorizontalFOV = 0;
      this.mClipPlaneNear = 0;
      this.mClipPlaneFar = 0;
      this.mAspect = 0;
    }
    function aiScene() {
      this.versionMajor = 0;
      this.versionMinor = 0;
      this.versionRevision = 0;
      this.compileFlags = 0;
      this.mFlags = 0;
      this.mNumMeshes = 0;
      this.mNumMaterials = 0;
      this.mNumAnimations = 0;
      this.mNumTextures = 0;
      this.mNumLights = 0;
      this.mNumCameras = 0;
      this.mRootNode = null;
      this.mMeshes = [];
      this.mMaterials = [];
      this.mAnimations = [];
      this.mLights = [];
      this.mCameras = [];
      this.nodeToBoneMap = {};
      this.findNode = function(name, root) {
        if (!root) {
          root = this.mRootNode;
        }
        if (root.mName == name) {
          return root;
        }
        for (let i2 = 0; i2 < root.mChildren.length; i2++) {
          var ret = this.findNode(name, root.mChildren[i2]);
          if (ret)
            return ret;
        }
        return null;
      };
      this.toTHREE = function() {
        this.nodeCount = 0;
        markBones(this);
        var o = this.mRootNode.toTHREE(this);
        for (let i2 in this.mMeshes)
          this.mMeshes[i2].hookupSkeletons(this);
        if (this.mAnimations.length > 0) {
          var a2 = this.mAnimations[0].toTHREE(this);
        }
        return {
          object: o,
          animation: a2
        };
      };
    }
    function aiMatrix4() {
      this.elements = [[], [], [], []];
      this.toTHREE = function() {
        var m2 = new Matrix4();
        for (let i2 = 0; i2 < 4; ++i2) {
          for (let i22 = 0; i22 < 4; ++i22) {
            m2.elements[i2 * 4 + i22] = this.elements[i22][i2];
          }
        }
        return m2;
      };
    }
    var littleEndian = true;
    function readFloat(dataview) {
      var val = dataview.getFloat32(dataview.readOffset, littleEndian);
      dataview.readOffset += 4;
      return val;
    }
    function Read_double(dataview) {
      var val = dataview.getFloat64(dataview.readOffset, littleEndian);
      dataview.readOffset += 8;
      return val;
    }
    function Read_uint8_t(dataview) {
      var val = dataview.getUint8(dataview.readOffset);
      dataview.readOffset += 1;
      return val;
    }
    function Read_uint16_t(dataview) {
      var val = dataview.getUint16(dataview.readOffset, littleEndian);
      dataview.readOffset += 2;
      return val;
    }
    function Read_unsigned_int(dataview) {
      var val = dataview.getUint32(dataview.readOffset, littleEndian);
      dataview.readOffset += 4;
      return val;
    }
    function Read_uint32_t(dataview) {
      var val = dataview.getUint32(dataview.readOffset, littleEndian);
      dataview.readOffset += 4;
      return val;
    }
    function Read_aiVector3D(stream) {
      var v3 = new aiVector3D();
      v3.x = readFloat(stream);
      v3.y = readFloat(stream);
      v3.z = readFloat(stream);
      return v3;
    }
    function Read_aiColor3D(stream) {
      var c2 = new aiColor3D();
      c2.r = readFloat(stream);
      c2.g = readFloat(stream);
      c2.b = readFloat(stream);
      return c2;
    }
    function Read_aiQuaternion(stream) {
      var v3 = new aiQuaternion();
      v3.w = readFloat(stream);
      v3.x = readFloat(stream);
      v3.y = readFloat(stream);
      v3.z = readFloat(stream);
      return v3;
    }
    function Read_aiString(stream) {
      var s = new aiString();
      var stringlengthbytes = Read_unsigned_int(stream);
      stream.ReadBytes(s.data, 1, stringlengthbytes);
      return s.toString();
    }
    function Read_aiVertexWeight(stream) {
      var w = new aiVertexWeight();
      w.mVertexId = Read_unsigned_int(stream);
      w.mWeight = readFloat(stream);
      return w;
    }
    function Read_aiMatrix4x4(stream) {
      var m2 = new aiMatrix4();
      for (let i2 = 0; i2 < 4; ++i2) {
        for (let i22 = 0; i22 < 4; ++i22) {
          m2.elements[i2][i22] = readFloat(stream);
        }
      }
      return m2;
    }
    function Read_aiVectorKey(stream) {
      var v3 = new aiVectorKey();
      v3.mTime = Read_double(stream);
      v3.mValue = Read_aiVector3D(stream);
      return v3;
    }
    function Read_aiQuatKey(stream) {
      var v3 = new aiQuatKey();
      v3.mTime = Read_double(stream);
      v3.mValue = Read_aiQuaternion(stream);
      return v3;
    }
    function ReadArray_aiVertexWeight(stream, data, size2) {
      for (let i2 = 0; i2 < size2; i2++)
        data[i2] = Read_aiVertexWeight(stream);
    }
    function ReadArray_aiVectorKey(stream, data, size2) {
      for (let i2 = 0; i2 < size2; i2++)
        data[i2] = Read_aiVectorKey(stream);
    }
    function ReadArray_aiQuatKey(stream, data, size2) {
      for (let i2 = 0; i2 < size2; i2++)
        data[i2] = Read_aiQuatKey(stream);
    }
    function ReadBounds(stream, T2, n) {
      return stream.Seek(sizeof(T2) * n, aiOrigin_CUR);
    }
    function ai_assert(bool2) {
      if (!bool2)
        throw "asset failed";
    }
    function ReadBinaryNode(stream, parent, depth) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AINODE);
      Read_uint32_t(stream);
      var node = new aiNode();
      node.mParent = parent;
      node.mDepth = depth;
      node.mName = Read_aiString(stream);
      node.mTransformation = Read_aiMatrix4x4(stream);
      node.mNumChildren = Read_unsigned_int(stream);
      node.mNumMeshes = Read_unsigned_int(stream);
      if (node.mNumMeshes) {
        node.mMeshes = [];
        for (let i2 = 0; i2 < node.mNumMeshes; ++i2) {
          node.mMeshes[i2] = Read_unsigned_int(stream);
        }
      }
      if (node.mNumChildren) {
        node.mChildren = [];
        for (let i2 = 0; i2 < node.mNumChildren; ++i2) {
          var node2 = ReadBinaryNode(stream, node, depth++);
          node.mChildren[i2] = node2;
        }
      }
      return node;
    }
    function ReadBinaryBone(stream, b2) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AIBONE);
      Read_uint32_t(stream);
      b2.mName = Read_aiString(stream);
      b2.mNumWeights = Read_unsigned_int(stream);
      b2.mOffsetMatrix = Read_aiMatrix4x4(stream);
      if (shortened) {
        ReadBounds(stream, b2.mWeights, b2.mNumWeights);
      } else {
        b2.mWeights = [];
        ReadArray_aiVertexWeight(stream, b2.mWeights, b2.mNumWeights);
      }
      return b2;
    }
    function ReadBinaryMesh(stream, mesh) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AIMESH);
      Read_uint32_t(stream);
      mesh.mPrimitiveTypes = Read_unsigned_int(stream);
      mesh.mNumVertices = Read_unsigned_int(stream);
      mesh.mNumFaces = Read_unsigned_int(stream);
      mesh.mNumBones = Read_unsigned_int(stream);
      mesh.mMaterialIndex = Read_unsigned_int(stream);
      mesh.mNumUVComponents = [];
      var c2 = Read_unsigned_int(stream);
      if (c2 & ASSBIN_MESH_HAS_POSITIONS) {
        if (shortened) {
          ReadBounds(stream, mesh.mVertices, mesh.mNumVertices);
        } else {
          mesh.mVertices = [];
          mesh.mVertexBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);
          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);
        }
      }
      if (c2 & ASSBIN_MESH_HAS_NORMALS) {
        if (shortened) {
          ReadBounds(stream, mesh.mNormals, mesh.mNumVertices);
        } else {
          mesh.mNormals = [];
          mesh.mNormalBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);
          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);
        }
      }
      if (c2 & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS) {
        if (shortened) {
          ReadBounds(stream, mesh.mTangents, mesh.mNumVertices);
          ReadBounds(stream, mesh.mBitangents, mesh.mNumVertices);
        } else {
          mesh.mTangents = [];
          mesh.mTangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);
          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);
          mesh.mBitangents = [];
          mesh.mBitangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);
          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);
        }
      }
      for (let n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++n) {
        if (!(c2 & ASSBIN_MESH_HAS_COLOR(n)))
          break;
        if (shortened) {
          ReadBounds(stream, mesh.mColors[n], mesh.mNumVertices);
        } else {
          mesh.mColors[n] = [];
          mesh.mColorBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4);
          stream.Seek(mesh.mNumVertices * 4 * 4, aiOrigin_CUR);
        }
      }
      mesh.mTexCoordsBuffers = [];
      for (let n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++n) {
        if (!(c2 & ASSBIN_MESH_HAS_TEXCOORD(n)))
          break;
        mesh.mNumUVComponents[n] = Read_unsigned_int(stream);
        if (shortened) {
          ReadBounds(stream, mesh.mTextureCoords[n], mesh.mNumVertices);
        } else {
          mesh.mTextureCoords[n] = [];
          mesh.mTexCoordsBuffers[n] = [];
          for (let uv2 = 0; uv2 < mesh.mNumVertices; uv2++) {
            mesh.mTexCoordsBuffers[n].push(readFloat(stream));
            mesh.mTexCoordsBuffers[n].push(readFloat(stream));
            readFloat(stream);
          }
        }
      }
      if (shortened) {
        Read_unsigned_int(stream);
      } else {
        mesh.mFaces = [];
        mesh.mIndexArray = [];
        for (let i2 = 0; i2 < mesh.mNumFaces; ++i2) {
          var f = mesh.mFaces[i2] = new aiFace();
          f.mNumIndices = Read_uint16_t(stream);
          f.mIndices = [];
          for (let a2 = 0; a2 < f.mNumIndices; ++a2) {
            if (mesh.mNumVertices < 1 << 16) {
              f.mIndices[a2] = Read_uint16_t(stream);
            } else {
              f.mIndices[a2] = Read_unsigned_int(stream);
            }
          }
          if (f.mNumIndices === 3) {
            mesh.mIndexArray.push(f.mIndices[0]);
            mesh.mIndexArray.push(f.mIndices[1]);
            mesh.mIndexArray.push(f.mIndices[2]);
          } else if (f.mNumIndices === 4) {
            mesh.mIndexArray.push(f.mIndices[0]);
            mesh.mIndexArray.push(f.mIndices[1]);
            mesh.mIndexArray.push(f.mIndices[2]);
            mesh.mIndexArray.push(f.mIndices[2]);
            mesh.mIndexArray.push(f.mIndices[3]);
            mesh.mIndexArray.push(f.mIndices[0]);
          } else {
            throw new Error("Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.");
          }
        }
      }
      if (mesh.mNumBones) {
        mesh.mBones = [];
        for (let a2 = 0; a2 < mesh.mNumBones; ++a2) {
          mesh.mBones[a2] = new aiBone();
          ReadBinaryBone(stream, mesh.mBones[a2]);
        }
      }
    }
    function ReadBinaryMaterialProperty(stream, prop) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY);
      Read_uint32_t(stream);
      prop.mKey = Read_aiString(stream);
      prop.mSemantic = Read_unsigned_int(stream);
      prop.mIndex = Read_unsigned_int(stream);
      prop.mDataLength = Read_unsigned_int(stream);
      prop.mType = Read_unsigned_int(stream);
      prop.mData = [];
      stream.ReadBytes(prop.mData, 1, prop.mDataLength);
    }
    function ReadBinaryMaterial(stream, mat) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIAL);
      Read_uint32_t(stream);
      mat.mNumAllocated = mat.mNumProperties = Read_unsigned_int(stream);
      if (mat.mNumProperties) {
        if (mat.mProperties) {
          delete mat.mProperties;
        }
        mat.mProperties = [];
        for (let i2 = 0; i2 < mat.mNumProperties; ++i2) {
          mat.mProperties[i2] = new aiMaterialProperty();
          ReadBinaryMaterialProperty(stream, mat.mProperties[i2]);
        }
      }
    }
    function ReadBinaryNodeAnim(stream, nd) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AINODEANIM);
      Read_uint32_t(stream);
      nd.mNodeName = Read_aiString(stream);
      nd.mNumPositionKeys = Read_unsigned_int(stream);
      nd.mNumRotationKeys = Read_unsigned_int(stream);
      nd.mNumScalingKeys = Read_unsigned_int(stream);
      nd.mPreState = Read_unsigned_int(stream);
      nd.mPostState = Read_unsigned_int(stream);
      if (nd.mNumPositionKeys) {
        if (shortened) {
          ReadBounds(stream, nd.mPositionKeys, nd.mNumPositionKeys);
        } else {
          nd.mPositionKeys = [];
          ReadArray_aiVectorKey(stream, nd.mPositionKeys, nd.mNumPositionKeys);
        }
      }
      if (nd.mNumRotationKeys) {
        if (shortened) {
          ReadBounds(stream, nd.mRotationKeys, nd.mNumRotationKeys);
        } else {
          nd.mRotationKeys = [];
          ReadArray_aiQuatKey(stream, nd.mRotationKeys, nd.mNumRotationKeys);
        }
      }
      if (nd.mNumScalingKeys) {
        if (shortened) {
          ReadBounds(stream, nd.mScalingKeys, nd.mNumScalingKeys);
        } else {
          nd.mScalingKeys = [];
          ReadArray_aiVectorKey(stream, nd.mScalingKeys, nd.mNumScalingKeys);
        }
      }
    }
    function ReadBinaryAnim(stream, anim) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AIANIMATION);
      Read_uint32_t(stream);
      anim.mName = Read_aiString(stream);
      anim.mDuration = Read_double(stream);
      anim.mTicksPerSecond = Read_double(stream);
      anim.mNumChannels = Read_unsigned_int(stream);
      if (anim.mNumChannels) {
        anim.mChannels = [];
        for (let a2 = 0; a2 < anim.mNumChannels; ++a2) {
          anim.mChannels[a2] = new aiNodeAnim();
          ReadBinaryNodeAnim(stream, anim.mChannels[a2]);
        }
      }
    }
    function ReadBinaryTexture(stream, tex) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AITEXTURE);
      Read_uint32_t(stream);
      tex.mWidth = Read_unsigned_int(stream);
      tex.mHeight = Read_unsigned_int(stream);
      stream.ReadBytes(tex.achFormatHint, 1, 4);
      if (!shortened) {
        if (!tex.mHeight) {
          tex.pcData = [];
          stream.ReadBytes(tex.pcData, 1, tex.mWidth);
        } else {
          tex.pcData = [];
          stream.ReadBytes(tex.pcData, 1, tex.mWidth * tex.mHeight * 4);
        }
      }
    }
    function ReadBinaryLight(stream, l) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AILIGHT);
      Read_uint32_t(stream);
      l.mName = Read_aiString(stream);
      l.mType = Read_unsigned_int(stream);
      if (l.mType != aiLightSource_DIRECTIONAL) {
        l.mAttenuationConstant = readFloat(stream);
        l.mAttenuationLinear = readFloat(stream);
        l.mAttenuationQuadratic = readFloat(stream);
      }
      l.mColorDiffuse = Read_aiColor3D(stream);
      l.mColorSpecular = Read_aiColor3D(stream);
      l.mColorAmbient = Read_aiColor3D(stream);
      if (l.mType == aiLightSource_SPOT) {
        l.mAngleInnerCone = readFloat(stream);
        l.mAngleOuterCone = readFloat(stream);
      }
    }
    function ReadBinaryCamera(stream, cam) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AICAMERA);
      Read_uint32_t(stream);
      cam.mName = Read_aiString(stream);
      cam.mPosition = Read_aiVector3D(stream);
      cam.mLookAt = Read_aiVector3D(stream);
      cam.mUp = Read_aiVector3D(stream);
      cam.mHorizontalFOV = readFloat(stream);
      cam.mClipPlaneNear = readFloat(stream);
      cam.mClipPlaneFar = readFloat(stream);
      cam.mAspect = readFloat(stream);
    }
    function ReadBinaryScene(stream, scene) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AISCENE);
      Read_uint32_t(stream);
      scene.mFlags = Read_unsigned_int(stream);
      scene.mNumMeshes = Read_unsigned_int(stream);
      scene.mNumMaterials = Read_unsigned_int(stream);
      scene.mNumAnimations = Read_unsigned_int(stream);
      scene.mNumTextures = Read_unsigned_int(stream);
      scene.mNumLights = Read_unsigned_int(stream);
      scene.mNumCameras = Read_unsigned_int(stream);
      scene.mRootNode = new aiNode();
      scene.mRootNode = ReadBinaryNode(stream, null, 0);
      if (scene.mNumMeshes) {
        scene.mMeshes = [];
        for (let i2 = 0; i2 < scene.mNumMeshes; ++i2) {
          scene.mMeshes[i2] = new aiMesh();
          ReadBinaryMesh(stream, scene.mMeshes[i2]);
        }
      }
      if (scene.mNumMaterials) {
        scene.mMaterials = [];
        for (let i2 = 0; i2 < scene.mNumMaterials; ++i2) {
          scene.mMaterials[i2] = new aiMaterial();
          ReadBinaryMaterial(stream, scene.mMaterials[i2]);
        }
      }
      if (scene.mNumAnimations) {
        scene.mAnimations = [];
        for (let i2 = 0; i2 < scene.mNumAnimations; ++i2) {
          scene.mAnimations[i2] = new aiAnimation();
          ReadBinaryAnim(stream, scene.mAnimations[i2]);
        }
      }
      if (scene.mNumTextures) {
        scene.mTextures = [];
        for (let i2 = 0; i2 < scene.mNumTextures; ++i2) {
          scene.mTextures[i2] = new aiTexture();
          ReadBinaryTexture(stream, scene.mTextures[i2]);
        }
      }
      if (scene.mNumLights) {
        scene.mLights = [];
        for (let i2 = 0; i2 < scene.mNumLights; ++i2) {
          scene.mLights[i2] = new aiLight();
          ReadBinaryLight(stream, scene.mLights[i2]);
        }
      }
      if (scene.mNumCameras) {
        scene.mCameras = [];
        for (let i2 = 0; i2 < scene.mNumCameras; ++i2) {
          scene.mCameras[i2] = new aiCamera();
          ReadBinaryCamera(stream, scene.mCameras[i2]);
        }
      }
    }
    var aiOrigin_CUR = 0;
    var aiOrigin_BEG = 1;
    function extendStream(stream) {
      stream.readOffset = 0;
      stream.Seek = function(off, ori) {
        if (ori == aiOrigin_CUR) {
          stream.readOffset += off;
        }
        if (ori == aiOrigin_BEG) {
          stream.readOffset = off;
        }
      };
      stream.ReadBytes = function(buff, size2, n) {
        var bytes = size2 * n;
        for (let i2 = 0; i2 < bytes; i2++)
          buff[i2] = Read_uint8_t(this);
      };
      stream.subArray32 = function(start, end) {
        var buff = this.buffer;
        var newbuff = buff.slice(start, end);
        return new Float32Array(newbuff);
      };
      stream.subArrayUint16 = function(start, end) {
        var buff = this.buffer;
        var newbuff = buff.slice(start, end);
        return new Uint16Array(newbuff);
      };
      stream.subArrayUint8 = function(start, end) {
        var buff = this.buffer;
        var newbuff = buff.slice(start, end);
        return new Uint8Array(newbuff);
      };
      stream.subArrayUint32 = function(start, end) {
        var buff = this.buffer;
        var newbuff = buff.slice(start, end);
        return new Uint32Array(newbuff);
      };
    }
    var shortened, compressed;
    function InternReadFile(pFiledata) {
      var pScene = new aiScene();
      var stream = new DataView(pFiledata);
      extendStream(stream);
      stream.Seek(44, aiOrigin_CUR);
      pScene.versionMajor = Read_unsigned_int(stream);
      pScene.versionMinor = Read_unsigned_int(stream);
      pScene.versionRevision = Read_unsigned_int(stream);
      pScene.compileFlags = Read_unsigned_int(stream);
      shortened = Read_uint16_t(stream) > 0;
      compressed = Read_uint16_t(stream) > 0;
      if (shortened)
        throw "Shortened binaries are not supported!";
      stream.Seek(256, aiOrigin_CUR);
      stream.Seek(128, aiOrigin_CUR);
      stream.Seek(64, aiOrigin_CUR);
      if (compressed) {
        var uncompressedSize = Read_uint32_t(stream);
        var compressedSize = stream.FileSize() - stream.Tell();
        var compressedData = [];
        stream.Read(compressedData, 1, compressedSize);
        var uncompressedData = [];
        uncompress(uncompressedData, uncompressedSize, compressedData, compressedSize);
        var buff = new ArrayBuffer(uncompressedData);
        ReadBinaryScene(buff, pScene);
      } else {
        ReadBinaryScene(stream, pScene);
      }
      return pScene.toTHREE();
    }
    return InternReadFile(buffer2);
  }
});

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/loaders/BasisTextureLoader.js
var _taskCache2 = /* @__PURE__ */ new WeakMap();
var BasisTextureLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.transcoderPath = "";
    this.transcoderBinary = null;
    this.transcoderPending = null;
    this.workerLimit = 4;
    this.workerPool = [];
    this.workerNextTaskID = 1;
    this.workerSourceURL = "";
    this.workerConfig = null;
  }
  setTranscoderPath(path) {
    this.transcoderPath = path;
    return this;
  }
  setWorkerLimit(workerLimit) {
    this.workerLimit = workerLimit;
    return this;
  }
  detectSupport(renderer) {
    this.workerConfig = {
      astcSupported: renderer.extensions.has("WEBGL_compressed_texture_astc"),
      etc1Supported: renderer.extensions.has("WEBGL_compressed_texture_etc1"),
      etc2Supported: renderer.extensions.has("WEBGL_compressed_texture_etc"),
      dxtSupported: renderer.extensions.has("WEBGL_compressed_texture_s3tc"),
      bptcSupported: renderer.extensions.has("EXT_texture_compression_bptc"),
      pvrtcSupported: renderer.extensions.has("WEBGL_compressed_texture_pvrtc") || renderer.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
    };
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    const loader = new FileLoader2(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setWithCredentials(this.withCredentials);
    const texture2 = new CompressedTexture();
    loader.load(url, (buffer2) => {
      if (_taskCache2.has(buffer2)) {
        const cachedTask = _taskCache2.get(buffer2);
        return cachedTask.promise.then(onLoad).catch(onError);
      }
      this._createTexture([buffer2]).then(function(_texture) {
        texture2.copy(_texture);
        texture2.needsUpdate = true;
        if (onLoad)
          onLoad(texture2);
      }).catch(onError);
    }, onProgress, onError);
    return texture2;
  }
  parseInternalAsync(options) {
    const {
      levels
    } = options;
    const buffers = /* @__PURE__ */ new Set();
    for (let i2 = 0; i2 < levels.length; i2++) {
      buffers.add(levels[i2].data.buffer);
    }
    return this._createTexture(Array.from(buffers), {
      ...options,
      lowLevel: true
    });
  }
  _createTexture(buffers, config = {}) {
    let worker;
    let taskID;
    const taskConfig = config;
    let taskCost = 0;
    for (let i2 = 0; i2 < buffers.length; i2++) {
      taskCost += buffers[i2].byteLength;
    }
    const texturePending = this._allocateWorker(taskCost).then((_worker) => {
      worker = _worker;
      taskID = this.workerNextTaskID++;
      return new Promise((resolve, reject) => {
        worker._callbacks[taskID] = {
          resolve,
          reject
        };
        worker.postMessage({
          type: "transcode",
          id: taskID,
          buffers,
          taskConfig
        }, buffers);
      });
    }).then((message) => {
      const {
        mipmaps,
        width,
        height,
        format
      } = message;
      const texture2 = new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);
      texture2.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;
      texture2.magFilter = LinearFilter;
      texture2.generateMipmaps = false;
      texture2.needsUpdate = true;
      return texture2;
    });
    texturePending.catch(() => true).then(() => {
      if (worker && taskID) {
        worker._taskLoad -= taskCost;
        delete worker._callbacks[taskID];
      }
    });
    _taskCache2.set(buffers[0], {
      promise: texturePending
    });
    return texturePending;
  }
  _initTranscoder() {
    if (!this.transcoderPending) {
      const jsLoader = new FileLoader2(this.manager);
      jsLoader.setPath(this.transcoderPath);
      jsLoader.setWithCredentials(this.withCredentials);
      const jsContent = new Promise((resolve, reject) => {
        jsLoader.load("basis_transcoder.js", resolve, void 0, reject);
      });
      const binaryLoader = new FileLoader2(this.manager);
      binaryLoader.setPath(this.transcoderPath);
      binaryLoader.setResponseType("arraybuffer");
      binaryLoader.setWithCredentials(this.withCredentials);
      const binaryContent = new Promise((resolve, reject) => {
        binaryLoader.load("basis_transcoder.wasm", resolve, void 0, reject);
      });
      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {
        const fn = BasisTextureLoader.BasisWorker.toString();
        const body = ["/* constants */", "let _EngineFormat = " + JSON.stringify(BasisTextureLoader.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(BasisTextureLoader.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(BasisTextureLoader.BasisFormat), "/* basis_transcoder.js */", jsContent2, "/* worker */", fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))].join("\n");
        this.workerSourceURL = URL.createObjectURL(new Blob([body]));
        this.transcoderBinary = binaryContent2;
      });
    }
    return this.transcoderPending;
  }
  _allocateWorker(taskCost) {
    return this._initTranscoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const worker2 = new Worker(this.workerSourceURL);
        worker2._callbacks = {};
        worker2._taskLoad = 0;
        worker2.postMessage({
          type: "init",
          config: this.workerConfig,
          transcoderBinary: this.transcoderBinary
        });
        worker2.onmessage = function(e) {
          const message = e.data;
          switch (message.type) {
            case "transcode":
              worker2._callbacks[message.id].resolve(message);
              break;
            case "error":
              worker2._callbacks[message.id].reject(message);
              break;
            default:
              console.error('THREE.BasisTextureLoader: Unexpected message, "' + message.type + '"');
          }
        };
        this.workerPool.push(worker2);
      } else {
        this.workerPool.sort(function(a2, b2) {
          return a2._taskLoad > b2._taskLoad ? -1 : 1;
        });
      }
      const worker = this.workerPool[this.workerPool.length - 1];
      worker._taskLoad += taskCost;
      return worker;
    });
  }
  dispose() {
    for (let i2 = 0; i2 < this.workerPool.length; i2++) {
      this.workerPool[i2].terminate();
    }
    this.workerPool.length = 0;
    return this;
  }
};
BasisTextureLoader.BasisFormat = {
  ETC1S: 0,
  UASTC_4x4: 1
};
BasisTextureLoader.TranscoderFormat = {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16
};
BasisTextureLoader.EngineFormat = {
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format
};
BasisTextureLoader.BasisWorker = function() {
  let config;
  let transcoderPending;
  let BasisModule;
  const EngineFormat = _EngineFormat;
  const TranscoderFormat = _TranscoderFormat;
  const BasisFormat = _BasisFormat;
  onmessage = function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        config = message.config;
        init(message.transcoderBinary);
        break;
      case "transcode":
        transcoderPending.then(() => {
          try {
            const {
              width,
              height,
              hasAlpha,
              mipmaps,
              format
            } = message.taskConfig.lowLevel ? transcodeLowLevel(message.taskConfig) : transcode(message.buffers[0]);
            const buffers = [];
            for (let i2 = 0; i2 < mipmaps.length; ++i2) {
              buffers.push(mipmaps[i2].data.buffer);
            }
            self.postMessage({
              type: "transcode",
              id: message.id,
              width,
              height,
              hasAlpha,
              mipmaps,
              format
            }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({
              type: "error",
              id: message.id,
              error: error.message
            });
          }
        });
        break;
    }
  };
  function init(wasmBinary) {
    transcoderPending = new Promise((resolve) => {
      BasisModule = {
        wasmBinary,
        onRuntimeInitialized: resolve
      };
      BASIS(BasisModule);
    }).then(() => {
      BasisModule.initializeBasis();
    });
  }
  function transcodeLowLevel(taskConfig) {
    const {
      basisFormat,
      width,
      height,
      hasAlpha
    } = taskConfig;
    const {
      transcoderFormat,
      engineFormat
    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);
    const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);
    assert(BasisModule.isFormatSupported(transcoderFormat), "THREE.BasisTextureLoader: Unsupported format.");
    const mipmaps = [];
    if (basisFormat === BasisFormat.ETC1S) {
      const transcoder = new BasisModule.LowLevelETC1SImageTranscoder();
      const {
        endpointCount,
        endpointsData,
        selectorCount,
        selectorsData,
        tablesData
      } = taskConfig.globalData;
      try {
        let ok;
        ok = transcoder.decodePalettes(endpointCount, endpointsData, selectorCount, selectorsData);
        assert(ok, "THREE.BasisTextureLoader: decodePalettes() failed.");
        ok = transcoder.decodeTables(tablesData);
        assert(ok, "THREE.BasisTextureLoader: decodeTables() failed.");
        for (let i2 = 0; i2 < taskConfig.levels.length; i2++) {
          const level = taskConfig.levels[i2];
          const imageDesc = taskConfig.globalData.imageDescs[i2];
          const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);
          const dst = new Uint8Array(dstByteLength);
          ok = transcoder.transcodeImage(transcoderFormat, dst, dstByteLength / blockByteLength, level.data, getWidthInBlocks(transcoderFormat, level.width), getHeightInBlocks(transcoderFormat, level.height), level.width, level.height, level.index, imageDesc.rgbSliceByteOffset, imageDesc.rgbSliceByteLength, imageDesc.alphaSliceByteOffset, imageDesc.alphaSliceByteLength, imageDesc.imageFlags, hasAlpha, false, 0, 0);
          assert(ok, "THREE.BasisTextureLoader: transcodeImage() failed for level " + level.index + ".");
          mipmaps.push({
            data: dst,
            width: level.width,
            height: level.height
          });
        }
      } finally {
        transcoder.delete();
      }
    } else {
      for (let i2 = 0; i2 < taskConfig.levels.length; i2++) {
        const level = taskConfig.levels[i2];
        const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);
        const dst = new Uint8Array(dstByteLength);
        const ok = BasisModule.transcodeUASTCImage(transcoderFormat, dst, dstByteLength / blockByteLength, level.data, getWidthInBlocks(transcoderFormat, level.width), getHeightInBlocks(transcoderFormat, level.height), level.width, level.height, level.index, 0, level.data.byteLength, 0, hasAlpha, false, 0, 0, -1, -1);
        assert(ok, "THREE.BasisTextureLoader: transcodeUASTCImage() failed for level " + level.index + ".");
        mipmaps.push({
          data: dst,
          width: level.width,
          height: level.height
        });
      }
    }
    return {
      width,
      height,
      hasAlpha,
      mipmaps,
      format: engineFormat
    };
  }
  function transcode(buffer2) {
    const basisFile = new BasisModule.BasisFile(new Uint8Array(buffer2));
    const basisFormat = basisFile.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;
    const width = basisFile.getImageWidth(0, 0);
    const height = basisFile.getImageHeight(0, 0);
    const levels = basisFile.getNumLevels(0);
    const hasAlpha = basisFile.getHasAlpha();
    function cleanup() {
      basisFile.close();
      basisFile.delete();
    }
    const {
      transcoderFormat,
      engineFormat
    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);
    if (!width || !height || !levels) {
      cleanup();
      throw new Error("THREE.BasisTextureLoader:	Invalid texture");
    }
    if (!basisFile.startTranscoding()) {
      cleanup();
      throw new Error("THREE.BasisTextureLoader: .startTranscoding failed");
    }
    const mipmaps = [];
    for (let mip = 0; mip < levels; mip++) {
      const mipWidth = basisFile.getImageWidth(0, mip);
      const mipHeight = basisFile.getImageHeight(0, mip);
      const dst = new Uint8Array(basisFile.getImageTranscodedSizeInBytes(0, mip, transcoderFormat));
      const status = basisFile.transcodeImage(dst, 0, mip, transcoderFormat, 0, hasAlpha);
      if (!status) {
        cleanup();
        throw new Error("THREE.BasisTextureLoader: .transcodeImage failed.");
      }
      mipmaps.push({
        data: dst,
        width: mipWidth,
        height: mipHeight
      });
    }
    cleanup();
    return {
      width,
      height,
      hasAlpha,
      mipmaps,
      format: engineFormat
    };
  }
  const FORMAT_OPTIONS = [{
    if: "astcSupported",
    basisFormat: [BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],
    engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],
    priorityETC1S: Infinity,
    priorityUASTC: 1,
    needsPowerOfTwo: false
  }, {
    if: "bptcSupported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],
    engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],
    priorityETC1S: 3,
    priorityUASTC: 2,
    needsPowerOfTwo: false
  }, {
    if: "dxtSupported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],
    engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],
    priorityETC1S: 4,
    priorityUASTC: 5,
    needsPowerOfTwo: false
  }, {
    if: "etc2Supported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],
    engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],
    priorityETC1S: 1,
    priorityUASTC: 3,
    needsPowerOfTwo: false
  }, {
    if: "etc1Supported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC1],
    engineFormat: [EngineFormat.RGB_ETC1_Format, EngineFormat.RGB_ETC1_Format],
    priorityETC1S: 2,
    priorityUASTC: 4,
    needsPowerOfTwo: false
  }, {
    if: "pvrtcSupported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],
    engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],
    priorityETC1S: 5,
    priorityUASTC: 6,
    needsPowerOfTwo: true
  }];
  const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function(a2, b2) {
    return a2.priorityETC1S - b2.priorityETC1S;
  });
  const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function(a2, b2) {
    return a2.priorityUASTC - b2.priorityUASTC;
  });
  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {
    let transcoderFormat;
    let engineFormat;
    const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;
    for (let i2 = 0; i2 < options.length; i2++) {
      const opt = options[i2];
      if (!config[opt.if])
        continue;
      if (!opt.basisFormat.includes(basisFormat))
        continue;
      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height)))
        continue;
      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];
      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];
      return {
        transcoderFormat,
        engineFormat
      };
    }
    console.warn("THREE.BasisTextureLoader: No suitable compressed texture format found. Decoding to RGBA32.");
    transcoderFormat = TranscoderFormat.RGBA32;
    engineFormat = EngineFormat.RGBAFormat;
    return {
      transcoderFormat,
      engineFormat
    };
  }
  function assert(ok, message) {
    if (!ok)
      throw new Error(message);
  }
  function getWidthInBlocks(transcoderFormat, width) {
    return Math.ceil(width / BasisModule.getFormatBlockWidth(transcoderFormat));
  }
  function getHeightInBlocks(transcoderFormat, height) {
    return Math.ceil(height / BasisModule.getFormatBlockHeight(transcoderFormat));
  }
  function getTranscodedImageByteLength(transcoderFormat, width, height) {
    const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);
    if (BasisModule.formatIsUncompressed(transcoderFormat)) {
      return width * height * blockByteLength;
    }
    if (transcoderFormat === TranscoderFormat.PVRTC1_4_RGB || transcoderFormat === TranscoderFormat.PVRTC1_4_RGBA) {
      const paddedWidth = width + 3 & ~3;
      const paddedHeight = height + 3 & ~3;
      return (Math.max(8, paddedWidth) * Math.max(8, paddedHeight) * 4 + 7) / 8;
    }
    return getWidthInBlocks(transcoderFormat, width) * getHeightInBlocks(transcoderFormat, height) * blockByteLength;
  }
  function isPowerOfTwo(value) {
    if (value <= 2)
      return true;
    return (value & value - 1) === 0 && value !== 0;
  }
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/loaders/LDrawLoader.js
var _tempVec0 = new Vector3();
var _tempVec1 = new Vector3();
var _ray = new Ray();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/loaders/lwo/LWO3Parser.js
function LWO3Parser(IFFParser2) {
  this.IFF = IFFParser2;
}
LWO3Parser.prototype = {
  constructor: LWO3Parser,
  parseBlock: function() {
    this.IFF.debugger.offset = this.IFF.reader.offset;
    this.IFF.debugger.closeForms();
    var blockID = this.IFF.reader.getIDTag();
    var length2 = this.IFF.reader.getUint32();
    this.IFF.debugger.dataOffset = this.IFF.reader.offset;
    this.IFF.debugger.length = length2;
    switch (blockID) {
      case "FORM":
        this.IFF.parseForm(length2);
        break;
      case "ICON":
      case "VMPA":
      case "BBOX":
      case "NORM":
      case "PRE ":
      case "POST":
      case "KEY ":
      case "SPAN":
      case "TIME":
      case "CLRS":
      case "CLRA":
      case "FILT":
      case "DITH":
      case "CONT":
      case "BRIT":
      case "SATR":
      case "HUE ":
      case "GAMM":
      case "NEGA":
      case "IFLT":
      case "PFLT":
      case "PROJ":
      case "AXIS":
      case "AAST":
      case "PIXB":
      case "STCK":
      case "VALU":
      case "PNAM":
      case "INAM":
      case "GRST":
      case "GREN":
      case "GRPT":
      case "FKEY":
      case "IKEY":
      case "CSYS":
      case "OPAQ":
      case "CMAP":
      case "NLOC":
      case "NZOM":
      case "NVER":
      case "NSRV":
      case "NCRD":
      case "NMOD":
      case "NSEL":
      case "NPRW":
      case "NPLA":
      case "VERS":
      case "ENUM":
      case "TAG ":
      case "CGMD":
      case "CGTY":
      case "CGST":
      case "CGEN":
      case "CGTS":
      case "CGTE":
      case "OSMP":
      case "OMDE":
      case "OUTR":
      case "FLAG":
      case "TRNL":
      case "SHRP":
      case "RFOP":
      case "RSAN":
      case "TROP":
      case "RBLR":
      case "TBLR":
      case "CLRH":
      case "CLRF":
      case "ADTR":
      case "GLOW":
      case "LINE":
      case "ALPH":
      case "VCOL":
      case "ENAB":
        this.IFF.debugger.skipped = true;
        this.IFF.reader.skip(length2);
        break;
      case "IPIX":
      case "IMIP":
      case "IMOD":
      case "AMOD":
      case "IINV":
      case "INCR":
      case "IAXS":
      case "IFOT":
      case "ITIM":
      case "IWRL":
      case "IUTI":
      case "IINX":
      case "IINY":
      case "IINZ":
      case "IREF":
        if (length2 === 4)
          this.IFF.currentNode[blockID] = this.IFF.reader.getInt32();
        else
          this.IFF.reader.skip(length2);
        break;
      case "OTAG":
        this.IFF.parseObjectTag();
        break;
      case "LAYR":
        this.IFF.parseLayer(length2);
        break;
      case "PNTS":
        this.IFF.parsePoints(length2);
        break;
      case "VMAP":
        this.IFF.parseVertexMapping(length2);
        break;
      case "POLS":
        this.IFF.parsePolygonList(length2);
        break;
      case "TAGS":
        this.IFF.parseTagStrings(length2);
        break;
      case "PTAG":
        this.IFF.parsePolygonTagMapping(length2);
        break;
      case "VMAD":
        this.IFF.parseVertexMapping(length2, true);
        break;
      case "DESC":
        this.IFF.currentForm.description = this.IFF.reader.getString();
        break;
      case "TEXT":
      case "CMNT":
      case "NCOM":
        this.IFF.currentForm.comment = this.IFF.reader.getString();
        break;
      case "NAME":
        this.IFF.currentForm.channelName = this.IFF.reader.getString();
        break;
      case "WRAP":
        this.IFF.currentForm.wrap = {
          w: this.IFF.reader.getUint16(),
          h: this.IFF.reader.getUint16()
        };
        break;
      case "IMAG":
        var index = this.IFF.reader.getVariableLengthIndex();
        this.IFF.currentForm.imageIndex = index;
        break;
      case "OREF":
        this.IFF.currentForm.referenceObject = this.IFF.reader.getString();
        break;
      case "ROID":
        this.IFF.currentForm.referenceObjectID = this.IFF.reader.getUint32();
        break;
      case "SSHN":
        this.IFF.currentSurface.surfaceShaderName = this.IFF.reader.getString();
        break;
      case "AOVN":
        this.IFF.currentSurface.surfaceCustomAOVName = this.IFF.reader.getString();
        break;
      case "NSTA":
        this.IFF.currentForm.disabled = this.IFF.reader.getUint16();
        break;
      case "NRNM":
        this.IFF.currentForm.realName = this.IFF.reader.getString();
        break;
      case "NNME":
        this.IFF.currentForm.refName = this.IFF.reader.getString();
        this.IFF.currentSurface.nodes[this.IFF.currentForm.refName] = this.IFF.currentForm;
        break;
      case "INME":
        if (!this.IFF.currentForm.nodeName)
          this.IFF.currentForm.nodeName = [];
        this.IFF.currentForm.nodeName.push(this.IFF.reader.getString());
        break;
      case "IINN":
        if (!this.IFF.currentForm.inputNodeName)
          this.IFF.currentForm.inputNodeName = [];
        this.IFF.currentForm.inputNodeName.push(this.IFF.reader.getString());
        break;
      case "IINM":
        if (!this.IFF.currentForm.inputName)
          this.IFF.currentForm.inputName = [];
        this.IFF.currentForm.inputName.push(this.IFF.reader.getString());
        break;
      case "IONM":
        if (!this.IFF.currentForm.inputOutputName)
          this.IFF.currentForm.inputOutputName = [];
        this.IFF.currentForm.inputOutputName.push(this.IFF.reader.getString());
        break;
      case "FNAM":
        this.IFF.currentForm.fileName = this.IFF.reader.getString();
        break;
      case "CHAN":
        if (length2 === 4)
          this.IFF.currentForm.textureChannel = this.IFF.reader.getIDTag();
        else
          this.IFF.reader.skip(length2);
        break;
      case "SMAN":
        var maxSmoothingAngle = this.IFF.reader.getFloat32();
        this.IFF.currentSurface.attributes.smooth = maxSmoothingAngle < 0 ? false : true;
        break;
      case "COLR":
        this.IFF.currentSurface.attributes.Color = {
          value: this.IFF.reader.getFloat32Array(3)
        };
        this.IFF.reader.skip(2);
        break;
      case "LUMI":
        this.IFF.currentSurface.attributes.Luminosity = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "SPEC":
        this.IFF.currentSurface.attributes.Specular = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "DIFF":
        this.IFF.currentSurface.attributes.Diffuse = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "REFL":
        this.IFF.currentSurface.attributes.Reflection = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "GLOS":
        this.IFF.currentSurface.attributes.Glossiness = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "TRAN":
        this.IFF.currentSurface.attributes.opacity = this.IFF.reader.getFloat32();
        this.IFF.reader.skip(2);
        break;
      case "BUMP":
        this.IFF.currentSurface.attributes.bumpStrength = this.IFF.reader.getFloat32();
        this.IFF.reader.skip(2);
        break;
      case "SIDE":
        this.IFF.currentSurface.attributes.side = this.IFF.reader.getUint16();
        break;
      case "RIMG":
        this.IFF.currentSurface.attributes.reflectionMap = this.IFF.reader.getVariableLengthIndex();
        break;
      case "RIND":
        this.IFF.currentSurface.attributes.refractiveIndex = this.IFF.reader.getFloat32();
        this.IFF.reader.skip(2);
        break;
      case "TIMG":
        this.IFF.currentSurface.attributes.refractionMap = this.IFF.reader.getVariableLengthIndex();
        break;
      case "IMAP":
        this.IFF.currentSurface.attributes.imageMapIndex = this.IFF.reader.getUint32();
        break;
      case "IUVI":
        this.IFF.currentNode.UVChannel = this.IFF.reader.getString(length2);
        break;
      case "IUTL":
        this.IFF.currentNode.widthWrappingMode = this.IFF.reader.getUint32();
        break;
      case "IVTL":
        this.IFF.currentNode.heightWrappingMode = this.IFF.reader.getUint32();
        break;
      default:
        this.IFF.parseUnknownCHUNK(blockID, length2);
    }
    if (blockID != "FORM") {
      this.IFF.debugger.node = 1;
      this.IFF.debugger.nodeID = blockID;
      this.IFF.debugger.log();
    }
    if (this.IFF.reader.offset >= this.IFF.currentFormEnd) {
      this.IFF.currentForm = this.IFF.parentForm;
    }
  }
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/loaders/lwo/LWO2Parser.js
function LWO2Parser(IFFParser2) {
  this.IFF = IFFParser2;
}
LWO2Parser.prototype = {
  constructor: LWO2Parser,
  parseBlock: function() {
    this.IFF.debugger.offset = this.IFF.reader.offset;
    this.IFF.debugger.closeForms();
    var blockID = this.IFF.reader.getIDTag();
    var length2 = this.IFF.reader.getUint32();
    if (length2 > this.IFF.reader.dv.byteLength - this.IFF.reader.offset) {
      this.IFF.reader.offset -= 4;
      length2 = this.IFF.reader.getUint16();
    }
    this.IFF.debugger.dataOffset = this.IFF.reader.offset;
    this.IFF.debugger.length = length2;
    switch (blockID) {
      case "FORM":
        this.IFF.parseForm(length2);
        break;
      case "ICON":
      case "VMPA":
      case "BBOX":
      case "NORM":
      case "PRE ":
      case "POST":
      case "KEY ":
      case "SPAN":
      case "TIME":
      case "CLRS":
      case "CLRA":
      case "FILT":
      case "DITH":
      case "CONT":
      case "BRIT":
      case "SATR":
      case "HUE ":
      case "GAMM":
      case "NEGA":
      case "IFLT":
      case "PFLT":
      case "PROJ":
      case "AXIS":
      case "AAST":
      case "PIXB":
      case "AUVO":
      case "STCK":
      case "PROC":
      case "VALU":
      case "FUNC":
      case "PNAM":
      case "INAM":
      case "GRST":
      case "GREN":
      case "GRPT":
      case "FKEY":
      case "IKEY":
      case "CSYS":
      case "OPAQ":
      case "CMAP":
      case "NLOC":
      case "NZOM":
      case "NVER":
      case "NSRV":
      case "NVSK":
      case "NCRD":
      case "WRPW":
      case "WRPH":
      case "NMOD":
      case "NPRW":
      case "NPLA":
      case "NODS":
      case "VERS":
      case "ENUM":
      case "TAG ":
      case "OPAC":
      case "CGMD":
      case "CGTY":
      case "CGST":
      case "CGEN":
      case "CGTS":
      case "CGTE":
      case "OSMP":
      case "OMDE":
      case "OUTR":
      case "FLAG":
      case "TRNL":
      case "GLOW":
      case "GVAL":
      case "SHRP":
      case "RFOP":
      case "RSAN":
      case "TROP":
      case "RBLR":
      case "TBLR":
      case "CLRH":
      case "CLRF":
      case "ADTR":
      case "LINE":
      case "ALPH":
      case "VCOL":
      case "ENAB":
        this.IFF.debugger.skipped = true;
        this.IFF.reader.skip(length2);
        break;
      case "SURF":
        this.IFF.parseSurfaceLwo2(length2);
        break;
      case "CLIP":
        this.IFF.parseClipLwo2(length2);
        break;
      case "IPIX":
      case "IMIP":
      case "IMOD":
      case "AMOD":
      case "IINV":
      case "INCR":
      case "IAXS":
      case "IFOT":
      case "ITIM":
      case "IWRL":
      case "IUTI":
      case "IINX":
      case "IINY":
      case "IINZ":
      case "IREF":
        if (length2 === 4)
          this.IFF.currentNode[blockID] = this.IFF.reader.getInt32();
        else
          this.IFF.reader.skip(length2);
        break;
      case "OTAG":
        this.IFF.parseObjectTag();
        break;
      case "LAYR":
        this.IFF.parseLayer(length2);
        break;
      case "PNTS":
        this.IFF.parsePoints(length2);
        break;
      case "VMAP":
        this.IFF.parseVertexMapping(length2);
        break;
      case "AUVU":
      case "AUVN":
        this.IFF.reader.skip(length2 - 1);
        this.IFF.reader.getVariableLengthIndex();
        break;
      case "POLS":
        this.IFF.parsePolygonList(length2);
        break;
      case "TAGS":
        this.IFF.parseTagStrings(length2);
        break;
      case "PTAG":
        this.IFF.parsePolygonTagMapping(length2);
        break;
      case "VMAD":
        this.IFF.parseVertexMapping(length2, true);
        break;
      case "DESC":
        this.IFF.currentForm.description = this.IFF.reader.getString();
        break;
      case "TEXT":
      case "CMNT":
      case "NCOM":
        this.IFF.currentForm.comment = this.IFF.reader.getString();
        break;
      case "NAME":
        this.IFF.currentForm.channelName = this.IFF.reader.getString();
        break;
      case "WRAP":
        this.IFF.currentForm.wrap = {
          w: this.IFF.reader.getUint16(),
          h: this.IFF.reader.getUint16()
        };
        break;
      case "IMAG":
        var index = this.IFF.reader.getVariableLengthIndex();
        this.IFF.currentForm.imageIndex = index;
        break;
      case "OREF":
        this.IFF.currentForm.referenceObject = this.IFF.reader.getString();
        break;
      case "ROID":
        this.IFF.currentForm.referenceObjectID = this.IFF.reader.getUint32();
        break;
      case "SSHN":
        this.IFF.currentSurface.surfaceShaderName = this.IFF.reader.getString();
        break;
      case "AOVN":
        this.IFF.currentSurface.surfaceCustomAOVName = this.IFF.reader.getString();
        break;
      case "NSTA":
        this.IFF.currentForm.disabled = this.IFF.reader.getUint16();
        break;
      case "NRNM":
        this.IFF.currentForm.realName = this.IFF.reader.getString();
        break;
      case "NNME":
        this.IFF.currentForm.refName = this.IFF.reader.getString();
        this.IFF.currentSurface.nodes[this.IFF.currentForm.refName] = this.IFF.currentForm;
        break;
      case "INME":
        if (!this.IFF.currentForm.nodeName)
          this.IFF.currentForm.nodeName = [];
        this.IFF.currentForm.nodeName.push(this.IFF.reader.getString());
        break;
      case "IINN":
        if (!this.IFF.currentForm.inputNodeName)
          this.IFF.currentForm.inputNodeName = [];
        this.IFF.currentForm.inputNodeName.push(this.IFF.reader.getString());
        break;
      case "IINM":
        if (!this.IFF.currentForm.inputName)
          this.IFF.currentForm.inputName = [];
        this.IFF.currentForm.inputName.push(this.IFF.reader.getString());
        break;
      case "IONM":
        if (!this.IFF.currentForm.inputOutputName)
          this.IFF.currentForm.inputOutputName = [];
        this.IFF.currentForm.inputOutputName.push(this.IFF.reader.getString());
        break;
      case "FNAM":
        this.IFF.currentForm.fileName = this.IFF.reader.getString();
        break;
      case "CHAN":
        if (length2 === 4)
          this.IFF.currentForm.textureChannel = this.IFF.reader.getIDTag();
        else
          this.IFF.reader.skip(length2);
        break;
      case "SMAN":
        var maxSmoothingAngle = this.IFF.reader.getFloat32();
        this.IFF.currentSurface.attributes.smooth = maxSmoothingAngle < 0 ? false : true;
        break;
      case "COLR":
        this.IFF.currentSurface.attributes.Color = {
          value: this.IFF.reader.getFloat32Array(3)
        };
        this.IFF.reader.skip(2);
        break;
      case "LUMI":
        this.IFF.currentSurface.attributes.Luminosity = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "SPEC":
        this.IFF.currentSurface.attributes.Specular = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "DIFF":
        this.IFF.currentSurface.attributes.Diffuse = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "REFL":
        this.IFF.currentSurface.attributes.Reflection = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "GLOS":
        this.IFF.currentSurface.attributes.Glossiness = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "TRAN":
        this.IFF.currentSurface.attributes.opacity = this.IFF.reader.getFloat32();
        this.IFF.reader.skip(2);
        break;
      case "BUMP":
        this.IFF.currentSurface.attributes.bumpStrength = this.IFF.reader.getFloat32();
        this.IFF.reader.skip(2);
        break;
      case "SIDE":
        this.IFF.currentSurface.attributes.side = this.IFF.reader.getUint16();
        break;
      case "RIMG":
        this.IFF.currentSurface.attributes.reflectionMap = this.IFF.reader.getVariableLengthIndex();
        break;
      case "RIND":
        this.IFF.currentSurface.attributes.refractiveIndex = this.IFF.reader.getFloat32();
        this.IFF.reader.skip(2);
        break;
      case "TIMG":
        this.IFF.currentSurface.attributes.refractionMap = this.IFF.reader.getVariableLengthIndex();
        break;
      case "IMAP":
        this.IFF.reader.skip(2);
        break;
      case "TMAP":
        this.IFF.debugger.skipped = true;
        this.IFF.reader.skip(length2);
        break;
      case "IUVI":
        this.IFF.currentNode.UVChannel = this.IFF.reader.getString(length2);
        break;
      case "IUTL":
        this.IFF.currentNode.widthWrappingMode = this.IFF.reader.getUint32();
        break;
      case "IVTL":
        this.IFF.currentNode.heightWrappingMode = this.IFF.reader.getUint32();
        break;
      case "BLOK":
        break;
      default:
        this.IFF.parseUnknownCHUNK(blockID, length2);
    }
    if (blockID != "FORM") {
      this.IFF.debugger.node = 1;
      this.IFF.debugger.nodeID = blockID;
      this.IFF.debugger.log();
    }
    if (this.IFF.reader.offset >= this.IFF.currentFormEnd) {
      this.IFF.currentForm = this.IFF.parentForm;
    }
  }
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/loaders/lwo/IFFParser.js
function IFFParser() {
  this.debugger = new Debugger();
}
IFFParser.prototype = {
  constructor: IFFParser,
  parse: function(buffer2) {
    this.reader = new DataViewReader(buffer2);
    this.tree = {
      materials: {},
      layers: [],
      tags: [],
      textures: []
    };
    this.currentLayer = this.tree;
    this.currentForm = this.tree;
    this.parseTopForm();
    if (this.tree.format === void 0)
      return;
    if (this.tree.format === "LWO2") {
      this.parser = new LWO2Parser(this);
      while (!this.reader.endOfFile())
        this.parser.parseBlock();
    } else if (this.tree.format === "LWO3") {
      this.parser = new LWO3Parser(this);
      while (!this.reader.endOfFile())
        this.parser.parseBlock();
    }
    this.debugger.offset = this.reader.offset;
    this.debugger.closeForms();
    return this.tree;
  },
  parseTopForm() {
    this.debugger.offset = this.reader.offset;
    var topForm = this.reader.getIDTag();
    if (topForm !== "FORM") {
      console.warn("LWOLoader: Top-level FORM missing.");
      return;
    }
    var length2 = this.reader.getUint32();
    this.debugger.dataOffset = this.reader.offset;
    this.debugger.length = length2;
    var type2 = this.reader.getIDTag();
    if (type2 === "LWO2") {
      this.tree.format = type2;
    } else if (type2 === "LWO3") {
      this.tree.format = type2;
    }
    this.debugger.node = 0;
    this.debugger.nodeID = type2;
    this.debugger.log();
    return;
  },
  parseForm(length2) {
    var type2 = this.reader.getIDTag();
    switch (type2) {
      case "ISEQ":
      case "ANIM":
      case "STCC":
      case "VPVL":
      case "VPRM":
      case "NROT":
      case "WRPW":
      case "WRPH":
      case "FUNC":
      case "FALL":
      case "OPAC":
      case "GRAD":
      case "ENVS":
      case "VMOP":
      case "VMBG":
      case "OMAX":
      case "STEX":
      case "CKBG":
      case "CKEY":
      case "VMLA":
      case "VMLB":
        this.debugger.skipped = true;
        this.skipForm(length2);
        break;
      case "META":
      case "NNDS":
      case "NODS":
      case "NDTA":
      case "ADAT":
      case "AOVS":
      case "BLOK":
      case "IBGC":
      case "IOPC":
      case "IIMG":
      case "TXTR":
        this.debugger.length = 4;
        this.debugger.skipped = true;
        break;
      case "IFAL":
      case "ISCL":
      case "IPOS":
      case "IROT":
      case "IBMP":
      case "IUTD":
      case "IVTD":
        this.parseTextureNodeAttribute(type2);
        break;
      case "ENVL":
        this.parseEnvelope(length2);
        break;
      case "CLIP":
        if (this.tree.format === "LWO2") {
          this.parseForm(length2);
        } else {
          this.parseClip(length2);
        }
        break;
      case "STIL":
        this.parseImage();
        break;
      case "XREF":
        this.reader.skip(8);
        this.currentForm.referenceTexture = {
          index: this.reader.getUint32(),
          refName: this.reader.getString()
        };
        break;
      case "IMST":
        this.parseImageStateForm(length2);
        break;
      case "SURF":
        this.parseSurfaceForm(length2);
        break;
      case "VALU":
        this.parseValueForm(length2);
        break;
      case "NTAG":
        this.parseSubNode(length2);
        break;
      case "ATTR":
      case "SATR":
        this.setupForm("attributes", length2);
        break;
      case "NCON":
        this.parseConnections(length2);
        break;
      case "SSHA":
        this.parentForm = this.currentForm;
        this.currentForm = this.currentSurface;
        this.setupForm("surfaceShader", length2);
        break;
      case "SSHD":
        this.setupForm("surfaceShaderData", length2);
        break;
      case "ENTR":
        this.parseEntryForm(length2);
        break;
      case "IMAP":
        this.parseImageMap(length2);
        break;
      case "TAMP":
        this.parseXVAL("amplitude", length2);
        break;
      case "TMAP":
        this.setupForm("textureMap", length2);
        break;
      case "CNTR":
        this.parseXVAL3("center", length2);
        break;
      case "SIZE":
        this.parseXVAL3("scale", length2);
        break;
      case "ROTA":
        this.parseXVAL3("rotation", length2);
        break;
      default:
        this.parseUnknownForm(type2, length2);
    }
    this.debugger.node = 0;
    this.debugger.nodeID = type2;
    this.debugger.log();
  },
  setupForm(type2, length2) {
    if (!this.currentForm)
      this.currentForm = this.currentNode;
    this.currentFormEnd = this.reader.offset + length2;
    this.parentForm = this.currentForm;
    if (!this.currentForm[type2]) {
      this.currentForm[type2] = {};
      this.currentForm = this.currentForm[type2];
    } else {
      console.warn("LWOLoader: form already exists on parent: ", type2, this.currentForm);
      this.currentForm = this.currentForm[type2];
    }
  },
  skipForm(length2) {
    this.reader.skip(length2 - 4);
  },
  parseUnknownForm(type2, length2) {
    console.warn("LWOLoader: unknown FORM encountered: " + type2, length2);
    printBuffer(this.reader.dv.buffer, this.reader.offset, length2 - 4);
    this.reader.skip(length2 - 4);
  },
  parseSurfaceForm(length2) {
    this.reader.skip(8);
    var name = this.reader.getString();
    var surface = {
      attributes: {},
      connections: {},
      name,
      inputName: name,
      nodes: {},
      source: this.reader.getString()
    };
    this.tree.materials[name] = surface;
    this.currentSurface = surface;
    this.parentForm = this.tree.materials;
    this.currentForm = surface;
    this.currentFormEnd = this.reader.offset + length2;
  },
  parseSurfaceLwo2(length2) {
    var name = this.reader.getString();
    var surface = {
      attributes: {},
      connections: {},
      name,
      nodes: {},
      source: this.reader.getString()
    };
    this.tree.materials[name] = surface;
    this.currentSurface = surface;
    this.parentForm = this.tree.materials;
    this.currentForm = surface;
    this.currentFormEnd = this.reader.offset + length2;
  },
  parseSubNode(length2) {
    this.reader.skip(8);
    var name = this.reader.getString();
    var node = {
      name
    };
    this.currentForm = node;
    this.currentNode = node;
    this.currentFormEnd = this.reader.offset + length2;
  },
  parseConnections(length2) {
    this.currentFormEnd = this.reader.offset + length2;
    this.parentForm = this.currentForm;
    this.currentForm = this.currentSurface.connections;
  },
  parseEntryForm(length2) {
    this.reader.skip(8);
    var name = this.reader.getString();
    this.currentForm = this.currentNode.attributes;
    this.setupForm(name, length2);
  },
  parseValueForm() {
    this.reader.skip(8);
    var valueType = this.reader.getString();
    if (valueType === "double") {
      this.currentForm.value = this.reader.getUint64();
    } else if (valueType === "int") {
      this.currentForm.value = this.reader.getUint32();
    } else if (valueType === "vparam") {
      this.reader.skip(24);
      this.currentForm.value = this.reader.getFloat64();
    } else if (valueType === "vparam3") {
      this.reader.skip(24);
      this.currentForm.value = this.reader.getFloat64Array(3);
    }
  },
  parseImageStateForm() {
    this.reader.skip(8);
    this.currentForm.mipMapLevel = this.reader.getFloat32();
  },
  parseImageMap(length2) {
    this.currentFormEnd = this.reader.offset + length2;
    this.parentForm = this.currentForm;
    if (!this.currentForm.maps)
      this.currentForm.maps = [];
    var map = {};
    this.currentForm.maps.push(map);
    this.currentForm = map;
    this.reader.skip(10);
  },
  parseTextureNodeAttribute(type2) {
    this.reader.skip(28);
    this.reader.skip(20);
    switch (type2) {
      case "ISCL":
        this.currentNode.scale = this.reader.getFloat32Array(3);
        break;
      case "IPOS":
        this.currentNode.position = this.reader.getFloat32Array(3);
        break;
      case "IROT":
        this.currentNode.rotation = this.reader.getFloat32Array(3);
        break;
      case "IFAL":
        this.currentNode.falloff = this.reader.getFloat32Array(3);
        break;
      case "IBMP":
        this.currentNode.amplitude = this.reader.getFloat32();
        break;
      case "IUTD":
        this.currentNode.uTiles = this.reader.getFloat32();
        break;
      case "IVTD":
        this.currentNode.vTiles = this.reader.getFloat32();
        break;
    }
    this.reader.skip(2);
  },
  parseEnvelope(length2) {
    this.reader.skip(length2 - 4);
  },
  parseClip(length2) {
    var tag = this.reader.getIDTag();
    if (tag === "FORM") {
      this.reader.skip(16);
      this.currentNode.fileName = this.reader.getString();
      return;
    }
    this.reader.setOffset(this.reader.offset - 4);
    this.currentFormEnd = this.reader.offset + length2;
    this.parentForm = this.currentForm;
    this.reader.skip(8);
    var texture2 = {
      index: this.reader.getUint32()
    };
    this.tree.textures.push(texture2);
    this.currentForm = texture2;
  },
  parseClipLwo2(length2) {
    var texture2 = {
      index: this.reader.getUint32(),
      fileName: ""
    };
    while (true) {
      var tag = this.reader.getIDTag();
      var n_length = this.reader.getUint16();
      if (tag === "STIL") {
        texture2.fileName = this.reader.getString();
        break;
      }
      if (n_length >= length2) {
        break;
      }
    }
    this.tree.textures.push(texture2);
    this.currentForm = texture2;
  },
  parseImage() {
    this.reader.skip(8);
    this.currentForm.fileName = this.reader.getString();
  },
  parseXVAL(type2, length2) {
    var endOffset = this.reader.offset + length2 - 4;
    this.reader.skip(8);
    this.currentForm[type2] = this.reader.getFloat32();
    this.reader.setOffset(endOffset);
  },
  parseXVAL3(type2, length2) {
    var endOffset = this.reader.offset + length2 - 4;
    this.reader.skip(8);
    this.currentForm[type2] = {
      x: this.reader.getFloat32(),
      y: this.reader.getFloat32(),
      z: this.reader.getFloat32()
    };
    this.reader.setOffset(endOffset);
  },
  parseObjectTag() {
    if (!this.tree.objectTags)
      this.tree.objectTags = {};
    this.tree.objectTags[this.reader.getIDTag()] = {
      tagString: this.reader.getString()
    };
  },
  parseLayer(length2) {
    var layer = {
      number: this.reader.getUint16(),
      flags: this.reader.getUint16(),
      pivot: this.reader.getFloat32Array(3),
      name: this.reader.getString()
    };
    this.tree.layers.push(layer);
    this.currentLayer = layer;
    var parsedLength = 16 + stringOffset(this.currentLayer.name);
    this.currentLayer.parent = parsedLength < length2 ? this.reader.getUint16() : -1;
  },
  parsePoints(length2) {
    this.currentPoints = [];
    for (let i2 = 0; i2 < length2 / 4; i2 += 3) {
      this.currentPoints.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());
    }
  },
  parseVertexMapping(length2, discontinuous) {
    var finalOffset = this.reader.offset + length2;
    var channelName = this.reader.getString();
    if (this.reader.offset === finalOffset) {
      this.currentForm.UVChannel = channelName;
      return;
    }
    this.reader.setOffset(this.reader.offset - stringOffset(channelName));
    var type2 = this.reader.getIDTag();
    this.reader.getUint16();
    var name = this.reader.getString();
    var remainingLength = length2 - 6 - stringOffset(name);
    switch (type2) {
      case "TXUV":
        this.parseUVMapping(name, finalOffset, discontinuous);
        break;
      case "MORF":
      case "SPOT":
        this.parseMorphTargets(name, finalOffset, type2);
        break;
      case "APSL":
      case "NORM":
      case "WGHT":
      case "MNVW":
      case "PICK":
      case "RGB ":
      case "RGBA":
        this.reader.skip(remainingLength);
        break;
      default:
        console.warn("LWOLoader: unknown vertex map type: " + type2);
        this.reader.skip(remainingLength);
    }
  },
  parseUVMapping(name, finalOffset, discontinuous) {
    var uvIndices = [];
    var polyIndices = [];
    var uvs = [];
    while (this.reader.offset < finalOffset) {
      uvIndices.push(this.reader.getVariableLengthIndex());
      if (discontinuous)
        polyIndices.push(this.reader.getVariableLengthIndex());
      uvs.push(this.reader.getFloat32(), this.reader.getFloat32());
    }
    if (discontinuous) {
      if (!this.currentLayer.discontinuousUVs)
        this.currentLayer.discontinuousUVs = {};
      this.currentLayer.discontinuousUVs[name] = {
        uvIndices,
        polyIndices,
        uvs
      };
    } else {
      if (!this.currentLayer.uvs)
        this.currentLayer.uvs = {};
      this.currentLayer.uvs[name] = {
        uvIndices,
        uvs
      };
    }
  },
  parseMorphTargets(name, finalOffset, type2) {
    var indices = [];
    var points = [];
    type2 = type2 === "MORF" ? "relative" : "absolute";
    while (this.reader.offset < finalOffset) {
      indices.push(this.reader.getVariableLengthIndex());
      points.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());
    }
    if (!this.currentLayer.morphTargets)
      this.currentLayer.morphTargets = {};
    this.currentLayer.morphTargets[name] = {
      indices,
      points,
      type: type2
    };
  },
  parsePolygonList(length2) {
    var finalOffset = this.reader.offset + length2;
    var type2 = this.reader.getIDTag();
    var indices = [];
    var polygonDimensions = [];
    while (this.reader.offset < finalOffset) {
      var numverts = this.reader.getUint16();
      numverts = numverts & 1023;
      polygonDimensions.push(numverts);
      for (let j2 = 0; j2 < numverts; j2++)
        indices.push(this.reader.getVariableLengthIndex());
    }
    var geometryData = {
      type: type2,
      vertexIndices: indices,
      polygonDimensions,
      points: this.currentPoints
    };
    if (polygonDimensions[0] === 1)
      geometryData.type = "points";
    else if (polygonDimensions[0] === 2)
      geometryData.type = "lines";
    this.currentLayer.geometry = geometryData;
  },
  parseTagStrings(length2) {
    this.tree.tags = this.reader.getStringArray(length2);
  },
  parsePolygonTagMapping(length2) {
    var finalOffset = this.reader.offset + length2;
    var type2 = this.reader.getIDTag();
    if (type2 === "SURF") {
      this.parseMaterialIndices(finalOffset);
    } else {
      this.reader.skip(length2 - 4);
    }
  },
  parseMaterialIndices(finalOffset) {
    this.currentLayer.geometry.materialIndices = [];
    while (this.reader.offset < finalOffset) {
      var polygonIndex = this.reader.getVariableLengthIndex();
      var materialIndex = this.reader.getUint16();
      this.currentLayer.geometry.materialIndices.push(polygonIndex, materialIndex);
    }
  },
  parseUnknownCHUNK(blockID, length2) {
    console.warn("LWOLoader: unknown chunk type: " + blockID + " length: " + length2);
    var data = this.reader.getString(length2);
    this.currentForm[blockID] = data;
  }
};
function DataViewReader(buffer2) {
  this.dv = new DataView(buffer2);
  this.offset = 0;
}
DataViewReader.prototype = {
  constructor: DataViewReader,
  size: function() {
    return this.dv.buffer.byteLength;
  },
  setOffset(offset) {
    if (offset > 0 && offset < this.dv.buffer.byteLength) {
      this.offset = offset;
    } else {
      console.error("LWOLoader: invalid buffer offset");
    }
  },
  endOfFile: function() {
    if (this.offset >= this.size())
      return true;
    return false;
  },
  skip: function(length2) {
    this.offset += length2;
  },
  getUint8: function() {
    var value = this.dv.getUint8(this.offset);
    this.offset += 1;
    return value;
  },
  getUint16: function() {
    var value = this.dv.getUint16(this.offset);
    this.offset += 2;
    return value;
  },
  getInt32: function() {
    var value = this.dv.getInt32(this.offset, false);
    this.offset += 4;
    return value;
  },
  getUint32: function() {
    var value = this.dv.getUint32(this.offset, false);
    this.offset += 4;
    return value;
  },
  getUint64: function() {
    var low, high;
    high = this.getUint32();
    low = this.getUint32();
    return high * 4294967296 + low;
  },
  getFloat32: function() {
    var value = this.dv.getFloat32(this.offset, false);
    this.offset += 4;
    return value;
  },
  getFloat32Array: function(size2) {
    var a2 = [];
    for (let i2 = 0; i2 < size2; i2++) {
      a2.push(this.getFloat32());
    }
    return a2;
  },
  getFloat64: function() {
    var value = this.dv.getFloat64(this.offset, this.littleEndian);
    this.offset += 8;
    return value;
  },
  getFloat64Array: function(size2) {
    var a2 = [];
    for (let i2 = 0; i2 < size2; i2++) {
      a2.push(this.getFloat64());
    }
    return a2;
  },
  getVariableLengthIndex() {
    var firstByte = this.getUint8();
    if (firstByte === 255) {
      return this.getUint8() * 65536 + this.getUint8() * 256 + this.getUint8();
    }
    return firstByte * 256 + this.getUint8();
  },
  getIDTag() {
    return this.getString(4);
  },
  getString: function(size2) {
    if (size2 === 0)
      return;
    var a2 = [];
    if (size2) {
      for (let i2 = 0; i2 < size2; i2++) {
        a2[i2] = this.getUint8();
      }
    } else {
      var currentChar;
      var len = 0;
      while (currentChar !== 0) {
        currentChar = this.getUint8();
        if (currentChar !== 0)
          a2.push(currentChar);
        len++;
      }
      if (!isEven(len + 1))
        this.getUint8();
    }
    return LoaderUtils.decodeText(new Uint8Array(a2));
  },
  getStringArray: function(size2) {
    var a2 = this.getString(size2);
    a2 = a2.split("\0");
    return a2.filter(Boolean);
  }
};
function Debugger() {
  this.active = false;
  this.depth = 0;
  this.formList = [];
}
Debugger.prototype = {
  constructor: Debugger,
  enable: function() {
    this.active = true;
  },
  log: function() {
    if (!this.active)
      return;
    var nodeType;
    switch (this.node) {
      case 0:
        nodeType = "FORM";
        break;
      case 1:
        nodeType = "CHK";
        break;
      case 2:
        nodeType = "S-CHK";
        break;
    }
    console.log("| ".repeat(this.depth) + nodeType, this.nodeID, `( ${this.offset} ) -> ( ${this.dataOffset + this.length} )`, this.node == 0 ? " {" : "", this.skipped ? "SKIPPED" : "", this.node == 0 && this.skipped ? "}" : "");
    if (this.node == 0 && !this.skipped) {
      this.depth += 1;
      this.formList.push(this.dataOffset + this.length);
    }
    this.skipped = false;
  },
  closeForms: function() {
    if (!this.active)
      return;
    for (let i2 = this.formList.length - 1; i2 >= 0; i2--) {
      if (this.offset >= this.formList[i2]) {
        this.depth -= 1;
        console.log("| ".repeat(this.depth) + "}");
        this.formList.splice(-1, 1);
      }
    }
  }
};
function isEven(num) {
  return num % 2;
}
function stringOffset(string) {
  return string.length + 1 + (isEven(string.length + 1) ? 1 : 0);
}
function printBuffer(buffer2, from, to) {
  console.log(LoaderUtils.decodeText(new Uint8Array(buffer2, from, to)));
}

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/loaders/OBJLoader.js
var _vA = new Vector3();
var _vB = new Vector3();
var _vC = new Vector3();
var _ab = new Vector3();
var _cb = new Vector3();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/loaders/KTXLoader.js
var HEADER_LEN = 12 + 13 * 4;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/loaders/RGBMLoader.js
var UPNG = {};
UPNG.toRGBA8 = function(out) {
  var w = out.width, h = out.height;
  if (out.tabs.acTL == null)
    return [UPNG.toRGBA8.decodeImage(out.data, w, h, out).buffer];
  var frms = [];
  if (out.frames[0].data == null)
    out.frames[0].data = out.data;
  var len = w * h * 4, img = new Uint8Array(len), empty = new Uint8Array(len), prev = new Uint8Array(len);
  for (var i2 = 0; i2 < out.frames.length; i2++) {
    var frm = out.frames[i2];
    var fx = frm.rect.x, fy = frm.rect.y, fw = frm.rect.width, fh = frm.rect.height;
    var fdata = UPNG.toRGBA8.decodeImage(frm.data, fw, fh, out);
    if (i2 != 0)
      for (var j2 = 0; j2 < len; j2++)
        prev[j2] = img[j2];
    if (frm.blend == 0)
      UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);
    else if (frm.blend == 1)
      UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);
    frms.push(img.buffer.slice(0));
    if (frm.dispose == 1)
      UPNG._copyTile(empty, fw, fh, img, w, h, fx, fy, 0);
    else if (frm.dispose == 2)
      for (var j2 = 0; j2 < len; j2++)
        img[j2] = prev[j2];
  }
  return frms;
};
UPNG.toRGBA8.decodeImage = function(data, w, h, out) {
  var area2 = w * h, bpp = UPNG.decode._getBPP(out);
  var bpl = Math.ceil(w * bpp / 8);
  var bf = new Uint8Array(area2 * 4), bf32 = new Uint32Array(bf.buffer);
  var ctype = out.ctype, depth = out.depth;
  var rs = UPNG._bin.readUshort;
  if (ctype == 6) {
    var qarea = area2 << 2;
    if (depth == 8) {
      for (var i2 = 0; i2 < qarea; i2 += 4) {
        bf[i2] = data[i2];
        bf[i2 + 1] = data[i2 + 1];
        bf[i2 + 2] = data[i2 + 2];
        bf[i2 + 3] = data[i2 + 3];
      }
    }
    if (depth == 16) {
      for (var i2 = 0; i2 < qarea; i2++) {
        bf[i2] = data[i2 << 1];
      }
    }
  } else if (ctype == 2) {
    var ts = out.tabs["tRNS"];
    if (ts == null) {
      if (depth == 8) {
        for (var i2 = 0; i2 < area2; i2++) {
          var ti = i2 * 3;
          bf32[i2] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];
        }
      }
      if (depth == 16) {
        for (var i2 = 0; i2 < area2; i2++) {
          var ti = i2 * 6;
          bf32[i2] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];
        }
      }
    } else {
      var tr = ts[0], tg = ts[1], tb = ts[2];
      if (depth == 8) {
        for (var i2 = 0; i2 < area2; i2++) {
          var qi = i2 << 2, ti = i2 * 3;
          bf32[i2] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];
          if (data[ti] == tr && data[ti + 1] == tg && data[ti + 2] == tb)
            bf[qi + 3] = 0;
        }
      }
      if (depth == 16) {
        for (var i2 = 0; i2 < area2; i2++) {
          var qi = i2 << 2, ti = i2 * 6;
          bf32[i2] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];
          if (rs(data, ti) == tr && rs(data, ti + 2) == tg && rs(data, ti + 4) == tb)
            bf[qi + 3] = 0;
        }
      }
    }
  } else if (ctype == 3) {
    var p = out.tabs["PLTE"], ap = out.tabs["tRNS"], tl = ap ? ap.length : 0;
    if (depth == 1) {
      for (var y = 0; y < h; y++) {
        var s0 = y * bpl, t0 = y * w;
        for (var i2 = 0; i2 < w; i2++) {
          var qi = t0 + i2 << 2, j2 = data[s0 + (i2 >> 3)] >> 7 - ((i2 & 7) << 0) & 1, cj = 3 * j2;
          bf[qi] = p[cj];
          bf[qi + 1] = p[cj + 1];
          bf[qi + 2] = p[cj + 2];
          bf[qi + 3] = j2 < tl ? ap[j2] : 255;
        }
      }
    }
    if (depth == 2) {
      for (var y = 0; y < h; y++) {
        var s0 = y * bpl, t0 = y * w;
        for (var i2 = 0; i2 < w; i2++) {
          var qi = t0 + i2 << 2, j2 = data[s0 + (i2 >> 2)] >> 6 - ((i2 & 3) << 1) & 3, cj = 3 * j2;
          bf[qi] = p[cj];
          bf[qi + 1] = p[cj + 1];
          bf[qi + 2] = p[cj + 2];
          bf[qi + 3] = j2 < tl ? ap[j2] : 255;
        }
      }
    }
    if (depth == 4) {
      for (var y = 0; y < h; y++) {
        var s0 = y * bpl, t0 = y * w;
        for (var i2 = 0; i2 < w; i2++) {
          var qi = t0 + i2 << 2, j2 = data[s0 + (i2 >> 1)] >> 4 - ((i2 & 1) << 2) & 15, cj = 3 * j2;
          bf[qi] = p[cj];
          bf[qi + 1] = p[cj + 1];
          bf[qi + 2] = p[cj + 2];
          bf[qi + 3] = j2 < tl ? ap[j2] : 255;
        }
      }
    }
    if (depth == 8) {
      for (var i2 = 0; i2 < area2; i2++) {
        var qi = i2 << 2, j2 = data[i2], cj = 3 * j2;
        bf[qi] = p[cj];
        bf[qi + 1] = p[cj + 1];
        bf[qi + 2] = p[cj + 2];
        bf[qi + 3] = j2 < tl ? ap[j2] : 255;
      }
    }
  } else if (ctype == 4) {
    if (depth == 8) {
      for (var i2 = 0; i2 < area2; i2++) {
        var qi = i2 << 2, di = i2 << 1, gr = data[di];
        bf[qi] = gr;
        bf[qi + 1] = gr;
        bf[qi + 2] = gr;
        bf[qi + 3] = data[di + 1];
      }
    }
    if (depth == 16) {
      for (var i2 = 0; i2 < area2; i2++) {
        var qi = i2 << 2, di = i2 << 2, gr = data[di];
        bf[qi] = gr;
        bf[qi + 1] = gr;
        bf[qi + 2] = gr;
        bf[qi + 3] = data[di + 2];
      }
    }
  } else if (ctype == 0) {
    var tr = out.tabs["tRNS"] ? out.tabs["tRNS"] : -1;
    for (var y = 0; y < h; y++) {
      var off = y * bpl, to = y * w;
      if (depth == 1) {
        for (var x = 0; x < w; x++) {
          var gr = 255 * (data[off + (x >>> 3)] >>> 7 - (x & 7) & 1), al = gr == tr * 255 ? 0 : 255;
          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
        }
      } else if (depth == 2) {
        for (var x = 0; x < w; x++) {
          var gr = 85 * (data[off + (x >>> 2)] >>> 6 - ((x & 3) << 1) & 3), al = gr == tr * 85 ? 0 : 255;
          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
        }
      } else if (depth == 4) {
        for (var x = 0; x < w; x++) {
          var gr = 17 * (data[off + (x >>> 1)] >>> 4 - ((x & 1) << 2) & 15), al = gr == tr * 17 ? 0 : 255;
          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
        }
      } else if (depth == 8) {
        for (var x = 0; x < w; x++) {
          var gr = data[off + x], al = gr == tr ? 0 : 255;
          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
        }
      } else if (depth == 16) {
        for (var x = 0; x < w; x++) {
          var gr = data[off + (x << 1)], al = rs(data, off + (x << 1)) == tr ? 0 : 255;
          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
        }
      }
    }
  }
  return bf;
};
UPNG.decode = function(buff) {
  var data = new Uint8Array(buff), offset = 8, bin = UPNG._bin, rUs = bin.readUshort, rUi = bin.readUint;
  var out = {
    tabs: {},
    frames: []
  };
  var dd = new Uint8Array(data.length), doff = 0;
  var fd, foff = 0;
  var text, keyw, bfr;
  var mgck = [137, 80, 78, 71, 13, 10, 26, 10];
  for (var i2 = 0; i2 < 8; i2++)
    if (data[i2] != mgck[i2])
      throw new Error("The input is not a PNG file!");
  while (offset < data.length) {
    var len = bin.readUint(data, offset);
    offset += 4;
    var type2 = bin.readASCII(data, offset, 4);
    offset += 4;
    if (type2 == "IHDR") {
      UPNG.decode._IHDR(data, offset, out);
    } else if (type2 == "CgBI") {
      out.tabs[type2] = data.slice(offset, offset + 4);
    } else if (type2 == "IDAT") {
      for (var i2 = 0; i2 < len; i2++)
        dd[doff + i2] = data[offset + i2];
      doff += len;
    } else if (type2 == "acTL") {
      out.tabs[type2] = {
        num_frames: rUi(data, offset),
        num_plays: rUi(data, offset + 4)
      };
      fd = new Uint8Array(data.length);
    } else if (type2 == "fcTL") {
      if (foff != 0) {
        var fr = out.frames[out.frames.length - 1];
        fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);
        foff = 0;
      }
      var rct = {
        x: rUi(data, offset + 12),
        y: rUi(data, offset + 16),
        width: rUi(data, offset + 4),
        height: rUi(data, offset + 8)
      };
      var del = rUs(data, offset + 22);
      del = rUs(data, offset + 20) / (del == 0 ? 100 : del);
      var frm = {
        rect: rct,
        delay: Math.round(del * 1e3),
        dispose: data[offset + 24],
        blend: data[offset + 25]
      };
      out.frames.push(frm);
    } else if (type2 == "fdAT") {
      for (var i2 = 0; i2 < len - 4; i2++)
        fd[foff + i2] = data[offset + i2 + 4];
      foff += len - 4;
    } else if (type2 == "pHYs") {
      out.tabs[type2] = [bin.readUint(data, offset), bin.readUint(data, offset + 4), data[offset + 8]];
    } else if (type2 == "cHRM") {
      out.tabs[type2] = [];
      for (var i2 = 0; i2 < 8; i2++)
        out.tabs[type2].push(bin.readUint(data, offset + i2 * 4));
    } else if (type2 == "tEXt" || type2 == "zTXt") {
      if (out.tabs[type2] == null)
        out.tabs[type2] = {};
      var nz = bin.nextZero(data, offset);
      keyw = bin.readASCII(data, offset, nz - offset);
      var tl = offset + len - nz - 1;
      if (type2 == "tEXt") {
        text = bin.readASCII(data, nz + 1, tl);
      } else {
        bfr = UPNG.decode._inflate(data.slice(nz + 2, nz + 2 + tl));
        text = bin.readUTF8(bfr, 0, bfr.length);
      }
      out.tabs[type2][keyw] = text;
    } else if (type2 == "iTXt") {
      if (out.tabs[type2] == null)
        out.tabs[type2] = {};
      var nz = 0, off = offset;
      nz = bin.nextZero(data, off);
      keyw = bin.readASCII(data, off, nz - off);
      off = nz + 1;
      var cflag = data[off];
      off += 2;
      nz = bin.nextZero(data, off);
      bin.readASCII(data, off, nz - off);
      off = nz + 1;
      nz = bin.nextZero(data, off);
      bin.readUTF8(data, off, nz - off);
      off = nz + 1;
      var tl = len - (off - offset);
      if (cflag == 0) {
        text = bin.readUTF8(data, off, tl);
      } else {
        bfr = UPNG.decode._inflate(data.slice(off, off + tl));
        text = bin.readUTF8(bfr, 0, bfr.length);
      }
      out.tabs[type2][keyw] = text;
    } else if (type2 == "PLTE") {
      out.tabs[type2] = bin.readBytes(data, offset, len);
    } else if (type2 == "hIST") {
      var pl = out.tabs["PLTE"].length / 3;
      out.tabs[type2] = [];
      for (var i2 = 0; i2 < pl; i2++)
        out.tabs[type2].push(rUs(data, offset + i2 * 2));
    } else if (type2 == "tRNS") {
      if (out.ctype == 3)
        out.tabs[type2] = bin.readBytes(data, offset, len);
      else if (out.ctype == 0)
        out.tabs[type2] = rUs(data, offset);
      else if (out.ctype == 2)
        out.tabs[type2] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];
    } else if (type2 == "gAMA") {
      out.tabs[type2] = bin.readUint(data, offset) / 1e5;
    } else if (type2 == "sRGB") {
      out.tabs[type2] = data[offset];
    } else if (type2 == "bKGD") {
      if (out.ctype == 0 || out.ctype == 4) {
        out.tabs[type2] = [rUs(data, offset)];
      } else if (out.ctype == 2 || out.ctype == 6) {
        out.tabs[type2] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];
      } else if (out.ctype == 3) {
        out.tabs[type2] = data[offset];
      }
    } else if (type2 == "IEND") {
      break;
    }
    offset += len;
    bin.readUint(data, offset);
    offset += 4;
  }
  if (foff != 0) {
    var fr = out.frames[out.frames.length - 1];
    fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);
  }
  out.data = UPNG.decode._decompress(out, dd, out.width, out.height);
  delete out.compress;
  delete out.interlace;
  delete out.filter;
  return out;
};
UPNG.decode._decompress = function(out, dd, w, h) {
  var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w * bpp / 8), buff = new Uint8Array((bpl + 1 + out.interlace) * h);
  if (out.tabs["CgBI"])
    dd = UPNG.inflateRaw(dd, buff);
  else
    dd = UPNG.decode._inflate(dd, buff);
  if (out.interlace == 0)
    dd = UPNG.decode._filterZero(dd, out, 0, w, h);
  else if (out.interlace == 1)
    dd = UPNG.decode._readInterlace(dd, out);
  return dd;
};
UPNG.decode._inflate = function(data, buff) {
  var out = UPNG["inflateRaw"](new Uint8Array(data.buffer, 2, data.length - 6), buff);
  return out;
};
UPNG.inflateRaw = function() {
  var H = {};
  H.H = {};
  H.H.N = function(N, W) {
    var R2 = Uint8Array, i2 = 0, m2 = 0, J = 0, h = 0, Q2 = 0, X = 0, u = 0, w = 0, d = 0, v3, C2;
    if (N[0] == 3 && N[1] == 0)
      return W ? W : new R2(0);
    var V = H.H, n = V.b, A = V.e, l = V.R, M = V.n, I = V.A, e = V.Z, b2 = V.m, Z = W == null;
    if (Z)
      W = new R2(N.length >>> 2 << 5);
    while (i2 == 0) {
      i2 = n(N, d, 1);
      m2 = n(N, d + 1, 2);
      d += 3;
      if (m2 == 0) {
        if ((d & 7) != 0)
          d += 8 - (d & 7);
        var D = (d >>> 3) + 4, q = N[D - 4] | N[D - 3] << 8;
        if (Z)
          W = H.H.W(W, w + q);
        W.set(new R2(N.buffer, N.byteOffset + D, q), w);
        d = D + q << 3;
        w += q;
        continue;
      }
      if (Z)
        W = H.H.W(W, w + (1 << 17));
      if (m2 == 1) {
        v3 = b2.J;
        C2 = b2.h;
        X = (1 << 9) - 1;
        u = (1 << 5) - 1;
      }
      if (m2 == 2) {
        J = A(N, d, 5) + 257;
        h = A(N, d + 5, 5) + 1;
        Q2 = A(N, d + 10, 4) + 4;
        d += 14;
        var j2 = 1;
        for (var c2 = 0; c2 < 38; c2 += 2) {
          b2.Q[c2] = 0;
          b2.Q[c2 + 1] = 0;
        }
        for (var c2 = 0; c2 < Q2; c2++) {
          var K = A(N, d + c2 * 3, 3);
          b2.Q[(b2.X[c2] << 1) + 1] = K;
          if (K > j2)
            j2 = K;
        }
        d += 3 * Q2;
        M(b2.Q, j2);
        I(b2.Q, j2, b2.u);
        v3 = b2.w;
        C2 = b2.d;
        d = l(b2.u, (1 << j2) - 1, J + h, N, d, b2.v);
        var r = V.V(b2.v, 0, J, b2.C);
        X = (1 << r) - 1;
        var S = V.V(b2.v, J, h, b2.D);
        u = (1 << S) - 1;
        M(b2.C, r);
        I(b2.C, r, v3);
        M(b2.D, S);
        I(b2.D, S, C2);
      }
      while (true) {
        var T2 = v3[e(N, d) & X];
        d += T2 & 15;
        var p = T2 >>> 4;
        if (p >>> 8 == 0) {
          W[w++] = p;
        } else if (p == 256) {
          break;
        } else {
          var z = w + p - 254;
          if (p > 264) {
            var _ = b2.q[p - 257];
            z = w + (_ >>> 3) + A(N, d, _ & 7);
            d += _ & 7;
          }
          var $ = C2[e(N, d) & u];
          d += $ & 15;
          var s = $ >>> 4, Y = b2.c[s], a2 = (Y >>> 4) + n(N, d, Y & 15);
          d += Y & 15;
          while (w < z) {
            W[w] = W[w++ - a2];
            W[w] = W[w++ - a2];
            W[w] = W[w++ - a2];
            W[w] = W[w++ - a2];
          }
          w = z;
        }
      }
    }
    return W.length == w ? W : W.slice(0, w);
  };
  H.H.W = function(N, W) {
    var R2 = N.length;
    if (W <= R2)
      return N;
    var V = new Uint8Array(R2 << 1);
    V.set(N, 0);
    return V;
  };
  H.H.R = function(N, W, R2, V, n, A) {
    var l = H.H.e, M = H.H.Z, I = 0;
    while (I < R2) {
      var e = N[M(V, n) & W];
      n += e & 15;
      var b2 = e >>> 4;
      if (b2 <= 15) {
        A[I] = b2;
        I++;
      } else {
        var Z = 0, m2 = 0;
        if (b2 == 16) {
          m2 = 3 + l(V, n, 2);
          n += 2;
          Z = A[I - 1];
        } else if (b2 == 17) {
          m2 = 3 + l(V, n, 3);
          n += 3;
        } else if (b2 == 18) {
          m2 = 11 + l(V, n, 7);
          n += 7;
        }
        var J = I + m2;
        while (I < J) {
          A[I] = Z;
          I++;
        }
      }
    }
    return n;
  };
  H.H.V = function(N, W, R2, V) {
    var n = 0, A = 0, l = V.length >>> 1;
    while (A < R2) {
      var M = N[A + W];
      V[A << 1] = 0;
      V[(A << 1) + 1] = M;
      if (M > n)
        n = M;
      A++;
    }
    while (A < l) {
      V[A << 1] = 0;
      V[(A << 1) + 1] = 0;
      A++;
    }
    return n;
  };
  H.H.n = function(N, W) {
    var R2 = H.H.m, V = N.length, n, A, l, M, I, e = R2.j;
    for (var M = 0; M <= W; M++)
      e[M] = 0;
    for (M = 1; M < V; M += 2)
      e[N[M]]++;
    var b2 = R2.K;
    n = 0;
    e[0] = 0;
    for (A = 1; A <= W; A++) {
      n = n + e[A - 1] << 1;
      b2[A] = n;
    }
    for (l = 0; l < V; l += 2) {
      I = N[l + 1];
      if (I != 0) {
        N[l] = b2[I];
        b2[I]++;
      }
    }
  };
  H.H.A = function(N, W, R2) {
    var V = N.length, n = H.H.m, A = n.r;
    for (var l = 0; l < V; l += 2) {
      if (N[l + 1] != 0) {
        var M = l >> 1, I = N[l + 1], e = M << 4 | I, b2 = W - I, Z = N[l] << b2, m2 = Z + (1 << b2);
        while (Z != m2) {
          var J = A[Z] >>> 15 - W;
          R2[J] = e;
          Z++;
        }
      }
    }
  };
  H.H.l = function(N, W) {
    var R2 = H.H.m.r, V = 15 - W;
    for (var n = 0; n < N.length; n += 2) {
      var A = N[n] << W - N[n + 1];
      N[n] = R2[A] >>> V;
    }
  };
  H.H.M = function(N, W, R2) {
    R2 = R2 << (W & 7);
    var V = W >>> 3;
    N[V] |= R2;
    N[V + 1] |= R2 >>> 8;
  };
  H.H.I = function(N, W, R2) {
    R2 = R2 << (W & 7);
    var V = W >>> 3;
    N[V] |= R2;
    N[V + 1] |= R2 >>> 8;
    N[V + 2] |= R2 >>> 16;
  };
  H.H.e = function(N, W, R2) {
    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8) >>> (W & 7) & (1 << R2) - 1;
  };
  H.H.b = function(N, W, R2) {
    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7) & (1 << R2) - 1;
  };
  H.H.Z = function(N, W) {
    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7);
  };
  H.H.i = function(N, W) {
    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16 | N[(W >>> 3) + 3] << 24) >>> (W & 7);
  };
  H.H.m = function() {
    var N = Uint16Array, W = Uint32Array;
    return {
      K: new N(16),
      j: new N(16),
      X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
      S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999],
      T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0],
      q: new N(32),
      p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535],
      z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0],
      c: new W(32),
      J: new N(512),
      _: [],
      h: new N(32),
      $: [],
      w: new N(32768),
      C: [],
      v: [],
      d: new N(32768),
      D: [],
      u: new N(512),
      Q: [],
      r: new N(1 << 15),
      s: new W(286),
      Y: new W(30),
      a: new W(19),
      t: new W(15e3),
      k: new N(1 << 16),
      g: new N(1 << 15)
    };
  }();
  (function() {
    var N = H.H.m, W = 1 << 15;
    for (var R2 = 0; R2 < W; R2++) {
      var V = R2;
      V = (V & 2863311530) >>> 1 | (V & 1431655765) << 1;
      V = (V & 3435973836) >>> 2 | (V & 858993459) << 2;
      V = (V & 4042322160) >>> 4 | (V & 252645135) << 4;
      V = (V & 4278255360) >>> 8 | (V & 16711935) << 8;
      N.r[R2] = (V >>> 16 | V << 16) >>> 17;
    }
    function n(A, l, M) {
      while (l-- != 0)
        A.push(0, M);
    }
    for (var R2 = 0; R2 < 32; R2++) {
      N.q[R2] = N.S[R2] << 3 | N.T[R2];
      N.c[R2] = N.p[R2] << 4 | N.z[R2];
    }
    n(N._, 144, 8);
    n(N._, 255 - 143, 9);
    n(N._, 279 - 255, 7);
    n(N._, 287 - 279, 8);
    H.H.n(N._, 9);
    H.H.A(N._, 9, N.J);
    H.H.l(N._, 9);
    n(N.$, 32, 5);
    H.H.n(N.$, 5);
    H.H.A(N.$, 5, N.h);
    H.H.l(N.$, 5);
    n(N.Q, 19, 0);
    n(N.C, 286, 0);
    n(N.D, 30, 0);
    n(N.v, 320, 0);
  })();
  return H.H.N;
}();
UPNG.decode._readInterlace = function(data, out) {
  var w = out.width, h = out.height;
  var bpp = UPNG.decode._getBPP(out), cbpp = bpp >> 3, bpl = Math.ceil(w * bpp / 8);
  var img = new Uint8Array(h * bpl);
  var di = 0;
  var starting_row = [0, 0, 4, 0, 2, 0, 1];
  var starting_col = [0, 4, 0, 2, 0, 1, 0];
  var row_increment = [8, 8, 8, 4, 4, 2, 2];
  var col_increment = [8, 8, 4, 4, 2, 2, 1];
  var pass = 0;
  while (pass < 7) {
    var ri = row_increment[pass], ci = col_increment[pass];
    var sw = 0, sh = 0;
    var cr = starting_row[pass];
    while (cr < h) {
      cr += ri;
      sh++;
    }
    var cc = starting_col[pass];
    while (cc < w) {
      cc += ci;
      sw++;
    }
    var bpll = Math.ceil(sw * bpp / 8);
    UPNG.decode._filterZero(data, out, di, sw, sh);
    var y = 0, row = starting_row[pass];
    var val;
    while (row < h) {
      var col = starting_col[pass];
      var cdi = di + y * bpll << 3;
      while (col < w) {
        if (bpp == 1) {
          val = data[cdi >> 3];
          val = val >> 7 - (cdi & 7) & 1;
          img[row * bpl + (col >> 3)] |= val << 7 - ((col & 7) << 0);
        }
        if (bpp == 2) {
          val = data[cdi >> 3];
          val = val >> 6 - (cdi & 7) & 3;
          img[row * bpl + (col >> 2)] |= val << 6 - ((col & 3) << 1);
        }
        if (bpp == 4) {
          val = data[cdi >> 3];
          val = val >> 4 - (cdi & 7) & 15;
          img[row * bpl + (col >> 1)] |= val << 4 - ((col & 1) << 2);
        }
        if (bpp >= 8) {
          var ii = row * bpl + col * cbpp;
          for (var j2 = 0; j2 < cbpp; j2++)
            img[ii + j2] = data[(cdi >> 3) + j2];
        }
        cdi += bpp;
        col += ci;
      }
      y++;
      row += ri;
    }
    if (sw * sh != 0)
      di += sh * (1 + bpll);
    pass = pass + 1;
  }
  return img;
};
UPNG.decode._getBPP = function(out) {
  var noc = [1, null, 3, 1, 2, null, 4][out.ctype];
  return noc * out.depth;
};
UPNG.decode._filterZero = function(data, out, off, w, h) {
  var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w * bpp / 8), paeth = UPNG.decode._paeth;
  bpp = Math.ceil(bpp / 8);
  var i2, di, type2 = data[off], x = 0;
  if (type2 > 1)
    data[off] = [0, 0, 1][type2 - 2];
  if (type2 == 3)
    for (x = bpp; x < bpl; x++)
      data[x + 1] = data[x + 1] + (data[x + 1 - bpp] >>> 1) & 255;
  for (var y = 0; y < h; y++) {
    i2 = off + y * bpl;
    di = i2 + y + 1;
    type2 = data[di - 1];
    x = 0;
    if (type2 == 0) {
      for (; x < bpl; x++)
        data[i2 + x] = data[di + x];
    } else if (type2 == 1) {
      for (; x < bpp; x++)
        data[i2 + x] = data[di + x];
      for (; x < bpl; x++)
        data[i2 + x] = data[di + x] + data[i2 + x - bpp];
    } else if (type2 == 2) {
      for (; x < bpl; x++)
        data[i2 + x] = data[di + x] + data[i2 + x - bpl];
    } else if (type2 == 3) {
      for (; x < bpp; x++)
        data[i2 + x] = data[di + x] + (data[i2 + x - bpl] >>> 1);
      for (; x < bpl; x++)
        data[i2 + x] = data[di + x] + (data[i2 + x - bpl] + data[i2 + x - bpp] >>> 1);
    } else {
      for (; x < bpp; x++)
        data[i2 + x] = data[di + x] + paeth(0, data[i2 + x - bpl], 0);
      for (; x < bpl; x++) {
        data[i2 + x] = data[di + x] + paeth(data[i2 + x - bpp], data[i2 + x - bpl], data[i2 + x - bpp - bpl]);
      }
    }
  }
  return data;
};
UPNG.decode._paeth = function(a2, b2, c2) {
  var p = a2 + b2 - c2, pa = p - a2, pb = p - b2, pc = p - c2;
  if (pa * pa <= pb * pb && pa * pa <= pc * pc)
    return a2;
  else if (pb * pb <= pc * pc)
    return b2;
  return c2;
};
UPNG.decode._IHDR = function(data, offset, out) {
  var bin = UPNG._bin;
  out.width = bin.readUint(data, offset);
  offset += 4;
  out.height = bin.readUint(data, offset);
  offset += 4;
  out.depth = data[offset];
  offset++;
  out.ctype = data[offset];
  offset++;
  out.compress = data[offset];
  offset++;
  out.filter = data[offset];
  offset++;
  out.interlace = data[offset];
  offset++;
};
UPNG._bin = {
  nextZero: function(data, p) {
    while (data[p] != 0)
      p++;
    return p;
  },
  readUshort: function(buff, p) {
    return buff[p] << 8 | buff[p + 1];
  },
  writeUshort: function(buff, p, n) {
    buff[p] = n >> 8 & 255;
    buff[p + 1] = n & 255;
  },
  readUint: function(buff, p) {
    return buff[p] * (256 * 256 * 256) + (buff[p + 1] << 16 | buff[p + 2] << 8 | buff[p + 3]);
  },
  writeUint: function(buff, p, n) {
    buff[p] = n >> 24 & 255;
    buff[p + 1] = n >> 16 & 255;
    buff[p + 2] = n >> 8 & 255;
    buff[p + 3] = n & 255;
  },
  readASCII: function(buff, p, l) {
    var s = "";
    for (var i2 = 0; i2 < l; i2++)
      s += String.fromCharCode(buff[p + i2]);
    return s;
  },
  writeASCII: function(data, p, s) {
    for (var i2 = 0; i2 < s.length; i2++)
      data[p + i2] = s.charCodeAt(i2);
  },
  readBytes: function(buff, p, l) {
    var arr = [];
    for (var i2 = 0; i2 < l; i2++)
      arr.push(buff[p + i2]);
    return arr;
  },
  pad: function(n) {
    return n.length < 2 ? "0" + n : n;
  },
  readUTF8: function(buff, p, l) {
    var s = "", ns;
    for (var i2 = 0; i2 < l; i2++)
      s += "%" + UPNG._bin.pad(buff[p + i2].toString(16));
    try {
      ns = decodeURIComponent(s);
    } catch (e) {
      return UPNG._bin.readASCII(buff, p, l);
    }
    return ns;
  }
};
UPNG._copyTile = function(sb, sw, sh, tb, tw, th, xoff, yoff, mode) {
  var w = Math.min(sw, tw), h = Math.min(sh, th);
  var si = 0, ti = 0;
  for (var y = 0; y < h; y++) {
    for (var x = 0; x < w; x++) {
      if (xoff >= 0 && yoff >= 0) {
        si = y * sw + x << 2;
        ti = (yoff + y) * tw + xoff + x << 2;
      } else {
        si = (-yoff + y) * sw - xoff + x << 2;
        ti = y * tw + x << 2;
      }
      if (mode == 0) {
        tb[ti] = sb[si];
        tb[ti + 1] = sb[si + 1];
        tb[ti + 2] = sb[si + 2];
        tb[ti + 3] = sb[si + 3];
      } else if (mode == 1) {
        var fa = sb[si + 3] * (1 / 255), fr = sb[si] * fa, fg = sb[si + 1] * fa, fb = sb[si + 2] * fa;
        var ba = tb[ti + 3] * (1 / 255), br = tb[ti] * ba, bg = tb[ti + 1] * ba, bb = tb[ti + 2] * ba;
        var ifa = 1 - fa, oa = fa + ba * ifa, ioa = oa == 0 ? 0 : 1 / oa;
        tb[ti + 3] = 255 * oa;
        tb[ti + 0] = (fr + br * ifa) * ioa;
        tb[ti + 1] = (fg + bg * ifa) * ioa;
        tb[ti + 2] = (fb + bb * ifa) * ioa;
      } else if (mode == 2) {
        var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];
        var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];
        if (fa == ba && fr == br && fg == bg && fb == bb) {
          tb[ti] = 0;
          tb[ti + 1] = 0;
          tb[ti + 2] = 0;
          tb[ti + 3] = 0;
        } else {
          tb[ti] = fr;
          tb[ti + 1] = fg;
          tb[ti + 2] = fb;
          tb[ti + 3] = fa;
        }
      } else if (mode == 3) {
        var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];
        var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];
        if (fa == ba && fr == br && fg == bg && fb == bb)
          continue;
        if (fa < 220 && ba > 20)
          return false;
      }
    }
  }
  return true;
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/lines/LineSegmentsGeometry.js
var _box = new Box3();
var _vector2 = new Vector3();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/lines/LineMaterial.js
UniformsLib.line = {
  worldUnits: {
    value: 1
  },
  linewidth: {
    value: 1
  },
  resolution: {
    value: new Vector2(1, 1)
  },
  dashOffset: {
    value: 0
  },
  dashScale: {
    value: 1
  },
  dashSize: {
    value: 1
  },
  gapSize: {
    value: 1
  }
};
ShaderLib["line"] = {
  uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.fog, UniformsLib.line]),
  vertexShader: `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,
  fragmentShader: `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/lines/Wireframe.js
var _start = new Vector3();
var _end = new Vector3();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/lines/LineSegments2.js
var _start2 = new Vector3();
var _end2 = new Vector3();
var _start4 = new Vector4();
var _end4 = new Vector4();
var _ssOrigin = new Vector4();
var _ssOrigin3 = new Vector3();
var _mvMatrix = new Matrix4();
var _line = new Line3();
var _closestPoint2 = new Vector3();
var _box2 = new Box3();
var _sphere = new Sphere();
var _clipToWorldVector = new Vector4();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/helpers/VertexTangentsHelper.js
var _v12 = new Vector3();
var _v2 = new Vector3();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/helpers/VertexNormalsHelper.js
var _v13 = new Vector3();
var _v22 = new Vector3();
var _normalMatrix = new Matrix3();

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/deprecated/Geometry.js
var _m1 = new Matrix4();
var _obj = new Object3D();
var _offset = new Vector3();
var Geometry = class extends EventDispatcher {
  constructor() {
    super();
    this.isGeometry = true;
    this.uuid = MathUtils.generateUUID();
    this.name = "";
    this.type = "Geometry";
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.elementsNeedUpdate = false;
    this.verticesNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.lineDistancesNeedUpdate = false;
    this.groupsNeedUpdate = false;
  }
  applyMatrix4(matrix3) {
    const normalMatrix = new Matrix3().getNormalMatrix(matrix3);
    for (let i2 = 0, il = this.vertices.length; i2 < il; i2++) {
      const vertex = this.vertices[i2];
      vertex.applyMatrix4(matrix3);
    }
    for (let i2 = 0, il = this.faces.length; i2 < il; i2++) {
      const face = this.faces[i2];
      face.normal.applyMatrix3(normalMatrix).normalize();
      for (let j2 = 0, jl2 = face.vertexNormals.length; j2 < jl2; j2++) {
        face.vertexNormals[j2].applyMatrix3(normalMatrix).normalize();
      }
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    this.verticesNeedUpdate = true;
    this.normalsNeedUpdate = true;
    return this;
  }
  rotateX(angle) {
    _m1.makeRotationX(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateY(angle) {
    _m1.makeRotationY(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateZ(angle) {
    _m1.makeRotationZ(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  translate(x, y, z) {
    _m1.makeTranslation(x, y, z);
    this.applyMatrix4(_m1);
    return this;
  }
  scale(x, y, z) {
    _m1.makeScale(x, y, z);
    this.applyMatrix4(_m1);
    return this;
  }
  lookAt(vector2) {
    _obj.lookAt(vector2);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  }
  fromBufferGeometry(geometry2) {
    const scope = this;
    const index = geometry2.index !== null ? geometry2.index : void 0;
    const attributes = geometry2.attributes;
    if (attributes.position === void 0) {
      console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.");
      return this;
    }
    const position = attributes.position;
    const normal = attributes.normal;
    const color3 = attributes.color;
    const uv2 = attributes.uv;
    const uv22 = attributes.uv2;
    if (uv22 !== void 0)
      this.faceVertexUvs[1] = [];
    for (let i2 = 0; i2 < position.count; i2++) {
      scope.vertices.push(new Vector3().fromBufferAttribute(position, i2));
      if (color3 !== void 0) {
        scope.colors.push(new Color().fromBufferAttribute(color3, i2));
      }
    }
    function addFace(a2, b2, c2, materialIndex) {
      const vertexColors = color3 === void 0 ? [] : [scope.colors[a2].clone(), scope.colors[b2].clone(), scope.colors[c2].clone()];
      const vertexNormals = normal === void 0 ? [] : [new Vector3().fromBufferAttribute(normal, a2), new Vector3().fromBufferAttribute(normal, b2), new Vector3().fromBufferAttribute(normal, c2)];
      const face = new Face3(a2, b2, c2, vertexNormals, vertexColors, materialIndex);
      scope.faces.push(face);
      if (uv2 !== void 0) {
        scope.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(uv2, a2), new Vector2().fromBufferAttribute(uv2, b2), new Vector2().fromBufferAttribute(uv2, c2)]);
      }
      if (uv22 !== void 0) {
        scope.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(uv22, a2), new Vector2().fromBufferAttribute(uv22, b2), new Vector2().fromBufferAttribute(uv22, c2)]);
      }
    }
    const groups = geometry2.groups;
    if (groups.length > 0) {
      for (let i2 = 0; i2 < groups.length; i2++) {
        const group = groups[i2];
        const start = group.start;
        const count = group.count;
        for (let j2 = start, jl2 = start + count; j2 < jl2; j2 += 3) {
          if (index !== void 0) {
            addFace(index.getX(j2), index.getX(j2 + 1), index.getX(j2 + 2), group.materialIndex);
          } else {
            addFace(j2, j2 + 1, j2 + 2, group.materialIndex);
          }
        }
      }
    } else {
      if (index !== void 0) {
        for (let i2 = 0; i2 < index.count; i2 += 3) {
          addFace(index.getX(i2), index.getX(i2 + 1), index.getX(i2 + 2));
        }
      } else {
        for (let i2 = 0; i2 < position.count; i2 += 3) {
          addFace(i2, i2 + 1, i2 + 2);
        }
      }
    }
    this.computeFaceNormals();
    if (geometry2.boundingBox !== null) {
      this.boundingBox = geometry2.boundingBox.clone();
    }
    if (geometry2.boundingSphere !== null) {
      this.boundingSphere = geometry2.boundingSphere.clone();
    }
    return this;
  }
  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }
  normalize() {
    this.computeBoundingSphere();
    const center = this.boundingSphere.center;
    const radius = this.boundingSphere.radius;
    const s = radius === 0 ? 1 : 1 / radius;
    const matrix3 = new Matrix4();
    matrix3.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
    this.applyMatrix4(matrix3);
    return this;
  }
  computeFaceNormals() {
    const cb2 = new Vector3(), ab3 = new Vector3();
    for (let f = 0, fl = this.faces.length; f < fl; f++) {
      const face = this.faces[f];
      const vA = this.vertices[face.a];
      const vB = this.vertices[face.b];
      const vC = this.vertices[face.c];
      cb2.subVectors(vC, vB);
      ab3.subVectors(vA, vB);
      cb2.cross(ab3);
      cb2.normalize();
      face.normal.copy(cb2);
    }
  }
  computeVertexNormals(areaWeighted = true) {
    const vertices = new Array(this.vertices.length);
    for (let v3 = 0, vl = this.vertices.length; v3 < vl; v3++) {
      vertices[v3] = new Vector3();
    }
    if (areaWeighted) {
      const cb2 = new Vector3(), ab3 = new Vector3();
      for (let f = 0, fl = this.faces.length; f < fl; f++) {
        const face = this.faces[f];
        const vA = this.vertices[face.a];
        const vB = this.vertices[face.b];
        const vC = this.vertices[face.c];
        cb2.subVectors(vC, vB);
        ab3.subVectors(vA, vB);
        cb2.cross(ab3);
        vertices[face.a].add(cb2);
        vertices[face.b].add(cb2);
        vertices[face.c].add(cb2);
      }
    } else {
      this.computeFaceNormals();
      for (let f = 0, fl = this.faces.length; f < fl; f++) {
        const face = this.faces[f];
        vertices[face.a].add(face.normal);
        vertices[face.b].add(face.normal);
        vertices[face.c].add(face.normal);
      }
    }
    for (let v3 = 0, vl = this.vertices.length; v3 < vl; v3++) {
      vertices[v3].normalize();
    }
    for (let f = 0, fl = this.faces.length; f < fl; f++) {
      const face = this.faces[f];
      const vertexNormals = face.vertexNormals;
      if (vertexNormals.length === 3) {
        vertexNormals[0].copy(vertices[face.a]);
        vertexNormals[1].copy(vertices[face.b]);
        vertexNormals[2].copy(vertices[face.c]);
      } else {
        vertexNormals[0] = vertices[face.a].clone();
        vertexNormals[1] = vertices[face.b].clone();
        vertexNormals[2] = vertices[face.c].clone();
      }
    }
    if (this.faces.length > 0) {
      this.normalsNeedUpdate = true;
    }
  }
  computeFlatVertexNormals() {
    this.computeFaceNormals();
    for (let f = 0, fl = this.faces.length; f < fl; f++) {
      const face = this.faces[f];
      const vertexNormals = face.vertexNormals;
      if (vertexNormals.length === 3) {
        vertexNormals[0].copy(face.normal);
        vertexNormals[1].copy(face.normal);
        vertexNormals[2].copy(face.normal);
      } else {
        vertexNormals[0] = face.normal.clone();
        vertexNormals[1] = face.normal.clone();
        vertexNormals[2] = face.normal.clone();
      }
    }
    if (this.faces.length > 0) {
      this.normalsNeedUpdate = true;
    }
  }
  computeMorphNormals() {
    for (let f = 0, fl = this.faces.length; f < fl; f++) {
      const face = this.faces[f];
      if (!face.__originalFaceNormal) {
        face.__originalFaceNormal = face.normal.clone();
      } else {
        face.__originalFaceNormal.copy(face.normal);
      }
      if (!face.__originalVertexNormals)
        face.__originalVertexNormals = [];
      for (let i2 = 0, il = face.vertexNormals.length; i2 < il; i2++) {
        if (!face.__originalVertexNormals[i2]) {
          face.__originalVertexNormals[i2] = face.vertexNormals[i2].clone();
        } else {
          face.__originalVertexNormals[i2].copy(face.vertexNormals[i2]);
        }
      }
    }
    const tmpGeo = new Geometry();
    tmpGeo.faces = this.faces;
    for (let i2 = 0, il = this.morphTargets.length; i2 < il; i2++) {
      if (!this.morphNormals[i2]) {
        this.morphNormals[i2] = {};
        this.morphNormals[i2].faceNormals = [];
        this.morphNormals[i2].vertexNormals = [];
        const dstNormalsFace = this.morphNormals[i2].faceNormals;
        const dstNormalsVertex = this.morphNormals[i2].vertexNormals;
        for (let f = 0, fl = this.faces.length; f < fl; f++) {
          const faceNormal = new Vector3();
          const vertexNormals = {
            a: new Vector3(),
            b: new Vector3(),
            c: new Vector3()
          };
          dstNormalsFace.push(faceNormal);
          dstNormalsVertex.push(vertexNormals);
        }
      }
      const morphNormals = this.morphNormals[i2];
      tmpGeo.vertices = this.morphTargets[i2].vertices;
      tmpGeo.computeFaceNormals();
      tmpGeo.computeVertexNormals();
      for (let f = 0, fl = this.faces.length; f < fl; f++) {
        const face = this.faces[f];
        const faceNormal = morphNormals.faceNormals[f];
        const vertexNormals = morphNormals.vertexNormals[f];
        faceNormal.copy(face.normal);
        vertexNormals.a.copy(face.vertexNormals[0]);
        vertexNormals.b.copy(face.vertexNormals[1]);
        vertexNormals.c.copy(face.vertexNormals[2]);
      }
    }
    for (let f = 0, fl = this.faces.length; f < fl; f++) {
      const face = this.faces[f];
      face.normal = face.__originalFaceNormal;
      face.vertexNormals = face.__originalVertexNormals;
    }
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    this.boundingBox.setFromPoints(this.vertices);
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    this.boundingSphere.setFromPoints(this.vertices);
  }
  merge(geometry2, matrix3, materialIndexOffset = 0) {
    if (!(geometry2 && geometry2.isGeometry)) {
      console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", geometry2);
      return;
    }
    let normalMatrix;
    const vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry2.vertices, faces1 = this.faces, faces2 = geometry2.faces, colors1 = this.colors, colors2 = geometry2.colors;
    if (matrix3 !== void 0) {
      normalMatrix = new Matrix3().getNormalMatrix(matrix3);
    }
    for (let i2 = 0, il = vertices2.length; i2 < il; i2++) {
      const vertex = vertices2[i2];
      const vertexCopy = vertex.clone();
      if (matrix3 !== void 0)
        vertexCopy.applyMatrix4(matrix3);
      vertices1.push(vertexCopy);
    }
    for (let i2 = 0, il = colors2.length; i2 < il; i2++) {
      colors1.push(colors2[i2].clone());
    }
    for (let i2 = 0, il = faces2.length; i2 < il; i2++) {
      const face = faces2[i2];
      let normal, color3;
      const faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
      const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
      faceCopy.normal.copy(face.normal);
      if (normalMatrix !== void 0) {
        faceCopy.normal.applyMatrix3(normalMatrix).normalize();
      }
      for (let j2 = 0, jl2 = faceVertexNormals.length; j2 < jl2; j2++) {
        normal = faceVertexNormals[j2].clone();
        if (normalMatrix !== void 0) {
          normal.applyMatrix3(normalMatrix).normalize();
        }
        faceCopy.vertexNormals.push(normal);
      }
      faceCopy.color.copy(face.color);
      for (let j2 = 0, jl2 = faceVertexColors.length; j2 < jl2; j2++) {
        color3 = faceVertexColors[j2];
        faceCopy.vertexColors.push(color3.clone());
      }
      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
      faces1.push(faceCopy);
    }
    for (let i2 = 0, il = geometry2.faceVertexUvs.length; i2 < il; i2++) {
      const faceVertexUvs2 = geometry2.faceVertexUvs[i2];
      if (this.faceVertexUvs[i2] === void 0)
        this.faceVertexUvs[i2] = [];
      for (let j2 = 0, jl2 = faceVertexUvs2.length; j2 < jl2; j2++) {
        const uvs2 = faceVertexUvs2[j2], uvsCopy = [];
        for (let k = 0, kl = uvs2.length; k < kl; k++) {
          uvsCopy.push(uvs2[k].clone());
        }
        this.faceVertexUvs[i2].push(uvsCopy);
      }
    }
  }
  mergeMesh(mesh) {
    if (!(mesh && mesh.isMesh)) {
      console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", mesh);
      return;
    }
    if (mesh.matrixAutoUpdate)
      mesh.updateMatrix();
    this.merge(mesh.geometry, mesh.matrix);
  }
  mergeVertices(precisionPoints = 4) {
    const verticesMap = {};
    const unique = [], changes = [];
    const precision = Math.pow(10, precisionPoints);
    for (let i2 = 0, il = this.vertices.length; i2 < il; i2++) {
      const v3 = this.vertices[i2];
      const key = `${Math.round(v3.x * precision)}_${Math.round(v3.y * precision)}_${Math.round(v3.z * precision)}`;
      if (verticesMap[key] === void 0) {
        verticesMap[key] = i2;
        unique.push(this.vertices[i2]);
        changes[i2] = unique.length - 1;
      } else {
        changes[i2] = changes[verticesMap[key]];
      }
    }
    const faceIndicesToRemove = [];
    for (let i2 = 0, il = this.faces.length; i2 < il; i2++) {
      const face = this.faces[i2];
      face.a = changes[face.a];
      face.b = changes[face.b];
      face.c = changes[face.c];
      const indices = [face.a, face.b, face.c];
      for (let n = 0; n < 3; n++) {
        if (indices[n] === indices[(n + 1) % 3]) {
          faceIndicesToRemove.push(i2);
          break;
        }
      }
    }
    for (let i2 = faceIndicesToRemove.length - 1; i2 >= 0; i2--) {
      const idx = faceIndicesToRemove[i2];
      this.faces.splice(idx, 1);
      for (let j2 = 0, jl2 = this.faceVertexUvs.length; j2 < jl2; j2++) {
        this.faceVertexUvs[j2].splice(idx, 1);
      }
    }
    const diff = this.vertices.length - unique.length;
    this.vertices = unique;
    return diff;
  }
  setFromPoints(points) {
    this.vertices = [];
    for (let i2 = 0, l = points.length; i2 < l; i2++) {
      const point = points[i2];
      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));
    }
    return this;
  }
  sortFacesByMaterialIndex() {
    const faces = this.faces;
    const length2 = faces.length;
    for (let i2 = 0; i2 < length2; i2++) {
      faces[i2]._id = i2;
    }
    function materialIndexSort(a2, b2) {
      return a2.materialIndex - b2.materialIndex;
    }
    faces.sort(materialIndexSort);
    const uvs1 = this.faceVertexUvs[0];
    const uvs2 = this.faceVertexUvs[1];
    let newUvs1, newUvs2;
    if (uvs1 && uvs1.length === length2)
      newUvs1 = [];
    if (uvs2 && uvs2.length === length2)
      newUvs2 = [];
    for (let i2 = 0; i2 < length2; i2++) {
      const id = faces[i2]._id;
      if (newUvs1)
        newUvs1.push(uvs1[id]);
      if (newUvs2)
        newUvs2.push(uvs2[id]);
    }
    if (newUvs1)
      this.faceVertexUvs[0] = newUvs1;
    if (newUvs2)
      this.faceVertexUvs[1] = newUvs2;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "Geometry",
        generator: "Geometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (let key in parameters) {
        if (parameters[key] !== void 0)
          data[key] = parameters[key];
      }
      return data;
    }
    const vertices = [];
    for (let i2 = 0; i2 < this.vertices.length; i2++) {
      const vertex = this.vertices[i2];
      vertices.push(vertex.x, vertex.y, vertex.z);
    }
    const faces = [];
    const normals = [];
    const normalsHash = {};
    const colors = [];
    const colorsHash = {};
    const uvs = [];
    const uvsHash = {};
    for (let i2 = 0; i2 < this.faces.length; i2++) {
      const face = this.faces[i2];
      const hasMaterial = true;
      const hasFaceUv = false;
      const hasFaceVertexUv = this.faceVertexUvs[0][i2] !== void 0;
      const hasFaceNormal = face.normal.length() > 0;
      const hasFaceVertexNormal = face.vertexNormals.length > 0;
      const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
      const hasFaceVertexColor = face.vertexColors.length > 0;
      let faceType = 0;
      faceType = setBit(faceType, 0, 0);
      faceType = setBit(faceType, 1, hasMaterial);
      faceType = setBit(faceType, 2, hasFaceUv);
      faceType = setBit(faceType, 3, hasFaceVertexUv);
      faceType = setBit(faceType, 4, hasFaceNormal);
      faceType = setBit(faceType, 5, hasFaceVertexNormal);
      faceType = setBit(faceType, 6, hasFaceColor);
      faceType = setBit(faceType, 7, hasFaceVertexColor);
      faces.push(faceType);
      faces.push(face.a, face.b, face.c);
      faces.push(face.materialIndex);
      if (hasFaceVertexUv) {
        const faceVertexUvs = this.faceVertexUvs[0][i2];
        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
      }
      if (hasFaceNormal) {
        faces.push(getNormalIndex(face.normal));
      }
      if (hasFaceVertexNormal) {
        const vertexNormals = face.vertexNormals;
        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
      }
      if (hasFaceColor) {
        faces.push(getColorIndex(face.color));
      }
      if (hasFaceVertexColor) {
        const vertexColors = face.vertexColors;
        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
      }
    }
    function setBit(value, position, enabled) {
      return enabled ? value | 1 << position : value & ~(1 << position);
    }
    function getNormalIndex(normal) {
      const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
      if (normalsHash[hash] !== void 0) {
        return normalsHash[hash];
      }
      normalsHash[hash] = normals.length / 3;
      normals.push(normal.x, normal.y, normal.z);
      return normalsHash[hash];
    }
    function getColorIndex(color3) {
      const hash = color3.r.toString() + color3.g.toString() + color3.b.toString();
      if (colorsHash[hash] !== void 0) {
        return colorsHash[hash];
      }
      colorsHash[hash] = colors.length;
      colors.push(color3.getHex());
      return colorsHash[hash];
    }
    function getUvIndex(uv2) {
      const hash = uv2.x.toString() + uv2.y.toString();
      if (uvsHash[hash] !== void 0) {
        return uvsHash[hash];
      }
      uvsHash[hash] = uvs.length / 2;
      uvs.push(uv2.x, uv2.y);
      return uvsHash[hash];
    }
    data.data = {};
    data.data.vertices = vertices;
    data.data.normals = normals;
    if (colors.length > 0)
      data.data.colors = colors;
    if (uvs.length > 0)
      data.data.uvs = [uvs];
    data.data.faces = faces;
    return data;
  }
  clone() {
    return new Geometry().copy(this);
  }
  copy(source) {
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.name = source.name;
    const vertices = source.vertices;
    for (let i2 = 0, il = vertices.length; i2 < il; i2++) {
      this.vertices.push(vertices[i2].clone());
    }
    const colors = source.colors;
    for (let i2 = 0, il = colors.length; i2 < il; i2++) {
      this.colors.push(colors[i2].clone());
    }
    const faces = source.faces;
    for (let i2 = 0, il = faces.length; i2 < il; i2++) {
      this.faces.push(faces[i2].clone());
    }
    for (let i2 = 0, il = source.faceVertexUvs.length; i2 < il; i2++) {
      const faceVertexUvs = source.faceVertexUvs[i2];
      if (this.faceVertexUvs[i2] === void 0) {
        this.faceVertexUvs[i2] = [];
      }
      for (let j2 = 0, jl2 = faceVertexUvs.length; j2 < jl2; j2++) {
        const uvs = faceVertexUvs[j2], uvsCopy = [];
        for (let k = 0, kl = uvs.length; k < kl; k++) {
          const uv2 = uvs[k];
          uvsCopy.push(uv2.clone());
        }
        this.faceVertexUvs[i2].push(uvsCopy);
      }
    }
    const morphTargets = source.morphTargets;
    for (let i2 = 0, il = morphTargets.length; i2 < il; i2++) {
      const morphTarget = {};
      morphTarget.name = morphTargets[i2].name;
      if (morphTargets[i2].vertices !== void 0) {
        morphTarget.vertices = [];
        for (let j2 = 0, jl2 = morphTargets[i2].vertices.length; j2 < jl2; j2++) {
          morphTarget.vertices.push(morphTargets[i2].vertices[j2].clone());
        }
      }
      if (morphTargets[i2].normals !== void 0) {
        morphTarget.normals = [];
        for (let j2 = 0, jl2 = morphTargets[i2].normals.length; j2 < jl2; j2++) {
          morphTarget.normals.push(morphTargets[i2].normals[j2].clone());
        }
      }
      this.morphTargets.push(morphTarget);
    }
    const morphNormals = source.morphNormals;
    for (let i2 = 0, il = morphNormals.length; i2 < il; i2++) {
      const morphNormal = {};
      if (morphNormals[i2].vertexNormals !== void 0) {
        morphNormal.vertexNormals = [];
        for (let j2 = 0, jl2 = morphNormals[i2].vertexNormals.length; j2 < jl2; j2++) {
          const srcVertexNormal = morphNormals[i2].vertexNormals[j2];
          const destVertexNormal = {};
          destVertexNormal.a = srcVertexNormal.a.clone();
          destVertexNormal.b = srcVertexNormal.b.clone();
          destVertexNormal.c = srcVertexNormal.c.clone();
          morphNormal.vertexNormals.push(destVertexNormal);
        }
      }
      if (morphNormals[i2].faceNormals !== void 0) {
        morphNormal.faceNormals = [];
        for (let j2 = 0, jl2 = morphNormals[i2].faceNormals.length; j2 < jl2; j2++) {
          morphNormal.faceNormals.push(morphNormals[i2].faceNormals[j2].clone());
        }
      }
      this.morphNormals.push(morphNormal);
    }
    const skinWeights = source.skinWeights;
    for (let i2 = 0, il = skinWeights.length; i2 < il; i2++) {
      this.skinWeights.push(skinWeights[i2].clone());
    }
    const skinIndices = source.skinIndices;
    for (let i2 = 0, il = skinIndices.length; i2 < il; i2++) {
      this.skinIndices.push(skinIndices[i2].clone());
    }
    const lineDistances = source.lineDistances;
    for (let i2 = 0, il = lineDistances.length; i2 < il; i2++) {
      this.lineDistances.push(lineDistances[i2]);
    }
    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.elementsNeedUpdate = source.elementsNeedUpdate;
    this.verticesNeedUpdate = source.verticesNeedUpdate;
    this.uvsNeedUpdate = source.uvsNeedUpdate;
    this.normalsNeedUpdate = source.normalsNeedUpdate;
    this.colorsNeedUpdate = source.colorsNeedUpdate;
    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
    this.groupsNeedUpdate = source.groupsNeedUpdate;
    return this;
  }
  toBufferGeometry() {
    const geometry2 = new DirectGeometry().fromGeometry(this);
    const buffergeometry = new BufferGeometry();
    const positions = new Float32Array(geometry2.vertices.length * 3);
    buffergeometry.setAttribute("position", new BufferAttribute(positions, 3).copyVector3sArray(geometry2.vertices));
    if (geometry2.normals.length > 0) {
      const normals = new Float32Array(geometry2.normals.length * 3);
      buffergeometry.setAttribute("normal", new BufferAttribute(normals, 3).copyVector3sArray(geometry2.normals));
    }
    if (geometry2.colors.length > 0) {
      const colors = new Float32Array(geometry2.colors.length * 3);
      buffergeometry.setAttribute("color", new BufferAttribute(colors, 3).copyColorsArray(geometry2.colors));
    }
    if (geometry2.uvs.length > 0) {
      const uvs = new Float32Array(geometry2.uvs.length * 2);
      buffergeometry.setAttribute("uv", new BufferAttribute(uvs, 2).copyVector2sArray(geometry2.uvs));
    }
    if (geometry2.uvs2.length > 0) {
      const uvs2 = new Float32Array(geometry2.uvs2.length * 2);
      buffergeometry.setAttribute("uv2", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry2.uvs2));
    }
    buffergeometry.groups = geometry2.groups;
    for (let name in geometry2.morphTargets) {
      const array = [];
      const morphTargets = geometry2.morphTargets[name];
      for (let i2 = 0, l = morphTargets.length; i2 < l; i2++) {
        const morphTarget = morphTargets[i2];
        const attribute2 = new Float32BufferAttribute(morphTarget.data.length * 3, 3);
        attribute2.name = morphTarget.name;
        array.push(attribute2.copyVector3sArray(morphTarget.data));
      }
      buffergeometry.morphAttributes[name] = array;
    }
    if (geometry2.skinIndices.length > 0) {
      const skinIndices = new Float32BufferAttribute(geometry2.skinIndices.length * 4, 4);
      buffergeometry.setAttribute("skinIndex", skinIndices.copyVector4sArray(geometry2.skinIndices));
    }
    if (geometry2.skinWeights.length > 0) {
      const skinWeights = new Float32BufferAttribute(geometry2.skinWeights.length * 4, 4);
      buffergeometry.setAttribute("skinWeight", skinWeights.copyVector4sArray(geometry2.skinWeights));
    }
    if (geometry2.boundingSphere !== null) {
      buffergeometry.boundingSphere = geometry2.boundingSphere.clone();
    }
    if (geometry2.boundingBox !== null) {
      buffergeometry.boundingBox = geometry2.boundingBox.clone();
    }
    return buffergeometry;
  }
  computeTangents() {
    console.error("THREE.Geometry: .computeTangents() has been removed.");
  }
  computeLineDistances() {
    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
  }
  applyMatrix(matrix3) {
    console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().");
    return this.applyMatrix4(matrix3);
  }
  dispose() {
    this.dispatchEvent({
      type: "dispose"
    });
  }
};
Geometry.createBufferGeometryFromObject = (object) => {
  let buffergeometry = new BufferGeometry();
  const geometry2 = object.geometry;
  if (object.isPoints || object.isLine) {
    const positions = new Float32BufferAttribute(geometry2.vertices.length * 3, 3);
    const colors = new Float32BufferAttribute(geometry2.colors.length * 3, 3);
    buffergeometry.setAttribute("position", positions.copyVector3sArray(geometry2.vertices));
    buffergeometry.setAttribute("color", colors.copyColorsArray(geometry2.colors));
    if (geometry2.lineDistances && geometry2.lineDistances.length === geometry2.vertices.length) {
      const lineDistances = new Float32BufferAttribute(geometry2.lineDistances.length, 1);
      buffergeometry.setAttribute("lineDistance", lineDistances.copyArray(geometry2.lineDistances));
    }
    if (geometry2.boundingSphere !== null) {
      buffergeometry.boundingSphere = geometry2.boundingSphere.clone();
    }
    if (geometry2.boundingBox !== null) {
      buffergeometry.boundingBox = geometry2.boundingBox.clone();
    }
  } else if (object.isMesh) {
    buffergeometry = geometry2.toBufferGeometry();
  }
  return buffergeometry;
};
var DirectGeometry = class {
  constructor() {
    this.vertices = [];
    this.normals = [];
    this.colors = [];
    this.uvs = [];
    this.uvs2 = [];
    this.groups = [];
    this.morphTargets = {};
    this.skinWeights = [];
    this.skinIndices = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.verticesNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.groupsNeedUpdate = false;
  }
  computeGroups(geometry2) {
    const groups = [];
    let group, i2;
    let materialIndex = void 0;
    const faces = geometry2.faces;
    for (i2 = 0; i2 < faces.length; i2++) {
      const face = faces[i2];
      if (face.materialIndex !== materialIndex) {
        materialIndex = face.materialIndex;
        if (group !== void 0) {
          group.count = i2 * 3 - group.start;
          groups.push(group);
        }
        group = {
          start: i2 * 3,
          materialIndex
        };
      }
    }
    if (group !== void 0) {
      group.count = i2 * 3 - group.start;
      groups.push(group);
    }
    this.groups = groups;
  }
  fromGeometry(geometry2) {
    const faces = geometry2.faces;
    const vertices = geometry2.vertices;
    const faceVertexUvs = geometry2.faceVertexUvs;
    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
    const morphTargets = geometry2.morphTargets;
    const morphTargetsLength = morphTargets.length;
    let morphTargetsPosition;
    if (morphTargetsLength > 0) {
      morphTargetsPosition = [];
      for (let i2 = 0; i2 < morphTargetsLength; i2++) {
        morphTargetsPosition[i2] = {
          name: morphTargets[i2].name,
          data: []
        };
      }
      this.morphTargets.position = morphTargetsPosition;
    }
    const morphNormals = geometry2.morphNormals;
    const morphNormalsLength = morphNormals.length;
    let morphTargetsNormal;
    if (morphNormalsLength > 0) {
      morphTargetsNormal = [];
      for (let i2 = 0; i2 < morphNormalsLength; i2++) {
        morphTargetsNormal[i2] = {
          name: morphNormals[i2].name,
          data: []
        };
      }
      this.morphTargets.normal = morphTargetsNormal;
    }
    const skinIndices = geometry2.skinIndices;
    const skinWeights = geometry2.skinWeights;
    const hasSkinIndices = skinIndices.length === vertices.length;
    const hasSkinWeights = skinWeights.length === vertices.length;
    if (vertices.length > 0 && faces.length === 0) {
      console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
    }
    for (let i2 = 0; i2 < faces.length; i2++) {
      const face = faces[i2];
      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
      const vertexNormals = face.vertexNormals;
      if (vertexNormals.length === 3) {
        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
      } else {
        const normal = face.normal;
        this.normals.push(normal, normal, normal);
      }
      const vertexColors = face.vertexColors;
      if (vertexColors.length === 3) {
        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
      } else {
        const color3 = face.color;
        this.colors.push(color3, color3, color3);
      }
      if (hasFaceVertexUv === true) {
        const vertexUvs = faceVertexUvs[0][i2];
        if (vertexUvs !== void 0) {
          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
        } else {
          console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", i2);
          this.uvs.push(new Vector2(), new Vector2(), new Vector2());
        }
      }
      if (hasFaceVertexUv2 === true) {
        const vertexUvs = faceVertexUvs[1][i2];
        if (vertexUvs !== void 0) {
          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
        } else {
          console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", i2);
          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
        }
      }
      for (let j2 = 0; j2 < morphTargetsLength; j2++) {
        const morphTarget = morphTargets[j2].vertices;
        morphTargetsPosition[j2].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
      }
      for (let j2 = 0; j2 < morphNormalsLength; j2++) {
        const morphNormal = morphNormals[j2].vertexNormals[i2];
        morphTargetsNormal[j2].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
      }
      if (hasSkinIndices) {
        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
      }
      if (hasSkinWeights) {
        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
      }
    }
    this.computeGroups(geometry2);
    this.verticesNeedUpdate = geometry2.verticesNeedUpdate;
    this.normalsNeedUpdate = geometry2.normalsNeedUpdate;
    this.colorsNeedUpdate = geometry2.colorsNeedUpdate;
    this.uvsNeedUpdate = geometry2.uvsNeedUpdate;
    this.groupsNeedUpdate = geometry2.groupsNeedUpdate;
    if (geometry2.boundingSphere !== null) {
      this.boundingSphere = geometry2.boundingSphere.clone();
    }
    if (geometry2.boundingBox !== null) {
      this.boundingBox = geometry2.boundingBox.clone();
    }
    return this;
  }
};
var Face3 = class {
  constructor(a2, b2, c2, normal, color3, materialIndex = 0) {
    this.a = a2;
    this.b = b2;
    this.c = c2;
    this.normal = normal && normal.isVector3 ? normal : new Vector3();
    this.vertexNormals = Array.isArray(normal) ? normal : [];
    this.color = color3 && color3.isColor ? color3 : new Color();
    this.vertexColors = Array.isArray(color3) ? color3 : [];
    this.materialIndex = materialIndex;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.a = source.a;
    this.b = source.b;
    this.c = source.c;
    this.normal.copy(source.normal);
    this.color.copy(source.color);
    this.materialIndex = source.materialIndex;
    for (let i2 = 0, il = source.vertexNormals.length; i2 < il; i2++) {
      this.vertexNormals[i2] = source.vertexNormals[i2].clone();
    }
    for (let i2 = 0, il = source.vertexColors.length; i2 < il; i2++) {
      this.vertexColors[i2] = source.vertexColors[i2].clone();
    }
    return this;
  }
};

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/materials/NodeMaterial.js
var NodeMaterial = class extends ShaderMaterial {
  constructor() {
    super();
    this.type = this.constructor.name;
    this.lights = true;
  }
  setDefaultValues(values) {
    let value;
    for (const property in values) {
      value = values[property];
      if (this[property] === void 0) {
        if (value && typeof value.clone === "function") {
          this[property] = value.clone();
        } else {
          this[property] = value;
        }
      }
    }
    Object.assign(this.defines, values.defines);
  }
  toJSON(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    const data = Material.prototype.toJSON.call(this, meta);
    const nodeKeys = getNodesKeys(this);
    data.inputNodes = {};
    for (const name of nodeKeys) {
      data.inputNodes[name] = this[name].toJSON(meta).uuid;
    }
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
      if (nodes.length > 0)
        data.nodes = nodes;
    }
    return data;
  }
};
NodeMaterial.prototype.isNodeMaterial = true;
var NodeMaterial_default = NodeMaterial;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/materials/LineBasicNodeMaterial.js
var defaultValues = new LineBasicMaterial();
var LineBasicNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.lightNode = null;
    this.positionNode = null;
    this.setDefaultValues(defaultValues);
    this.setValues(parameters);
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.lightNode = source.lightNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};
LineBasicNodeMaterial.prototype.isLineBasicNodeMaterial = true;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/materials/MeshBasicNodeMaterial.js
var defaultValues2 = new MeshBasicMaterial();
var MeshBasicNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.lights = true;
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.lightNode = null;
    this.positionNode = null;
    this.setDefaultValues(defaultValues2);
    this.setValues(parameters);
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.lightNode = source.lightNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};
MeshBasicNodeMaterial.prototype.isMeshBasicNodeMaterial = true;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/materials/MeshStandardNodeMaterial.js
var defaultValues3 = new MeshStandardMaterial();
var MeshStandardNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.normalNode = null;
    this.emissiveNode = null;
    this.metalnessNode = null;
    this.roughnessNode = null;
    this.clearcoatNode = null;
    this.clearcoatRoughnessNode = null;
    this.envNode = null;
    this.lightNode = null;
    this.positionNode = null;
    this.setDefaultValues(defaultValues3);
    this.setValues(parameters);
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.normalNode = source.normalNode;
    this.emissiveNode = source.emissiveNode;
    this.metalnessNode = source.metalnessNode;
    this.roughnessNode = source.roughnessNode;
    this.clearcoatNode = source.clearcoatNode;
    this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;
    this.envNode = source.envNode;
    this.lightNode = source.lightNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};
MeshStandardNodeMaterial.prototype.isMeshStandardNodeMaterial = true;

// node_modules/@react-three/postprocessing/node_modules/three-stdlib/nodes/materials/PointsNodeMaterial.js
var defaultValues4 = new PointsMaterial();
var PointsNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.transparent = true;
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.lightNode = null;
    this.sizeNode = null;
    this.positionNode = null;
    this.setDefaultValues(defaultValues4);
    this.setValues(parameters);
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.lightNode = source.lightNode;
    this.sizeNode = source.sizeNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};
PointsNodeMaterial.prototype.isPointsNodeMaterial = true;

// node_modules/screen-space-reflections/dist/index.js
function _extends2() {
  _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
var boxBlur = "#define GLSLIFY 1\nuniform float blur;uniform float blurSharpness;uniform int blurKernel;vec3 denoise(vec3 center,sampler2D tex,vec2 uv,vec2 invTexSize,float blur,float blurSharpness,int blurKernel){vec3 color;float total;vec3 col;float weight;for(int x=-blurKernel;x<=blurKernel;x++){for(int y=-blurKernel;y<=blurKernel;y++){col=textureLod(tex,uv+vec2(x,y)*invTexSize,0.).rgb;weight=1.0-abs(dot(col-center,vec3(0.25)));weight=pow(weight,blurSharpness);color+=col*weight;total+=weight;}}return color/total;}";
var finalSSRShader = "#define GLSLIFY 1\n#define MODE_DEFAULT 0\n#define MODE_REFLECTIONS 1\n#define MODE_RAW_REFLECTION 2\n#define MODE_BLURRED_REFLECTIONS 3\n#define MODE_INPUT 4\n#define MODE_BLUR_MIX 5\n#define FLOAT_EPSILON 0.00001\nuniform sampler2D inputTexture;uniform sampler2D reflectionsTexture;uniform float samples;\n#include <boxBlur>\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 reflectionsTexel=texture2D(reflectionsTexture,vUv);ivec2 size=textureSize(reflectionsTexture,0);vec2 invTexSize=1./vec2(size.x,size.y);vec3 reflectionClr=reflectionsTexel.xyz;if(blur>FLOAT_EPSILON){vec3 blurredReflectionsColor=denoise(reflectionsTexel.rgb,reflectionsTexture,vUv,invTexSize,blur,blurSharpness,blurKernel);reflectionClr=mix(reflectionClr,blurredReflectionsColor.rgb,blur);}\n#if RENDER_MODE == MODE_DEFAULT\noutputColor=vec4(inputColor.rgb+reflectionClr,1.0);\n#endif\n#if RENDER_MODE == MODE_REFLECTIONS\noutputColor=vec4(reflectionClr,1.0);\n#endif\n#if RENDER_MODE == MODE_RAW_REFLECTION\noutputColor=vec4(reflectionsTexel.xyz,1.0);\n#endif\n#if RENDER_MODE == MODE_BLURRED_REFLECTIONS\noutputColor=vec4(blurredReflectionsTexel.xyz,1.0);\n#endif\n#if RENDER_MODE == MODE_INPUT\noutputColor=vec4(inputColor.xyz,1.0);\n#endif\n#if RENDER_MODE == MODE_BLUR_MIX\noutputColor=vec4(vec3(blur),1.0);\n#endif\n}";
var helperFunctions = "#define GLSLIFY 1\nvec3 getViewPosition(const float depth){float clipW=_projectionMatrix[2][3]*depth+_projectionMatrix[3][3];vec4 clipPosition=vec4((vec3(vUv,depth)-0.5)*2.0,1.0);clipPosition*=clipW;return(_inverseProjectionMatrix*clipPosition).xyz;}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 screenSpaceToWorldSpace(const vec2 uv,const float depth){vec4 ndc=vec4((uv.x-0.5)*2.0,(uv.y-0.5)*2.0,(depth-0.5)*2.0,1.0);vec4 clip=_inverseProjectionMatrix*ndc;vec4 view=cameraMatrixWorld*(clip/clip.w);return view.xyz;}\n#define Scale (vec3(0.8, 0.8, 0.8))\n#define K (19.19)\nvec3 hash(vec3 a){a=fract(a*Scale);a+=dot(a,a.yxz+K);return fract((a.xxy+a.yxx)*a.zyx);}float fresnel_dielectric_cos(float cosi,float eta){float c=abs(cosi);float g=eta*eta-1.0+c*c;float result;if(g>0.0){g=sqrt(g);float A=(g-c)/(g+c);float B=(c*(g+c)-1.0)/(c*(g-c)+1.0);result=0.5*A*A*(1.0+B*B);}else{result=1.0;}return result;}float fresnel_dielectric(vec3 Incoming,vec3 Normal,float eta){float cosine=dot(Incoming,Normal);return min(1.0,5.0*fresnel_dielectric_cos(cosine,eta));}";
var trCompose = "#define GLSLIFY 1\n#define INV_EULER 0.36787944117144233\nalpha=velocityDisocclusion<FLOAT_EPSILON ?(alpha+0.0075): 0.0;alpha=clamp(alpha,0.0,1.0);bool needsBlur=!didReproject||velocityDisocclusion>0.5;\n#ifdef boxBlur\nif(needsBlur)inputColor=boxBlurredColor;\n#endif\nif(alpha==1.0){outputColor=accumulatedColor;}else{float m=mix(alpha,1.0,blend);if(needsBlur)m=0.0;outputColor=accumulatedColor*m+inputColor*(1.0-m);}";
var MRTMaterial = class extends ShaderMaterial {
  constructor() {
    super({
      type: "MRTMaterial",
      defines: {
        USE_UV: "",
        TEMPORAL_RESOLVE: ""
      },
      uniforms: {
        opacity: new Uniform(1),
        normalMap: new Uniform(null),
        normalScale: new Uniform(new Vector2(1, 1)),
        uvTransform: new Uniform(new Matrix3()),
        roughness: new Uniform(1),
        roughnessMap: new Uniform(null)
      },
      vertexShader: `
                #ifdef USE_MRT
                 varying vec2 vHighPrecisionZW;
                #endif
                #define NORMAL
                #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
                    varying vec3 vViewPosition;
                #endif
                #include <common>
                #include <uv_pars_vertex>
                #include <displacementmap_pars_vertex>
                #include <normal_pars_vertex>
                #include <morphtarget_pars_vertex>
                #include <skinning_pars_vertex>
                #include <logdepthbuf_pars_vertex>
                #include <clipping_planes_pars_vertex>
                void main() {
                    #include <uv_vertex>
                    #include <beginnormal_vertex>
                    #include <morphnormal_vertex>
                    #include <skinbase_vertex>
                    #include <skinnormal_vertex>
                    #include <defaultnormal_vertex>
                    #include <normal_vertex>
                    #include <begin_vertex>
                    #include <morphtarget_vertex>
                    #include <skinning_vertex>
                    #include <displacementmap_vertex>
                    #include <project_vertex>
                    #include <logdepthbuf_vertex>
                    #include <clipping_planes_vertex>
                    #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
                        vViewPosition = - mvPosition.xyz;
                    #endif
                    #ifdef USE_MRT
                        vHighPrecisionZW = gl_Position.zw;
                    #endif 
                    #ifdef USE_UV
                        vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
                    #endif
                }
            `,
      fragmentShader: `
                 #define NORMAL
                #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
                    varying vec3 vViewPosition;
                #endif
                #include <packing>
                #include <uv_pars_fragment>
                #include <normal_pars_fragment>
                #include <bumpmap_pars_fragment>
                #include <normalmap_pars_fragment>
                #include <logdepthbuf_pars_fragment>
                #include <clipping_planes_pars_fragment>
                #include <roughnessmap_pars_fragment>
                
                #ifdef USE_MRT
                layout(location = 0) out vec4 gNormal;
                layout(location = 1) out vec4 gDepth;
                
                varying vec2 vHighPrecisionZW;
                #endif
                uniform float roughness;
                void main() {
                    #include <clipping_planes_fragment>
                    #include <logdepthbuf_fragment>
                    #include <normal_fragment_begin>
                    #include <normal_fragment_maps>

                    float roughnessFactor = roughness;
                    
                    if(roughness > 10.0e9){
                        roughnessFactor = 1.;
                    }else{
                        #ifdef useRoughnessMap
                            vec4 texelRoughness = texture2D( roughnessMap, vUv );
                            // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
                            roughnessFactor *= texelRoughness.g;
                        #endif
                    }

                    vec3 normalColor = packNormalToRGB( normal );
                    #ifdef USE_MRT
                        float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
                        vec4 depthColor = packDepthToRGBA( fragCoordZ );
                        gNormal = vec4( normalColor, roughnessFactor );
                        gDepth = depthColor;
                    #else
                        gl_FragColor = vec4(normalColor, roughnessFactor);
                    #endif
                }
            `,
      toneMapped: false
    });
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    Object.defineProperty(this, "glslVersion", {
      get() {
        return "USE_MRT" in this.defines ? GLSL3 : null;
      },
      set(_) {
      }
    });
  }
};
var vertexShader$1 = "#define GLSLIFY 1\nvarying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}";
var fragmentShader = "#define GLSLIFY 1\nvarying vec2 vUv;uniform sampler2D inputTexture;uniform sampler2D accumulatedTexture;uniform sampler2D normalTexture;uniform sampler2D depthTexture;uniform sampler2D envMap;uniform mat4 _projectionMatrix;uniform mat4 _inverseProjectionMatrix;uniform mat4 cameraMatrixWorld;uniform float cameraNear;uniform float cameraFar;uniform float rayDistance;uniform float intensity;uniform float maxDepthDifference;uniform float roughnessFade;uniform float maxRoughness;uniform float fade;uniform float thickness;uniform float ior;uniform float samples;uniform float jitter;uniform float jitterRoughness;\n#define INVALID_RAY_COORDS vec2(-1.0);\n#define EARLY_OUT_COLOR vec4(0.0, 0.0, 0.0, 1.0)\n#define FLOAT_EPSILON 0.00001\nfloat nearMinusFar;float nearMulFar;float farMinusNear;\n#include <packing>\n#include <helperFunctions>\nvec2 RayMarch(vec3 dir,inout vec3 hitPos,inout float rayHitDepthDifference);vec2 BinarySearch(in vec3 dir,inout vec3 hitPos,inout float rayHitDepthDifference);float fastGetViewZ(const in float depth);vec3 getIBLRadiance(const in vec3 viewDir,const in vec3 normal,const in float roughness);void main(){vec4 depthTexel=textureLod(depthTexture,vUv,0.0);if(dot(depthTexel.rgb,depthTexel.rgb)<FLOAT_EPSILON){gl_FragColor=EARLY_OUT_COLOR;return;}float unpackedDepth=unpackRGBAToDepth(depthTexel);vec4 normalTexel=textureLod(normalTexture,vUv,0.0);float roughness=normalTexel.a;float specular=1.0-roughness;nearMinusFar=cameraNear-cameraFar;nearMulFar=cameraNear*cameraFar;farMinusNear=cameraFar-cameraNear;normalTexel.rgb=unpackRGBToNormal(normalTexel.rgb);float depth=fastGetViewZ(unpackedDepth);vec3 viewPos=getViewPosition(depth);vec3 viewDir=normalize(viewPos);vec3 viewNormal=normalTexel.xyz;vec3 worldPos=screenSpaceToWorldSpace(vUv,unpackedDepth);vec3 jitt=vec3(0.0);if(jitterRoughness!=0.0||jitter!=0.0){vec3 randomJitter=hash(50.0*samples*worldPos)-0.5;float spread=((2.0-specular)+roughness*jitterRoughness);float jitterMix=jitter*0.25+jitterRoughness*roughness;if(jitterMix>1.0)jitterMix=1.0;jitt=mix(vec3(0.0),randomJitter*spread,jitterMix);}viewNormal+=jitt;float fresnelFactor=fresnel_dielectric(viewDir,viewNormal,ior);vec3 iblRadiance=getIBLRadiance(-viewDir,viewNormal,0.)*fresnelFactor;float lastFrameAlpha=textureLod(accumulatedTexture,vUv,0.0).a;if(roughness>maxRoughness||(roughness>1.0-FLOAT_EPSILON&&roughnessFade>1.0-FLOAT_EPSILON)){gl_FragColor=vec4(iblRadiance,lastFrameAlpha);return;}vec3 reflected=reflect(viewDir,viewNormal);vec3 rayDir=reflected*-viewPos.z;vec3 hitPos=viewPos;float rayHitDepthDifference;vec2 coords=RayMarch(rayDir,hitPos,rayHitDepthDifference);if(coords.x==-1.0){gl_FragColor=vec4(iblRadiance,lastFrameAlpha);return;}vec4 SSRTexel=textureLod(inputTexture,coords.xy,0.0);vec4 SSRTexelReflected=textureLod(accumulatedTexture,coords.xy,0.0);vec3 SSR=SSRTexel.rgb+SSRTexelReflected.rgb;float roughnessFactor=mix(specular,1.0,max(0.0,1.0-roughnessFade));vec2 coordsNDC=(coords.xy*2.0-1.0);float screenFade=0.1;float maxDimension=min(1.0,max(abs(coordsNDC.x),abs(coordsNDC.y)));float reflectionIntensity=1.0-(max(0.0,maxDimension-screenFade)/(1.0-screenFade));reflectionIntensity=max(0.,reflectionIntensity);vec3 finalSSR=mix(iblRadiance,SSR,reflectionIntensity)*roughnessFactor;if(fade!=0.0){vec3 hitWorldPos=screenSpaceToWorldSpace(coords,rayHitDepthDifference);float reflectionDistance=distance(hitWorldPos,worldPos)+1.0;float opacity=1.0/(reflectionDistance*fade*0.1);if(opacity>1.0)opacity=1.0;finalSSR*=opacity;}finalSSR*=fresnelFactor*intensity;finalSSR=min(vec3(1.0),finalSSR);float alpha=hitPos.z==1.0 ? 1.0 : SSRTexelReflected.a;alpha=min(lastFrameAlpha,alpha);gl_FragColor=vec4(finalSSR,alpha);}vec2 RayMarch(vec3 dir,inout vec3 hitPos,inout float rayHitDepthDifference){dir=normalize(dir);dir*=rayDistance/float(steps);float depth;vec4 projectedCoord;vec4 lastProjectedCoord;float unpackedDepth;vec4 depthTexel;for(int i=0;i<steps;i++){hitPos+=dir;projectedCoord=_projectionMatrix*vec4(hitPos,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=projectedCoord.xy*0.5+0.5;\n#ifndef missedRays\nif(projectedCoord.x<0.0||projectedCoord.x>1.0||projectedCoord.y<0.0||projectedCoord.y>1.0){return INVALID_RAY_COORDS;}\n#endif\ndepthTexel=textureLod(depthTexture,projectedCoord.xy,0.0);unpackedDepth=unpackRGBAToDepth(depthTexel);depth=fastGetViewZ(unpackedDepth);rayHitDepthDifference=depth-hitPos.z;if(rayHitDepthDifference>=0.0&&rayHitDepthDifference<thickness){\n#if refineSteps == 0\nif(dot(depthTexel.rgb,depthTexel.rgb)<FLOAT_EPSILON)return INVALID_RAY_COORDS;\n#else\nreturn BinarySearch(dir,hitPos,rayHitDepthDifference);\n#endif\n}\n#ifndef missedRays\nif(hitPos.z>0.0){return INVALID_RAY_COORDS;}\n#endif\nlastProjectedCoord=projectedCoord;}hitPos.z=1.0;\n#ifndef missedRays\nreturn INVALID_RAY_COORDS;\n#endif\nrayHitDepthDifference=unpackedDepth;return projectedCoord.xy;}vec2 BinarySearch(in vec3 dir,inout vec3 hitPos,inout float rayHitDepthDifference){float depth;vec4 projectedCoord;vec2 lastMinProjectedCoordXY;float unpackedDepth;vec4 depthTexel;for(int i=0;i<refineSteps;i++){projectedCoord=_projectionMatrix*vec4(hitPos,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=projectedCoord.xy*0.5+0.5;depthTexel=textureLod(depthTexture,projectedCoord.xy,0.0);unpackedDepth=unpackRGBAToDepth(depthTexel);depth=fastGetViewZ(unpackedDepth);rayHitDepthDifference=depth-hitPos.z;dir*=0.5;if(rayHitDepthDifference>0.0){hitPos-=dir;}else{hitPos+=dir;}}if(dot(depthTexel.rgb,depthTexel.rgb)<FLOAT_EPSILON)return INVALID_RAY_COORDS;if(abs(rayHitDepthDifference)>maxDepthDifference)return INVALID_RAY_COORDS;projectedCoord=_projectionMatrix*vec4(hitPos,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=projectedCoord.xy*0.5+0.5;rayHitDepthDifference=unpackedDepth;return projectedCoord.xy;}float fastGetViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn nearMulFar/(farMinusNear*depth-cameraFar);\n#else\nreturn depth*nearMinusFar-cameraNear;\n#endif\n}\n#include <common>\n#include <cube_uv_reflection_fragment>\nvec3 getIBLRadiance(const in vec3 viewDir,const in vec3 normal,const in float roughness){\n#if defined(ENVMAP_TYPE_CUBE_UV)\nvec3 reflectVec=reflect(-viewDir,normal);reflectVec=normalize(mix(reflectVec,normal,roughness*roughness));reflectVec=inverseTransformDirection(reflectVec,viewMatrix);vec4 envMapColor=textureCubeUV(envMap,reflectVec,roughness);return envMapColor.rgb*intensity;\n#else\nreturn vec3(0.0);\n#endif\n}";
var ReflectionsMaterial = class extends ShaderMaterial {
  constructor() {
    super({
      type: "ReflectionsMaterial",
      uniforms: {
        inputTexture: new Uniform(null),
        accumulatedTexture: new Uniform(null),
        normalTexture: new Uniform(null),
        depthTexture: new Uniform(null),
        _projectionMatrix: new Uniform(new Matrix4()),
        _inverseProjectionMatrix: new Uniform(new Matrix4()),
        cameraMatrixWorld: new Uniform(new Matrix4()),
        cameraNear: new Uniform(0),
        cameraFar: new Uniform(0),
        rayDistance: new Uniform(0),
        intensity: new Uniform(0),
        roughnessFade: new Uniform(0),
        fade: new Uniform(0),
        thickness: new Uniform(0),
        ior: new Uniform(0),
        maxDepthDifference: new Uniform(0),
        jitter: new Uniform(0),
        jitterRoughness: new Uniform(0),
        maxRoughness: new Uniform(0),
        samples: new Uniform(0),
        envMap: new Uniform(null),
        envMapPosition: new Uniform(new Vector3()),
        envMapSize: new Uniform(new Vector3()),
        viewMatrix: new Uniform(new Matrix4())
      },
      defines: {
        steps: 20,
        refineSteps: 5,
        CUBEUV_TEXEL_WIDTH: 0,
        CUBEUV_TEXEL_HEIGHT: 0,
        CUBEUV_MAX_MIP: 0,
        vWorldPosition: "worldPos"
      },
      fragmentShader: fragmentShader.replace("#include <helperFunctions>", helperFunctions),
      vertexShader: vertexShader$1,
      toneMapped: false,
      depthWrite: false,
      depthTest: false
    });
  }
};
var getVisibleChildren = (object) => {
  const queue = [object];
  const objects = [];
  while (queue.length !== 0) {
    const mesh = queue.shift();
    if (mesh.material)
      objects.push(mesh);
    for (const c2 of mesh.children) {
      if (c2.visible)
        queue.push(c2);
    }
  }
  return objects;
};
var generateCubeUVSize = (parameters) => {
  const imageHeight = parameters.envMapCubeUVHeight;
  if (imageHeight === null)
    return null;
  const maxMip = Math.log2(imageHeight) - 2;
  const texelHeight = 1 / imageHeight;
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return {
    texelWidth,
    texelHeight,
    maxMip
  };
};
var setupEnvMap = (reflectionsMaterial, envMap, envMapCubeUVHeight) => {
  reflectionsMaterial.uniforms.envMap.value = envMap;
  const envMapCubeUVSize = generateCubeUVSize({
    envMapCubeUVHeight
  });
  reflectionsMaterial.defines.ENVMAP_TYPE_CUBE_UV = "";
  reflectionsMaterial.defines.CUBEUV_TEXEL_WIDTH = envMapCubeUVSize.texelWidth;
  reflectionsMaterial.defines.CUBEUV_TEXEL_HEIGHT = envMapCubeUVSize.texelHeight;
  reflectionsMaterial.defines.CUBEUV_MAX_MIP = envMapCubeUVSize.maxMip + ".0";
  reflectionsMaterial.needsUpdate = true;
};
var isWebGL2Available2 = () => {
  try {
    const canvas = document.createElement("canvas");
    return !!(window.WebGL2RenderingContext && canvas.getContext("webgl2"));
  } catch (e) {
    return false;
  }
};
var ReflectionsPass = class extends Pass {
  constructor(ssrEffect, options = {}) {
    super("ReflectionsPass");
    this.ssrEffect = void 0;
    this.cachedMaterials = /* @__PURE__ */ new WeakMap();
    this.USE_MRT = false;
    this.webgl1DepthPass = null;
    this.visibleMeshes = [];
    this.ssrEffect = ssrEffect;
    this._scene = ssrEffect._scene;
    this._camera = ssrEffect._camera;
    this.fullscreenMaterial = new ReflectionsMaterial();
    if (ssrEffect._camera.isPerspectiveCamera)
      this.fullscreenMaterial.defines.PERSPECTIVE_CAMERA = "";
    const width = options.width || typeof window !== "undefined" ? window.innerWidth : 2e3;
    const height = options.height || typeof window !== "undefined" ? window.innerHeight : 1e3;
    this.renderTarget = new WebGLRenderTarget(width, height, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      type: HalfFloatType,
      depthBuffer: false
    });
    this.renderPass = new RenderPass(this._scene, this._camera);
    this.USE_MRT = isWebGL2Available2();
    if (this.USE_MRT) {
      this.gBuffersRenderTarget = new WebGLMultipleRenderTargets(width, height, 2, {
        minFilter: LinearFilter,
        magFilter: LinearFilter
      });
      this.normalTexture = this.gBuffersRenderTarget.texture[0];
      this.depthTexture = this.gBuffersRenderTarget.texture[1];
    } else {
      this.webgl1DepthPass = new DepthPass(this._scene, this._camera);
      this.webgl1DepthPass.renderTarget.minFilter = LinearFilter;
      this.webgl1DepthPass.renderTarget.magFilter = LinearFilter;
      this.webgl1DepthPass.renderTarget.texture.minFilter = LinearFilter;
      this.webgl1DepthPass.renderTarget.texture.magFilter = LinearFilter;
      this.webgl1DepthPass.setSize(typeof window !== "undefined" ? window.innerWidth : 2e3, typeof window !== "undefined" ? window.innerHeight : 1e3);
      this.gBuffersRenderTarget = new WebGLRenderTarget(width, height, {
        minFilter: LinearFilter,
        magFilter: LinearFilter
      });
      this.normalTexture = this.gBuffersRenderTarget.texture;
      this.depthTexture = this.webgl1DepthPass.texture;
    }
    this.fullscreenMaterial.uniforms.normalTexture.value = this.normalTexture;
    this.fullscreenMaterial.uniforms.depthTexture.value = this.depthTexture;
    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.ssrEffect.temporalResolvePass.accumulatedTexture;
    this.fullscreenMaterial.uniforms.cameraMatrixWorld.value = this._camera.matrixWorld;
    this.fullscreenMaterial.uniforms._projectionMatrix.value = this._camera.projectionMatrix;
    this.fullscreenMaterial.uniforms._inverseProjectionMatrix.value = this._camera.projectionMatrixInverse;
  }
  setSize(width, height) {
    this.renderTarget.setSize(width * this.ssrEffect.resolutionScale, height * this.ssrEffect.resolutionScale);
    this.gBuffersRenderTarget.setSize(width * this.ssrEffect.resolutionScale, height * this.ssrEffect.resolutionScale);
    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.ssrEffect.temporalResolvePass.accumulatedTexture;
    this.fullscreenMaterial.needsUpdate = true;
  }
  dispose() {
    this.renderTarget.dispose();
    this.gBuffersRenderTarget.dispose();
    this.renderPass.dispose();
    if (!this.USE_MRT)
      this.webgl1DepthPass.dispose();
    this.fullscreenMaterial.dispose();
    this.normalTexture = null;
    this.depthTexture = null;
    this.velocityTexture = null;
  }
  keepMaterialMapUpdated(mrtMaterial, originalMaterial, prop, define) {
    if (this.ssrEffect[define]) {
      if (originalMaterial[prop] !== mrtMaterial[prop]) {
        mrtMaterial[prop] = originalMaterial[prop];
        mrtMaterial.uniforms[prop].value = originalMaterial[prop];
        if (originalMaterial[prop]) {
          mrtMaterial.defines[define] = "";
        } else {
          delete mrtMaterial.defines[define];
        }
        mrtMaterial.needsUpdate = true;
      }
    } else if (mrtMaterial[prop] !== void 0) {
      mrtMaterial[prop] = void 0;
      mrtMaterial.uniforms[prop].value = void 0;
      delete mrtMaterial.defines[define];
      mrtMaterial.needsUpdate = true;
    }
  }
  setMRTMaterialInScene() {
    this.visibleMeshes = getVisibleChildren(this._scene);
    for (const c2 of this.visibleMeshes) {
      if (c2.material) {
        const originalMaterial = c2.material;
        let [cachedOriginalMaterial, mrtMaterial] = this.cachedMaterials.get(c2) || [];
        if (originalMaterial !== cachedOriginalMaterial) {
          if (mrtMaterial)
            mrtMaterial.dispose();
          mrtMaterial = new MRTMaterial();
          if (this.USE_MRT)
            mrtMaterial.defines.USE_MRT = "";
          mrtMaterial.normalScale = originalMaterial.normalScale;
          mrtMaterial.uniforms.normalScale.value = originalMaterial.normalScale;
          const map = originalMaterial.map || originalMaterial.normalMap || originalMaterial.roughnessMap || originalMaterial.metalnessMap;
          if (map)
            mrtMaterial.uniforms.uvTransform.value = map.matrix;
          this.cachedMaterials.set(c2, [originalMaterial, mrtMaterial]);
        }
        this.keepMaterialMapUpdated(mrtMaterial, originalMaterial, "normalMap", "useNormalMap");
        this.keepMaterialMapUpdated(mrtMaterial, originalMaterial, "roughnessMap", "useRoughnessMap");
        mrtMaterial.uniforms.roughness.value = this.ssrEffect.selection.size === 0 || this.ssrEffect.selection.has(c2) ? originalMaterial.roughness || 0 : 1e11;
        c2.material = mrtMaterial;
      }
    }
  }
  unsetMRTMaterialInScene() {
    for (const c2 of this.visibleMeshes) {
      var _c$material;
      if (((_c$material = c2.material) == null ? void 0 : _c$material.type) === "MRTMaterial") {
        c2.visible = true;
        const [originalMaterial] = this.cachedMaterials.get(c2);
        c2.material = originalMaterial;
      }
    }
  }
  render(renderer, inputBuffer) {
    this.setMRTMaterialInScene();
    renderer.setRenderTarget(this.gBuffersRenderTarget);
    this.renderPass.render(renderer, this.gBuffersRenderTarget);
    this.unsetMRTMaterialInScene();
    if (!this.USE_MRT)
      this.webgl1DepthPass.renderPass.render(renderer, this.webgl1DepthPass.renderTarget);
    this.fullscreenMaterial.uniforms.inputTexture.value = inputBuffer.texture;
    this.fullscreenMaterial.uniforms.samples.value = this.ssrEffect.temporalResolvePass.samples;
    this.fullscreenMaterial.uniforms.cameraNear.value = this._camera.near;
    this.fullscreenMaterial.uniforms.cameraFar.value = this._camera.far;
    this.fullscreenMaterial.uniforms.viewMatrix.value.copy(this._camera.matrixWorldInverse);
    renderer.setRenderTarget(this.renderTarget);
    renderer.render(this.scene, this.camera);
  }
};
var defaultSSROptions = {
  intensity: 1,
  exponent: 1,
  distance: 10,
  fade: 0,
  roughnessFade: 1,
  thickness: 10,
  ior: 1.45,
  maxRoughness: 1,
  maxDepthDifference: 10,
  blend: 0.9,
  correction: 1,
  correctionRadius: 1,
  blur: 0.5,
  blurKernel: 1,
  blurSharpness: 10,
  jitter: 0,
  jitterRoughness: 0,
  steps: 20,
  refineSteps: 5,
  missedRays: true,
  useNormalMap: true,
  useRoughnessMap: true,
  resolutionScale: 1,
  velocityResolutionScale: 1
};
var vertexShader = "#define GLSLIFY 1\nvarying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}";
var temporalResolve = "#define GLSLIFY 1\nuniform sampler2D inputTexture;uniform sampler2D accumulatedTexture;uniform sampler2D velocityTexture;uniform sampler2D lastVelocityTexture;uniform float blend;uniform float correction;uniform float exponent;uniform float samples;uniform vec2 invTexSize;uniform mat4 curInverseProjectionMatrix;uniform mat4 curCameraMatrixWorld;uniform mat4 prevInverseProjectionMatrix;uniform mat4 prevCameraMatrixWorld;varying vec2 vUv;\n#define MAX_NEIGHBOR_DEPTH_DIFFERENCE 0.001\n#define FLOAT_EPSILON 0.00001\n#define FLOAT_ONE_MINUS_EPSILON 0.99999\nvec3 transformexponent;vec3 undoColorTransformExponent;vec3 transformColor(vec3 color){if(exponent==1.0)return color;return pow(abs(color),transformexponent);}vec3 undoColorTransform(vec3 color){if(exponent==1.0)return color;return max(pow(abs(color),undoColorTransformExponent),vec3(0.0));}void main(){if(exponent!=1.0){transformexponent=vec3(1.0/exponent);undoColorTransformExponent=vec3(exponent);}vec4 inputTexel=textureLod(inputTexture,vUv,0.0);vec4 accumulatedTexel;vec3 inputColor=transformColor(inputTexel.rgb);vec3 accumulatedColor;float alpha=inputTexel.a;float velocityDisocclusion;bool didReproject=false;\n#ifdef boxBlur\nvec3 boxBlurredColor=inputTexel.rgb;\n#endif\nvec4 velocity=textureLod(velocityTexture,vUv,0.0);bool isMoving=alpha<1.0||dot(velocity.xy,velocity.xy)>0.0;if(isMoving){vec3 minNeighborColor=inputColor;vec3 maxNeighborColor=inputColor;vec3 col;vec2 neighborUv;vec2 reprojectedUv=vUv-velocity.xy;vec4 lastVelocity=textureLod(lastVelocityTexture,reprojectedUv,0.0);float depth=velocity.b;float closestDepth=depth;float lastClosestDepth=lastVelocity.b;float neighborDepth;float lastNeighborDepth;for(int x=-correctionRadius;x<=correctionRadius;x++){for(int y=-correctionRadius;y<=correctionRadius;y++){if(x!=0||y!=0){neighborUv=vUv+vec2(x,y)*invTexSize;vec4 neigborVelocity=textureLod(velocityTexture,neighborUv,0.0);neighborDepth=neigborVelocity.b;col=textureLod(inputTexture,neighborUv,0.0).xyz;int absX=abs(x);int absY=abs(y);\n#ifdef dilation\nif(absX==1&&absY==1){if(neighborDepth>closestDepth){velocity=neigborVelocity;closestDepth=neighborDepth;}vec4 lastNeighborVelocity=textureLod(velocityTexture,vUv+vec2(x,y)*invTexSize,0.0);lastNeighborDepth=lastNeighborVelocity.b;if(neighborDepth>closestDepth){lastVelocity=lastNeighborVelocity;lastClosestDepth=lastNeighborDepth;}}\n#endif\nif(abs(depth-neighborDepth)<MAX_NEIGHBOR_DEPTH_DIFFERENCE){\n#ifdef boxBlur\nif(absX<=2&&absY<=2)boxBlurredColor+=col;\n#endif\ncol=transformColor(col);minNeighborColor=min(col,minNeighborColor);maxNeighborColor=max(col,maxNeighborColor);}}}}float velocityLength=length(lastVelocity.xy-velocity.xy);velocityDisocclusion=(velocityLength-0.000005)*10.0;velocityDisocclusion*=velocityDisocclusion;reprojectedUv=vUv-velocity.xy;\n#ifdef boxBlur\nfloat pxRadius=correctionRadius>5 ? 121.0 : pow(float(correctionRadius*2+1),2.0);boxBlurredColor/=pxRadius;boxBlurredColor=transformColor(boxBlurredColor);\n#endif\nif(reprojectedUv.x>=0.0&&reprojectedUv.x<=1.0&&reprojectedUv.y>=0.0&&reprojectedUv.y<=1.0){accumulatedTexel=textureLod(accumulatedTexture,reprojectedUv,0.0);accumulatedColor=transformColor(accumulatedTexel.rgb);vec3 clampedColor=clamp(accumulatedColor,minNeighborColor,maxNeighborColor);accumulatedColor=mix(accumulatedColor,clampedColor,correction);didReproject=true;}else{\n#ifdef boxBlur\naccumulatedColor=boxBlurredColor;\n#else\naccumulatedColor=inputColor;\n#endif\n}if(velocity.r>FLOAT_ONE_MINUS_EPSILON&&velocity.g>FLOAT_ONE_MINUS_EPSILON){alpha=0.0;velocityDisocclusion=1.0;}}else{accumulatedColor=transformColor(textureLod(accumulatedTexture,vUv,0.0).rgb);}vec3 outputColor=inputColor;\n#include <custom_compose_shader>\ngl_FragColor=vec4(undoColorTransform(outputColor),alpha);}";
var TemporalResolveMaterial = class extends ShaderMaterial {
  constructor(customComposeShader) {
    const fragmentShader2 = temporalResolve.replace("#include <custom_compose_shader>", customComposeShader);
    super({
      type: "TemporalResolveMaterial",
      uniforms: {
        inputTexture: new Uniform(null),
        accumulatedTexture: new Uniform(null),
        velocityTexture: new Uniform(null),
        lastVelocityTexture: new Uniform(null),
        samples: new Uniform(1),
        blend: new Uniform(0.5),
        correction: new Uniform(1),
        exponent: new Uniform(1),
        invTexSize: new Uniform(new Vector2())
      },
      defines: {
        correctionRadius: 1
      },
      vertexShader,
      fragmentShader: fragmentShader2
    });
  }
};
var prev_skinning_pars_vertex = `
		#ifdef USE_SKINNING
		#ifdef BONE_TEXTURE
			uniform sampler2D prevBoneTexture;
			mat4 getPrevBoneMatrix( const in float i ) {
				float j = i * 4.0;
				float x = mod( j, float( boneTextureSize ) );
				float y = floor( j / float( boneTextureSize ) );
				float dx = 1.0 / float( boneTextureSize );
				float dy = 1.0 / float( boneTextureSize );
				y = dy * ( y + 0.5 );
				vec4 v1 = texture2D( prevBoneTexture, vec2( dx * ( x + 0.5 ), y ) );
				vec4 v2 = texture2D( prevBoneTexture, vec2( dx * ( x + 1.5 ), y ) );
				vec4 v3 = texture2D( prevBoneTexture, vec2( dx * ( x + 2.5 ), y ) );
				vec4 v4 = texture2D( prevBoneTexture, vec2( dx * ( x + 3.5 ), y ) );
				mat4 bone = mat4( v1, v2, v3, v4 );
				return bone;
			}
		#else
			uniform mat4 prevBoneMatrices[ MAX_BONES ];
			mat4 getPrevBoneMatrix( const in float i ) {
				mat4 bone = prevBoneMatrices[ int(i) ];
				return bone;
			}
		#endif
		#endif
`;
var velocity_vertex = `
		vec3 transformed;

		// Get the normal
		${ShaderChunk.skinbase_vertex}
		${ShaderChunk.beginnormal_vertex}
		${ShaderChunk.skinnormal_vertex}
		${ShaderChunk.defaultnormal_vertex}

		// Get the current vertex position
		transformed = vec3( position );
		${ShaderChunk.skinning_vertex}
		newPosition = velocityMatrix * vec4( transformed, 1.0 );

		// Get the previous vertex position
		transformed = vec3( position );
		${ShaderChunk.skinbase_vertex.replace(/mat4 /g, "").replace(/getBoneMatrix/g, "getPrevBoneMatrix")}
		${ShaderChunk.skinning_vertex.replace(/vec4 /g, "")}
		prevPosition = prevVelocityMatrix * vec4( transformed, 1.0 );

		gl_Position = newPosition;
`;
var VelocityMaterial = class extends ShaderMaterial {
  constructor() {
    super({
      uniforms: {
        prevVelocityMatrix: {
          value: new Matrix4()
        },
        velocityMatrix: {
          value: new Matrix4()
        },
        prevBoneTexture: {
          value: null
        },
        interpolateGeometry: {
          value: 0
        },
        intensity: {
          value: 1
        },
        boneTexture: {
          value: null
        },
        alphaTest: {
          value: 0
        },
        map: {
          value: null
        },
        alphaMap: {
          value: null
        },
        opacity: {
          value: 1
        }
      },
      vertexShader: `
                    #define MAX_BONES 1024
                    
                    ${ShaderChunk.skinning_pars_vertex}
                    ${prev_skinning_pars_vertex}
        
                    uniform mat4 velocityMatrix;
                    uniform mat4 prevVelocityMatrix;
                    uniform float interpolateGeometry;
                    varying vec4 prevPosition;
                    varying vec4 newPosition;
					varying vec2 vHighPrecisionZW;
        
                    void main() {
        
                        ${velocity_vertex}

						vHighPrecisionZW = gl_Position.zw;
        
                    }`,
      fragmentShader: `
                    uniform float intensity;
                    varying vec4 prevPosition;
                    varying vec4 newPosition;
					varying vec2 vHighPrecisionZW;
        
                    void main() {
						#ifdef FULL_MOVEMENT
						gl_FragColor = vec4( 1., 1., 1. - gl_FragCoord.z, 0. );
						return;
						#endif

                        vec2 pos0 = (prevPosition.xy / prevPosition.w) * 0.5 + 0.5;
                        vec2 pos1 = (newPosition.xy / newPosition.w) * 0.5 + 0.5;
        
                        vec2 vel = pos1 - pos0;

						float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
                        
                        gl_FragColor = vec4( vel, 1. - fragCoordZ, 0. );
        
                    }`
    });
    this.isVelocityMaterial = true;
  }
};
var backgroundColor = new Color(0);
var updateProperties = ["visible", "wireframe", "side"];
var VelocityPass = class extends Pass {
  constructor(scene, camera) {
    var _window, _window2;
    super("VelocityPass");
    this.cachedMaterials = /* @__PURE__ */ new WeakMap();
    this.lastCameraTransform = {
      position: new Vector3(),
      quaternion: new Quaternion()
    };
    this.visibleMeshes = [];
    this.renderedMeshesThisFrame = 0;
    this.renderedMeshesLastFrame = 0;
    this._scene = scene;
    this._camera = camera;
    this.renderTarget = new WebGLRenderTarget(((_window = window) == null ? void 0 : _window.innerWidth) || 1e3, ((_window2 = window) == null ? void 0 : _window2.innerHeight) || 1e3, {
      type: HalfFloatType
    });
  }
  setVelocityMaterialInScene() {
    this.renderedMeshesThisFrame = 0;
    this.visibleMeshes = getVisibleChildren(this._scene);
    for (const c2 of this.visibleMeshes) {
      var _c$skeleton2;
      const originalMaterial = c2.material;
      let [cachedOriginalMaterial, velocityMaterial] = this.cachedMaterials.get(c2) || [];
      if (originalMaterial !== cachedOriginalMaterial) {
        var _c$skeleton;
        velocityMaterial = new VelocityMaterial();
        velocityMaterial.lastMatrixWorld = new Matrix4();
        c2.material = velocityMaterial;
        if ((_c$skeleton = c2.skeleton) != null && _c$skeleton.boneTexture)
          this.saveBoneTexture(c2);
        this.cachedMaterials.set(c2, [originalMaterial, velocityMaterial]);
      }
      velocityMaterial.uniforms.velocityMatrix.value.multiplyMatrices(this._camera.projectionMatrix, c2.modelViewMatrix);
      if (c2.userData.needsUpdatedReflections || originalMaterial.map instanceof VideoTexture) {
        if (!("FULL_MOVEMENT" in velocityMaterial.defines))
          velocityMaterial.needsUpdate = true;
        velocityMaterial.defines.FULL_MOVEMENT = "";
      } else {
        if ("FULL_MOVEMENT" in velocityMaterial.defines) {
          delete velocityMaterial.defines.FULL_MOVEMENT;
          velocityMaterial.needsUpdate = true;
        }
      }
      c2.visible = this.cameraMovedThisFrame || !c2.matrixWorld.equals(velocityMaterial.lastMatrixWorld) || c2.skeleton || "FULL_MOVEMENT" in velocityMaterial.defines;
      c2.material = velocityMaterial;
      if (!c2.visible)
        continue;
      this.renderedMeshesThisFrame++;
      for (const prop of updateProperties)
        velocityMaterial[prop] = originalMaterial[prop];
      if ((_c$skeleton2 = c2.skeleton) != null && _c$skeleton2.boneTexture) {
        velocityMaterial.defines.USE_SKINNING = "";
        velocityMaterial.defines.BONE_TEXTURE = "";
        velocityMaterial.uniforms.boneTexture.value = c2.skeleton.boneTexture;
      }
    }
  }
  saveBoneTexture(object) {
    let boneTexture = object.material.uniforms.prevBoneTexture.value;
    if (boneTexture && boneTexture.image.width === object.skeleton.boneTexture.width) {
      boneTexture = object.material.uniforms.prevBoneTexture.value;
      boneTexture.image.data.set(object.skeleton.boneTexture.image.data);
    } else {
      var _boneTexture;
      (_boneTexture = boneTexture) == null ? void 0 : _boneTexture.dispose();
      const boneMatrices = object.skeleton.boneTexture.image.data.slice();
      const size2 = object.skeleton.boneTexture.image.width;
      boneTexture = new DataTexture(boneMatrices, size2, size2, RGBAFormat, FloatType);
      object.material.uniforms.prevBoneTexture.value = boneTexture;
      boneTexture.needsUpdate = true;
    }
  }
  unsetVelocityMaterialInScene() {
    for (const c2 of this.visibleMeshes) {
      if (c2.material.isVelocityMaterial) {
        var _c$skeleton3;
        c2.visible = true;
        c2.material.lastMatrixWorld.copy(c2.matrixWorld);
        c2.material.uniforms.prevVelocityMatrix.value.multiplyMatrices(this._camera.projectionMatrix, c2.modelViewMatrix);
        if ((_c$skeleton3 = c2.skeleton) != null && _c$skeleton3.boneTexture)
          this.saveBoneTexture(c2);
        c2.material = this.cachedMaterials.get(c2)[0];
      }
    }
  }
  setSize(width, height) {
    this.renderTarget.setSize(width, height);
  }
  renderVelocity(renderer) {
    renderer.setRenderTarget(this.renderTarget);
    if (this.renderedMeshesThisFrame > 0) {
      const {
        background
      } = this._scene;
      this._scene.background = backgroundColor;
      renderer.render(this._scene, this._camera);
      this._scene.background = background;
    } else {
      renderer.clearColor();
    }
  }
  checkCameraMoved() {
    const moveDist = this.lastCameraTransform.position.distanceToSquared(this._camera.position);
    const rotateDist = 8 * (1 - this.lastCameraTransform.quaternion.dot(this._camera.quaternion));
    if (moveDist > 1e-6 || rotateDist > 1e-6) {
      this.lastCameraTransform.position.copy(this._camera.position);
      this.lastCameraTransform.quaternion.copy(this._camera.quaternion);
      return true;
    }
    return false;
  }
  render(renderer) {
    this.cameraMovedThisFrame = this.checkCameraMoved();
    this.setVelocityMaterialInScene();
    if (this.renderedMeshesThisFrame > 0 || this.renderedMeshesLastFrame > 0)
      this.renderVelocity(renderer);
    this.unsetVelocityMaterialInScene();
    this.renderedMeshesLastFrame = this.renderedMeshesThisFrame;
  }
};
var zeroVec2 = new Vector2();
var TemporalResolvePass = class extends Pass {
  constructor(scene, camera, customComposeShader, options = {}) {
    super("TemporalResolvePass");
    this.velocityPass = null;
    this.velocityResolutionScale = 1;
    this.samples = 1;
    this.lastCameraTransform = {
      position: new Vector3(),
      quaternion: new Quaternion()
    };
    this._scene = scene;
    this._camera = camera;
    this.renderTarget = new WebGLRenderTarget(1, 1, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      type: HalfFloatType,
      depthBuffer: false
    });
    this.velocityPass = new VelocityPass(scene, camera);
    this.fullscreenMaterial = new TemporalResolveMaterial(customComposeShader);
    this.fullscreenMaterial.defines.correctionRadius = options.correctionRadius || 1;
    if (options.dilation)
      this.fullscreenMaterial.defines.dilation = "";
    if (options.boxBlur)
      this.fullscreenMaterial.defines.boxBlur = "";
    this.setupFramebuffers(1, 1);
    this.checkCanUseSharedVelocityTexture();
  }
  dispose() {
    if (this._scene.userData.velocityTexture === this.velocityPass.renderTarget.texture) {
      delete this._scene.userData.velocityTexture;
      delete this._scene.userData.lastVelocityTexture;
    }
    this.renderTarget.dispose();
    this.accumulatedTexture.dispose();
    this.fullscreenMaterial.dispose();
    this.velocityPass.dispose();
  }
  setSize(width, height) {
    this.renderTarget.setSize(width, height);
    this.velocityPass.setSize(width * this.velocityResolutionScale, height * this.velocityResolutionScale);
    this.velocityPass.renderTarget.texture.minFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter;
    this.velocityPass.renderTarget.texture.magFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter;
    this.velocityPass.renderTarget.texture.needsUpdate = true;
    this.fullscreenMaterial.uniforms.invTexSize.value.set(1 / width, 1 / height);
    this.setupFramebuffers(width, height);
  }
  setupFramebuffers(width, height) {
    if (this.accumulatedTexture)
      this.accumulatedTexture.dispose();
    if (this.lastVelocityTexture)
      this.lastVelocityTexture.dispose();
    this.accumulatedTexture = new FramebufferTexture(width, height, RGBAFormat);
    this.accumulatedTexture.minFilter = LinearFilter;
    this.accumulatedTexture.magFilter = LinearFilter;
    this.accumulatedTexture.type = HalfFloatType;
    this.lastVelocityTexture = new FramebufferTexture(width * this.velocityResolutionScale, height * this.velocityResolutionScale, RGBAFormat);
    this.lastVelocityTexture.minFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter;
    this.lastVelocityTexture.magFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter;
    this.lastVelocityTexture.type = HalfFloatType;
    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.accumulatedTexture;
    this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this.lastVelocityTexture;
    this.fullscreenMaterial.needsUpdate = true;
  }
  checkCanUseSharedVelocityTexture() {
    const canUseSharedVelocityTexture = this._scene.userData.velocityTexture && this.velocityPass.renderTarget.texture !== this._scene.userData.velocityTexture;
    if (canUseSharedVelocityTexture) {
      if (this.velocityPass.renderTarget.texture === this.fullscreenMaterial.uniforms.velocityTexture.value) {
        this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this._scene.userData.lastVelocityTexture;
        this.fullscreenMaterial.uniforms.velocityTexture.value = this._scene.userData.velocityTexture;
        this.fullscreenMaterial.needsUpdate = true;
      }
    } else {
      if (this.velocityPass.renderTarget.texture !== this.fullscreenMaterial.uniforms.velocityTexture.value) {
        this.fullscreenMaterial.uniforms.velocityTexture.value = this.velocityPass.renderTarget.texture;
        this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this.lastVelocityTexture;
        this.fullscreenMaterial.needsUpdate = true;
        if (!this._scene.userData.velocityTexture) {
          this._scene.userData.velocityTexture = this.velocityPass.renderTarget.texture;
          this._scene.userData.lastVelocityTexture = this.lastVelocityTexture;
        }
      }
    }
    return this.velocityPass.renderTarget.texture !== this.fullscreenMaterial.uniforms.velocityTexture.value;
  }
  checkNeedsResample() {
    const moveDist = this.lastCameraTransform.position.distanceToSquared(this._camera.position);
    const rotateDist = 8 * (1 - this.lastCameraTransform.quaternion.dot(this._camera.quaternion));
    if (moveDist > 1e-6 || rotateDist > 1e-6) {
      this.samples = 1;
      this.lastCameraTransform.position.copy(this._camera.position);
      this.lastCameraTransform.quaternion.copy(this._camera.quaternion);
    }
  }
  render(renderer) {
    this.samples++;
    this.checkNeedsResample();
    this.fullscreenMaterial.uniforms.samples.value = this.samples;
    renderer.setRenderTarget(this.renderTarget);
    renderer.render(this.scene, this.camera);
    renderer.copyFramebufferToTexture(zeroVec2, this.accumulatedTexture);
    renderer.setRenderTarget(this.velocityPass.renderTarget);
    renderer.copyFramebufferToTexture(zeroVec2, this.lastVelocityTexture);
  }
};
var halton = function halton2(index, base) {
  let fraction = 1;
  let result = 0;
  while (index > 0) {
    fraction /= base;
    result += fraction * (index % base);
    index = ~~(index / base);
  }
  return result;
};
var generateHalton23Points = (count) => {
  const data = [];
  let i2 = 1;
  const end = i2 + count;
  for (; i2 < end; i2++) {
    data.push([halton(i2, 2) - 0.5, halton(i2, 3) - 0.5]);
  }
  return data;
};
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
var worldposReplace = `
#if defined( USE_ENVMAP ) || defined(  ) || defined ( USE_SHADOWMAP )
    vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );

    #ifdef BOX_PROJECTED_ENV_MAP
        vWorldPosition = worldPosition.xyz;
    #endif
#endif
`;
var boxProjectDefinitions = `
#ifdef BOX_PROJECTED_ENV_MAP
    uniform vec3 envMapSize;
    uniform vec3 envMapPosition;
    varying vec3 vWorldPosition;
    
    vec3 parallaxCorrectNormal( vec3 v, vec3 cubeSize, vec3 cubePos ) {
        vec3 nDir = normalize( v );

        vec3 rbmax = ( .5 * cubeSize + cubePos - vWorldPosition ) / nDir;
        vec3 rbmin = ( -.5 * cubeSize + cubePos - vWorldPosition ) / nDir;

        vec3 rbminmax;

        rbminmax.x = ( nDir.x > 0. ) ? rbmax.x : rbmin.x;
        rbminmax.y = ( nDir.y > 0. ) ? rbmax.y : rbmin.y;
        rbminmax.z = ( nDir.z > 0. ) ? rbmax.z : rbmin.z;

        float correction = min( min( rbminmax.x, rbminmax.y ), rbminmax.z );
        vec3 boxIntersection = vWorldPosition + nDir * correction;
        
        return boxIntersection - cubePos;
    }
#endif
`;
var getIBLIrradiance_patch = `
#ifdef BOX_PROJECTED_ENV_MAP
    worldNormal = parallaxCorrectNormal( worldNormal, envMapSize, envMapPosition );
#endif
`;
var getIBLRadiance_patch = `
#ifdef BOX_PROJECTED_ENV_MAP
    reflectVec = parallaxCorrectNormal( reflectVec, envMapSize, envMapPosition );
#endif
`;
function useBoxProjectedEnvMap(shader, envMapPosition, envMapSize) {
  shader.defines.BOX_PROJECTED_ENV_MAP = "";
  shader.uniforms.envMapPosition = {
    value: envMapPosition
  };
  shader.uniforms.envMapSize = {
    value: envMapSize
  };
  const line1 = new RegExp(escapeRegExp("vec3 worldNormal = inverseTransformDirection ( normal , viewMatrix ) ;").replaceAll(" ", "\\s*"), "g");
  const line2 = new RegExp(escapeRegExp("reflectVec = inverseTransformDirection ( reflectVec , viewMatrix ) ;").replaceAll(" ", "\\s*"), "g");
  shader.vertexShader = "varying vec3 vWorldPosition;\n" + shader.vertexShader.replace("#include <worldpos_vertex>", worldposReplace);
  shader.fragmentShader = boxProjectDefinitions + "\n" + shader.fragmentShader.replace("#include <envmap_physical_pars_fragment>", ShaderChunk.envmap_physical_pars_fragment).replace(line1, `vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
                ${getIBLIrradiance_patch}`).replace(line2, `reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
                ${getIBLRadiance_patch}`);
}
var finalFragmentShader = finalSSRShader.replace("#include <helperFunctions>", helperFunctions).replace("#include <boxBlur>", boxBlur);
var noResetSamplesProperties = ["blur", "blurSharpness", "blurKernel"];
var defaultCubeRenderTarget = new WebGLCubeRenderTarget(1);
var pmremGenerator;
var SSREffect = class extends Effect {
  constructor(scene, camera, options = defaultSSROptions) {
    super("SSREffect", finalFragmentShader, {
      type: "FinalSSRMaterial",
      uniforms: /* @__PURE__ */ new Map([["reflectionsTexture", new Uniform(null)], ["blur", new Uniform(0)], ["blurSharpness", new Uniform(0)], ["blurKernel", new Uniform(0)]]),
      defines: /* @__PURE__ */ new Map([["RENDER_MODE", "0"]])
    });
    this.haltonSequence = generateHalton23Points(1024);
    this.haltonIndex = 0;
    this.selection = new Selection();
    this.lastSize = void 0;
    this.cubeCamera = new CubeCamera(1e-3, 1e3, defaultCubeRenderTarget);
    this.usingBoxProjectedEnvMap = false;
    this._scene = scene;
    this._camera = camera;
    const trOptions = {
      boxBlur: true,
      dilation: true
    };
    options = _extends2({}, defaultSSROptions, options, trOptions);
    this.temporalResolvePass = new TemporalResolvePass(scene, camera, trCompose, options);
    this.uniforms.get("reflectionsTexture").value = this.temporalResolvePass.renderTarget.texture;
    this.reflectionsPass = new ReflectionsPass(this, options);
    this.temporalResolvePass.fullscreenMaterial.uniforms.inputTexture.value = this.reflectionsPass.renderTarget.texture;
    this.lastSize = {
      width: options.width,
      height: options.height,
      resolutionScale: options.resolutionScale,
      velocityResolutionScale: options.velocityResolutionScale
    };
    this.setSize(options.width, options.height);
    this.makeOptionsReactive(options);
  }
  makeOptionsReactive(options) {
    let needsUpdate = false;
    const reflectionPassFullscreenMaterialUniforms = this.reflectionsPass.fullscreenMaterial.uniforms;
    const reflectionPassFullscreenMaterialUniformsKeys = Object.keys(reflectionPassFullscreenMaterialUniforms);
    for (const key of Object.keys(options)) {
      Object.defineProperty(this, key, {
        get() {
          return options[key];
        },
        set(value) {
          if (options[key] === value && needsUpdate)
            return;
          options[key] = value;
          if (!noResetSamplesProperties.includes(key)) {
            this.setSize(this.lastSize.width, this.lastSize.height, true);
          }
          switch (key) {
            case "resolutionScale":
              this.setSize(this.lastSize.width, this.lastSize.height);
              break;
            case "velocityResolutionScale":
              this.temporalResolvePass.velocityResolutionScale = value;
              this.setSize(this.lastSize.width, this.lastSize.height, true);
              break;
            case "blur":
              this.uniforms.get("blur").value = value;
              break;
            case "blurSharpness":
              this.uniforms.get("blurSharpness").value = value;
              break;
            case "blurKernel":
              this.uniforms.get("blurKernel").value = value;
              break;
            case "steps":
              this.reflectionsPass.fullscreenMaterial.defines.steps = parseInt(value);
              this.reflectionsPass.fullscreenMaterial.needsUpdate = needsUpdate;
              break;
            case "refineSteps":
              this.reflectionsPass.fullscreenMaterial.defines.refineSteps = parseInt(value);
              this.reflectionsPass.fullscreenMaterial.needsUpdate = needsUpdate;
              break;
            case "missedRays":
              if (value) {
                this.reflectionsPass.fullscreenMaterial.defines.missedRays = "";
              } else {
                delete this.reflectionsPass.fullscreenMaterial.defines.missedRays;
              }
              this.reflectionsPass.fullscreenMaterial.needsUpdate = needsUpdate;
              break;
            case "correctionRadius":
              this.temporalResolvePass.fullscreenMaterial.defines.correctionRadius = Math.round(value);
              this.temporalResolvePass.fullscreenMaterial.needsUpdate = needsUpdate;
              break;
            case "blend":
              this.temporalResolvePass.fullscreenMaterial.uniforms.blend.value = value;
              break;
            case "correction":
              this.temporalResolvePass.fullscreenMaterial.uniforms.correction.value = value;
              break;
            case "exponent":
              this.temporalResolvePass.fullscreenMaterial.uniforms.exponent.value = value;
              break;
            case "distance":
              reflectionPassFullscreenMaterialUniforms.rayDistance.value = value;
            default:
              if (reflectionPassFullscreenMaterialUniformsKeys.includes(key)) {
                reflectionPassFullscreenMaterialUniforms[key].value = value;
              }
          }
        }
      });
      this[key] = options[key];
    }
    needsUpdate = true;
  }
  setSize(width, height, force = false) {
    if (!force && width === this.lastSize.width && height === this.lastSize.height && this.resolutionScale === this.lastSize.resolutionScale && this.velocityResolutionScale === this.lastSize.velocityResolutionScale)
      return;
    this.temporalResolvePass.setSize(width, height);
    this.reflectionsPass.setSize(width, height);
    this.lastSize = {
      width,
      height,
      resolutionScale: this.resolutionScale,
      velocityResolutionScale: this.velocityResolutionScale
    };
  }
  generateBoxProjectedEnvMapFallback(renderer, position = new Vector3(), size2 = new Vector3(), envMapSize = 512) {
    this.cubeCamera.renderTarget.dispose();
    this.cubeCamera.renderTarget = new WebGLCubeRenderTarget(envMapSize);
    this.cubeCamera.position.copy(position);
    this.cubeCamera.updateMatrixWorld();
    this.cubeCamera.update(renderer, this._scene);
    if (!pmremGenerator) {
      pmremGenerator = new PMREMGenerator(renderer);
      pmremGenerator.compileCubemapShader();
    }
    const envMap = pmremGenerator.fromCubemap(this.cubeCamera.renderTarget.texture).texture;
    envMap.minFilter = LinearFilter;
    envMap.magFilter = LinearFilter;
    const reflectionsMaterial = this.reflectionsPass.fullscreenMaterial;
    useBoxProjectedEnvMap(reflectionsMaterial, position, size2);
    reflectionsMaterial.fragmentShader = reflectionsMaterial.fragmentShader.replace("vec3 worldPos", "worldPos").replace("varying vec3 vWorldPosition;", "vec3 worldPos;");
    reflectionsMaterial.uniforms.envMapPosition.value.copy(position);
    reflectionsMaterial.uniforms.envMapSize.value.copy(size2);
    setupEnvMap(reflectionsMaterial, envMap, envMapSize);
    this.usingBoxProjectedEnvMap = true;
    return envMap;
  }
  setIBLRadiance(iblRadiance, renderer) {
    this._scene.traverse((c2) => {
      if (c2.material) {
        var _renderer$properties$;
        const uniforms = (_renderer$properties$ = renderer.properties.get(c2.material)) == null ? void 0 : _renderer$properties$.uniforms;
        if (uniforms && "disableIBLRadiance" in uniforms) {
          uniforms.disableIBLRadiance.value = iblRadiance;
        }
      }
    });
  }
  deleteBoxProjectedEnvMapFallback() {
    const reflectionsMaterial = this.reflectionsPass.fullscreenMaterial;
    reflectionsMaterial.uniforms.envMap.value = null;
    reflectionsMaterial.fragmentShader = reflectionsMaterial.fragmentShader.replace("worldPos = ", "vec3 worldPos = ");
    delete reflectionsMaterial.defines.BOX_PROJECTED_ENV_MAP;
    reflectionsMaterial.needsUpdate = true;
    this.usingBoxProjectedEnvMap = false;
  }
  dispose() {
    super.dispose();
    this.reflectionsPass.dispose();
    this.temporalResolvePass.dispose();
  }
  update(renderer, inputBuffer) {
    if (!this.usingBoxProjectedEnvMap && this._scene.environment) {
      const reflectionsMaterial = this.reflectionsPass.fullscreenMaterial;
      let envMap = null;
      this._scene.traverse((c2) => {
        if (!envMap && c2.material && !c2.material.envMap) {
          const properties = renderer.properties.get(c2.material);
          if ("envMap" in properties && properties.envMap instanceof Texture)
            envMap = properties.envMap;
        }
      });
      if (envMap) {
        const envMapCubeUVHeight = this._scene.environment.image.height;
        setupEnvMap(reflectionsMaterial, envMap, envMapCubeUVHeight);
      }
    }
    this.haltonIndex = (this.haltonIndex + 1) % this.haltonSequence.length;
    const [x, y] = this.haltonSequence[this.haltonIndex];
    const {
      width,
      height
    } = this.lastSize;
    this.temporalResolvePass.velocityPass.render(renderer);
    if (this._camera.setViewOffset)
      this._camera.setViewOffset(width, height, x, y, width, height);
    this.reflectionsPass.render(renderer, inputBuffer);
    this.temporalResolvePass.render(renderer);
    this._camera.clearViewOffset();
  }
  static patchDirectEnvIntensity(envMapIntensity = 0) {
    if (envMapIntensity === 0) {
      ShaderChunk.envmap_physical_pars_fragment = ShaderChunk.envmap_physical_pars_fragment.replace("vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {", "vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) { return vec3(0.0);");
    } else {
      ShaderChunk.envmap_physical_pars_fragment = ShaderChunk.envmap_physical_pars_fragment.replace("vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );", "vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness ) * " + envMapIntensity.toFixed(5) + ";");
    }
  }
};

// node_modules/@react-three/postprocessing/dist/index.js
var isRef = (ref) => !!ref.current;
var resolveRef = (ref) => isRef(ref) ? ref.current : ref;
var wrapEffect = function(effectImpl, defaultBlendMode) {
  if (defaultBlendMode === void 0) {
    defaultBlendMode = BlendFunction.NORMAL;
  }
  return (0, import_react.forwardRef)(function Wrap(_ref, ref) {
    let {
      blendFunction,
      opacity,
      ...props
    } = _ref;
    const invalidate = useThree((state) => state.invalidate);
    const effect = (0, import_react.useMemo)(() => new effectImpl(props), [props]);
    (0, import_react.useLayoutEffect)(() => {
      effect.blendMode.blendFunction = !blendFunction && blendFunction !== 0 ? defaultBlendMode : blendFunction;
      if (opacity !== void 0)
        effect.blendMode.opacity.value = opacity;
      invalidate();
    }, [blendFunction, effect.blendMode, opacity]);
    return import_react.default.createElement("primitive", {
      ref,
      object: effect,
      dispose: null
    });
  });
};
var useVector2 = (props, key) => {
  const vec = props[key];
  return (0, import_react.useMemo)(() => {
    if (vec instanceof Vector2) {
      return new Vector2().set(vec.x, vec.y);
    } else if (Array.isArray(vec)) {
      const [x, y] = vec;
      return new Vector2().set(x, y);
    }
  }, [vec]);
};
var Bloom = wrapEffect(BloomEffect, BlendFunction.ADD);
var BrightnessContrast = wrapEffect(BrightnessContrastEffect);
var ChromaticAberration = (0, import_react.forwardRef)(function ChromaticAberration2(props, ref) {
  const offset = useVector2(props, "offset");
  const effect = (0, import_react.useMemo)(() => new ChromaticAberrationEffect({
    ...props,
    offset
  }), [offset, props]);
  return import_react.default.createElement("primitive", {
    ref,
    object: effect,
    dispose: null
  });
});
var ColorAverage = (0, import_react.forwardRef)(function ColorAverage2(_ref, ref) {
  let {
    blendFunction = BlendFunction.NORMAL
  } = _ref;
  const effect = (0, import_react.useMemo)(() => new ColorAverageEffect(blendFunction), [blendFunction]);
  return import_react.default.createElement("primitive", {
    ref,
    object: effect,
    dispose: null
  });
});
var ColorDepth = wrapEffect(ColorDepthEffect);
var Depth = wrapEffect(DepthEffect);
var EffectComposerContext = (0, import_react.createContext)(null);
var EffectComposer3 = import_react.default.memo((0, import_react.forwardRef)((_ref, ref) => {
  let {
    children,
    camera,
    scene,
    resolutionScale,
    enabled = true,
    renderPriority = 1,
    autoClear = true,
    depthBuffer,
    disableNormalPass,
    stencilBuffer,
    multisampling = 8,
    frameBufferType = HalfFloatType
  } = _ref;
  const {
    gl,
    scene: defaultScene,
    camera: defaultCamera,
    size: size2
  } = useThree();
  scene = scene || defaultScene;
  camera = camera || defaultCamera;
  const [composer, normalPass, downSamplingPass] = (0, import_react.useMemo)(() => {
    const webGL2Available2 = isWebGL2Available();
    const effectComposer = new EffectComposer(gl, {
      depthBuffer,
      stencilBuffer,
      multisampling: multisampling > 0 && webGL2Available2 ? multisampling : 0,
      frameBufferType
    });
    effectComposer.addPass(new RenderPass(scene, camera));
    let downSamplingPass2 = null;
    let normalPass2 = null;
    if (!disableNormalPass) {
      normalPass2 = new NormalPass(scene, camera);
      normalPass2.enabled = false;
      effectComposer.addPass(normalPass2);
      if (resolutionScale !== void 0 && webGL2Available2) {
        downSamplingPass2 = new DepthDownsamplingPass({
          normalBuffer: normalPass2.texture,
          resolutionScale
        });
        downSamplingPass2.enabled = false;
        effectComposer.addPass(downSamplingPass2);
      }
    }
    return [effectComposer, normalPass2, downSamplingPass2];
  }, [camera, gl, depthBuffer, stencilBuffer, multisampling, frameBufferType, scene, disableNormalPass, resolutionScale]);
  (0, import_react.useEffect)(() => composer == null ? void 0 : composer.setSize(size2.width, size2.height), [composer, size2]);
  useFrame((_, delta) => {
    if (enabled) {
      gl.autoClear = autoClear;
      composer.render(delta);
    }
  }, enabled ? renderPriority : 0);
  const group = (0, import_react.useRef)(null);
  (0, import_react.useLayoutEffect)(() => {
    let effectPass;
    if (group.current && group.current.__r3f && composer) {
      effectPass = new EffectPass(camera, ...group.current.__r3f.objects);
      effectPass.renderToScreen = true;
      composer.addPass(effectPass);
      if (normalPass)
        normalPass.enabled = true;
      if (downSamplingPass)
        downSamplingPass.enabled = true;
    }
    return () => {
      if (effectPass)
        composer == null ? void 0 : composer.removePass(effectPass);
      if (normalPass)
        normalPass.enabled = false;
      if (downSamplingPass)
        downSamplingPass.enabled = false;
    };
  }, [composer, children, camera, normalPass, downSamplingPass]);
  const state = (0, import_react.useMemo)(() => ({
    composer,
    normalPass,
    downSamplingPass,
    resolutionScale,
    camera,
    scene
  }), [composer, normalPass, downSamplingPass, resolutionScale, camera, scene]);
  (0, import_react.useImperativeHandle)(ref, () => composer, [composer]);
  return import_react.default.createElement(EffectComposerContext.Provider, {
    value: state
  }, import_react.default.createElement("group", {
    ref: group
  }, children));
}));
var DepthOfField = (0, import_react.forwardRef)(function DepthOfField2(_ref, ref) {
  let {
    target,
    depthTexture,
    ...props
  } = _ref;
  const invalidate = useThree((state) => state.invalidate);
  const {
    camera
  } = (0, import_react.useContext)(EffectComposerContext);
  const effect = (0, import_react.useMemo)(() => new DepthOfFieldEffect(camera, props), [camera, props]);
  (0, import_react.useLayoutEffect)(() => {
    if (target) {
      const vec = target instanceof Vector3 ? new Vector3().set(target.x, target.y, target.z) : new Vector3().set(target[0], target[1], target[2]);
      effect.target = vec;
    }
    if (depthTexture)
      effect.setDepthTexture(depthTexture.texture, depthTexture.packing);
    invalidate();
  }, [target, depthTexture, effect]);
  return import_react.default.createElement("primitive", {
    ref,
    object: effect,
    dispose: null
  });
});
var DotScreen = wrapEffect(DotScreenEffect);
var Glitch = (0, import_react.forwardRef)(function Glitch2(_ref, ref) {
  let {
    active = true,
    ...props
  } = _ref;
  const invalidate = useThree((state) => state.invalidate);
  const delay = useVector2(props, "delay");
  const duration = useVector2(props, "duration");
  const strength = useVector2(props, "strength");
  const effect = (0, import_react.useMemo)(() => new GlitchEffect({
    ...props,
    delay,
    duration,
    strength
  }), [delay, duration, props, strength]);
  (0, import_react.useLayoutEffect)(() => {
    effect.mode = active ? props.mode || GlitchMode.SPORADIC : GlitchMode.DISABLED;
    invalidate();
  }, [active, effect, props.mode]);
  return import_react.default.createElement("primitive", {
    ref,
    object: effect,
    dispose: null
  });
});
var GodRays = (0, import_react.forwardRef)(function GodRays2(props, ref) {
  const {
    camera
  } = (0, import_react.useContext)(EffectComposerContext);
  const effect = (0, import_react.useMemo)(() => new GodRaysEffect(camera, props.sun, props), [camera, props]);
  return import_react.default.createElement("primitive", {
    ref,
    object: effect,
    dispose: null
  });
});
var Grid = (0, import_react.forwardRef)(function Grid2(_ref, ref) {
  let {
    size: size2,
    ...props
  } = _ref;
  const invalidate = useThree((state) => state.invalidate);
  const effect = (0, import_react.useMemo)(() => new GridEffect(props), [props]);
  (0, import_react.useLayoutEffect)(() => {
    if (size2)
      effect.setSize(size2.width, size2.height);
    invalidate();
  }, [effect, size2]);
  return import_react.default.createElement("primitive", {
    ref,
    object: effect,
    dispose: null
  });
});
var HueSaturation = wrapEffect(HueSaturationEffect);
var Noise = wrapEffect(NoiseEffect, BlendFunction.COLOR_DODGE);
var selectionContext = (0, import_react.createContext)(null);
function Selection2(_ref) {
  let {
    children,
    enabled = true
  } = _ref;
  const [selected, select] = (0, import_react.useState)([]);
  const value = (0, import_react.useMemo)(() => ({
    selected,
    select,
    enabled
  }), [selected, select, enabled]);
  return import_react.default.createElement(selectionContext.Provider, {
    value
  }, children);
}
function Select(_ref2) {
  let {
    enabled = false,
    children,
    ...props
  } = _ref2;
  const group = (0, import_react.useRef)(null);
  const api = (0, import_react.useContext)(selectionContext);
  (0, import_react.useEffect)(() => {
    if (api && enabled) {
      let changed = false;
      const current = [];
      group.current.traverse((o) => {
        o.type === "Mesh" && current.push(o);
        if (api.selected.indexOf(o) === -1)
          changed = true;
      });
      if (changed) {
        api.select((state) => [...state, ...current]);
        return () => {
          api.select((state) => state.filter((selected) => !current.includes(selected)));
        };
      }
    }
  }, [enabled, children]);
  return import_react.default.createElement("group", _extends({
    ref: group
  }, props), children);
}
var Outline = (0, import_react.forwardRef)(function Outline2(_ref, forwardRef2) {
  let {
    selection = [],
    selectionLayer = 10,
    blendFunction,
    patternTexture,
    edgeStrength,
    pulseSpeed,
    visibleEdgeColor,
    hiddenEdgeColor,
    width,
    height,
    kernelSize,
    blur,
    xRay,
    ...props
  } = _ref;
  const invalidate = useThree((state) => state.invalidate);
  const {
    scene,
    camera
  } = (0, import_react.useContext)(EffectComposerContext);
  const effect = (0, import_react.useMemo)(() => new OutlineEffect(scene, camera, {
    blendFunction,
    patternTexture,
    edgeStrength,
    pulseSpeed,
    visibleEdgeColor,
    hiddenEdgeColor,
    width,
    height,
    kernelSize,
    blur,
    xRay,
    ...props
  }), [blendFunction, blur, camera, edgeStrength, height, hiddenEdgeColor, kernelSize, patternTexture, pulseSpeed, scene, visibleEdgeColor, width, xRay]);
  const api = (0, import_react.useContext)(selectionContext);
  (0, import_react.useEffect)(() => {
    if (!api && selection) {
      effect.selection.set(Array.isArray(selection) ? selection.map(resolveRef) : [resolveRef(selection)]);
      invalidate();
      return () => {
        effect.selection.clear();
        invalidate();
      };
    }
  }, [effect, selection, api]);
  (0, import_react.useEffect)(() => {
    effect.selectionLayer = selectionLayer;
    invalidate();
  }, [effect, selectionLayer]);
  (0, import_react.useRef)();
  (0, import_react.useEffect)(() => {
    if (api && api.enabled) {
      var _api$selected;
      if ((_api$selected = api.selected) != null && _api$selected.length) {
        effect.selection.set(api.selected);
        invalidate();
        return () => {
          effect.selection.clear();
          invalidate();
        };
      }
    }
  }, [api]);
  return import_react.default.createElement("primitive", {
    ref: forwardRef2,
    object: effect
  });
});
var Pixelation = (0, import_react.forwardRef)(function Pixelation2(_ref, ref) {
  let {
    granularity = 5
  } = _ref;
  const effect = (0, import_react.useMemo)(() => new PixelationEffect(granularity), [granularity]);
  return import_react.default.createElement("primitive", {
    ref,
    object: effect,
    dispose: null
  });
});
var Scanline = wrapEffect(ScanlineEffect, BlendFunction.OVERLAY);
var addLight = (light, effect) => light.layers.enable(effect.selection.layer);
var removeLight = (light, effect) => light.layers.disable(effect.selection.layer);
var SelectiveBloom = (0, import_react.forwardRef)(function SelectiveBloom2(_ref, forwardRef2) {
  let {
    selection = [],
    selectionLayer = 10,
    lights = [],
    luminanceThreshold,
    luminanceSmoothing,
    intensity,
    width,
    height,
    kernelSize,
    mipmapBlur,
    radius,
    levels,
    ...props
  } = _ref;
  if (lights.length === 0) {
    console.warn("SelectiveBloom requires lights to work.");
  }
  const invalidate = useThree((state) => state.invalidate);
  const {
    scene,
    camera
  } = (0, import_react.useContext)(EffectComposerContext);
  const effect = (0, import_react.useMemo)(() => new SelectiveBloomEffect(scene, camera, {
    blendFunction: BlendFunction.ADD,
    luminanceThreshold,
    luminanceSmoothing,
    intensity,
    width,
    height,
    kernelSize,
    mipmapBlur,
    radius,
    levels,
    ...props
  }), [camera, height, intensity, kernelSize, luminanceSmoothing, luminanceThreshold, scene, width, height, mipmapBlur, radius, levels]);
  const api = (0, import_react.useContext)(selectionContext);
  (0, import_react.useEffect)(() => {
    if (!api && selection) {
      effect.selection.set(Array.isArray(selection) ? selection.map(resolveRef) : [resolveRef(selection)]);
      invalidate();
      return () => {
        effect.selection.clear();
        invalidate();
      };
    }
  }, [effect, selection, api]);
  (0, import_react.useEffect)(() => {
    effect.selection.layer = selectionLayer;
    invalidate();
  }, [effect, selectionLayer]);
  (0, import_react.useEffect)(() => {
    if (lights && lights.length > 0) {
      lights.forEach((light) => addLight(resolveRef(light), effect));
      invalidate();
      return () => {
        lights.forEach((light) => removeLight(resolveRef(light), effect));
        invalidate();
      };
    }
  }, [effect, lights, selectionLayer]);
  (0, import_react.useRef)();
  (0, import_react.useEffect)(() => {
    if (api && api.enabled) {
      var _api$selected;
      if ((_api$selected = api.selected) != null && _api$selected.length) {
        effect.selection.set(api.selected);
        invalidate();
        return () => {
          effect.selection.clear();
          invalidate();
        };
      }
    }
  }, [api]);
  return import_react.default.createElement("primitive", {
    ref: forwardRef2,
    object: effect,
    dispose: null
  });
});
var Sepia = wrapEffect(SepiaEffect);
var SSAO = (0, import_react.forwardRef)(function SSAO2(props, ref) {
  const {
    camera,
    normalPass,
    downSamplingPass,
    resolutionScale
  } = (0, import_react.useContext)(EffectComposerContext);
  const effect = (0, import_react.useMemo)(() => {
    if (normalPass === null && downSamplingPass === null) {
      console.error("Please enable the NormalPass in the EffectComposer in order to use SSAO.");
      return null;
    }
    return new SSAOEffect(camera, normalPass && !downSamplingPass ? normalPass.texture : null, {
      blendFunction: BlendFunction.MULTIPLY,
      samples: 30,
      rings: 4,
      distanceThreshold: 1,
      distanceFalloff: 0,
      rangeThreshold: 0.5,
      rangeFalloff: 0.1,
      luminanceInfluence: 0.9,
      radius: 20,
      scale: 0.5,
      bias: 0.5,
      intensity: 1,
      color: null,
      normalDepthBuffer: downSamplingPass ? downSamplingPass.texture : null,
      resolutionScale: resolutionScale != null ? resolutionScale : 1,
      depthAwareUpsampling: true,
      ...props
    });
  }, [camera, normalPass, props]);
  return import_react.default.createElement("primitive", {
    ref,
    object: effect,
    dispose: null
  });
});
var SMAA = (0, import_react.forwardRef)(function SMAA2(_ref, ref) {
  let {
    preset = SMAAPreset.HIGH,
    edgeDetectionMode = EdgeDetectionMode.COLOR
  } = _ref;
  const smaaProps = useLoader(SMAAImageLoader, "");
  const effect = (0, import_react.useMemo)(() => new SMAAEffect(...smaaProps, preset, edgeDetectionMode), [smaaProps, preset, edgeDetectionMode]);
  return import_react.default.createElement("primitive", {
    ref,
    object: effect,
    dispose: null
  });
});
var Texture2 = (0, import_react.forwardRef)(function Texture3(_ref, ref) {
  let {
    textureSrc,
    texture: texture2,
    ...props
  } = _ref;
  const t2 = useLoader(TextureLoader, textureSrc);
  (0, import_react.useLayoutEffect)(() => {
    t2.encoding = sRGBEncoding;
    t2.wrapS = t2.wrapT = RepeatWrapping;
  }, [t2]);
  const effect = (0, import_react.useMemo)(() => new TextureEffect({
    ...props,
    texture: t2 || texture2
  }), [props, t2, texture2]);
  return import_react.default.createElement("primitive", {
    ref,
    object: effect,
    dispose: null
  });
});
var ToneMapping = wrapEffect(ToneMappingEffect);
var Vignette = wrapEffect(VignetteEffect);
var ShockWave = wrapEffect(ShockWaveEffect);
var LUT = (0, import_react.forwardRef)(function LUT2(_ref, ref) {
  let {
    lut,
    tetrahedralInterpolation,
    ...props
  } = _ref;
  const invalidate = useThree((state) => state.invalidate);
  const effect = (0, import_react.useMemo)(() => new LUT3DEffect(lut, props), [lut, props]);
  (0, import_react.useLayoutEffect)(() => {
    if (lut)
      effect.setLUT(lut);
    if (tetrahedralInterpolation)
      effect.setTetrahedralInterpolationEnabled(tetrahedralInterpolation);
    invalidate();
  }, [effect, lut, tetrahedralInterpolation]);
  return import_react.default.createElement("primitive", {
    ref,
    object: effect,
    dispose: null
  });
});
var TiltShift = wrapEffect(TiltShiftEffect, BlendFunction.ADD);
var SSR = (0, import_react.forwardRef)(function SSR2(_ref, ref) {
  let {
    ENABLE_BLUR = true,
    USE_MRT = true,
    ...props
  } = _ref;
  const {
    invalidate
  } = useThree();
  const {
    scene,
    camera
  } = (0, import_react.useContext)(EffectComposerContext);
  const effect = (0, import_react.useMemo)(() => new SSREffect(scene, camera, {
    ENABLE_BLUR,
    USE_MRT,
    ...props
  }), [SSREffect, scene, camera, ENABLE_BLUR, USE_MRT]);
  (0, import_react.useLayoutEffect)(() => {
    Object.keys(props).forEach((key) => effect[key] = props[key]);
    invalidate();
  }, [props]);
  const api = (0, import_react.useContext)(selectionContext);
  (0, import_react.useEffect)(() => {
    if (api && api.enabled) {
      var _api$selected;
      if ((_api$selected = api.selected) != null && _api$selected.length) {
        effect.selection.set(api.selected);
        invalidate();
        return () => {
          effect.selection.clear();
          invalidate();
        };
      }
    }
  }, [api]);
  return import_react.default.createElement("primitive", {
    ref,
    object: effect
  });
});
export {
  Bloom,
  BrightnessContrast,
  ChromaticAberration,
  ColorAverage,
  ColorDepth,
  Depth,
  DepthOfField,
  DotScreen,
  EffectComposer3 as EffectComposer,
  EffectComposerContext,
  Glitch,
  GodRays,
  Grid,
  HueSaturation,
  LUT,
  Noise,
  Outline,
  Pixelation,
  SMAA,
  SSAO,
  SSR,
  Scanline,
  Select,
  Selection2 as Selection,
  SelectiveBloom,
  Sepia,
  ShockWave,
  Texture2 as Texture,
  TiltShift,
  ToneMapping,
  Vignette,
  selectionContext
};
/**
 * postprocessing v6.29.1 build Thu Oct 27 2022
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2022 Raoul van Rüschen
 * @license Zlib
 */
//! A directional light source has a well-defined direction
//! A good example for a spot light is a light spot in
//! A point light source has a well-defined position
//! A spot light source emits light in a specific
//! The generic light level of the world, including the bounces
//! This light type doesn't have a valid position, direction, or
//! Typically, there's at most one ambient light in a scene.
//! angle. It has a position and a direction it is pointing to.
//! approximation for sun light.
//! but is infinitely far away. That's quite a good
//! directions. A normal bulb is a point light.
//! in space but no direction - it emits light in all
//! of all other lightsources.
//! other properties, just a color.
//! sport arenas.
//# sourceMappingURL=@react-three_postprocessing.js.map
